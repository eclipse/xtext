package org.eclipse.xtend.core.tests.macro;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend.core.compiler.XtendGenerator;
import org.eclipse.xtend.core.jvmmodel.IXtendJvmAssociations;
import org.eclipse.xtend.core.macro.declaration.CompilationUnitImpl;
import org.eclipse.xtend.core.macro.declaration.ExpressionImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmClassDeclarationImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmFieldDeclarationImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmMethodDeclarationImpl;
import org.eclipse.xtend.core.macro.declaration.ProblemSupportImpl;
import org.eclipse.xtend.core.macro.declaration.TracabilityImpl;
import org.eclipse.xtend.core.macro.declaration.TypeLookupImpl;
import org.eclipse.xtend.core.xtend.XtendFile;
import org.eclipse.xtend.lib.macro.declaration.AnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.AnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.Element;
import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.InterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableInterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMemberDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.expression.Expression;
import org.eclipse.xtend.lib.macro.services.Problem;
import org.eclipse.xtend.lib.macro.services.TypeReferenceProvider;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmIdentifiableElement;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.junit4.internal.LineDelimiters;
import org.eclipse.xtext.junit4.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.XExpression;
import org.eclipse.xtext.xbase.compiler.GeneratorConfig;
import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;
import org.eclipse.xtext.xbase.jvmmodel.ILogicalContainerProvider;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

@SuppressWarnings("all")
public abstract class AbstractReusableActiveAnnotationTests {
  @Inject
  private XtendGenerator generator;
  
  @Inject
  private IGeneratorConfigProvider generatorConfigProvider;
  
  @Inject
  private ValidationTestHelper validator;
  
  @Inject
  private ILogicalContainerProvider logicalContainerProvider;
  
  @Test
  public void testBug453273() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Target(ElementType.TYPE)");
    _builder.newLine();
    _builder.append("@Active(AddNestedTypesProcessor)");
    _builder.newLine();
    _builder.append("annotation AddNestedTypes {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AddNestedTypesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, RegisterGlobalsContext registerGlobalsContext) {");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(qualifiedName + \".NestedType\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(qualifiedName + \".NestedType.NestedType2\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(packageName + \".OtherTopLevelClass\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(packageName + \".OtherTopLevelClass.NestedType\")");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("   ");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("def String getPackageName(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("   \t  ");
    _builder.append("qualifiedName.substring(0,qualifiedName.lastIndexOf(\'.\'))");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddNestedTypes.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package my.client");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddNestedTypes");
    _builder_1.newLine();
    _builder_1.append("class TopLevelClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("my/client/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        XtendFile _xtendFile = it.getXtendFile();
        AbstractReusableActiveAnnotationTests.this.validator.assertNoErrors(_xtendFile);
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("my.client.TopLevelClass");
        Assert.assertNotNull(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        MutableClassDeclaration _findClass_1 = _typeLookup_1.findClass("my.client.TopLevelClass.NestedType");
        Assert.assertNotNull(_findClass_1);
        TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
        MutableClassDeclaration _findClass_2 = _typeLookup_2.findClass("my.client.TopLevelClass.NestedType.NestedType2");
        Assert.assertNotNull(_findClass_2);
        TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
        MutableClassDeclaration _findClass_3 = _typeLookup_3.findClass("my.client.OtherTopLevelClass");
        Assert.assertNotNull(_findClass_3);
        TypeLookupImpl _typeLookup_4 = it.getTypeLookup();
        MutableClassDeclaration _findClass_4 = _typeLookup_4.findClass("my.client.OtherTopLevelClass.NestedType");
        Assert.assertNotNull(_findClass_4);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testBug441081() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package bug441081");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("interface GenericInterface {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def <T> T m()");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Bug441081Processor)");
    _builder.newLine();
    _builder.append("annotation Bug441081 {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Bug441081Processor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces + #[findTypeGlobally(GenericInterface).newTypeReference]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.addMethod(\"m\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("returnType = addTypeParameter(\"T\", object).newTypeReference");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = \'");
    _builder.append("\'\'return null;\'");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = annotatedClass");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("bug441081/Bug441081.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("import bug441081.Bug441081");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Bug441081");
    _builder_1.newLine();
    _builder_1.append("class Bug441081Client {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("Bug441081Client.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration c = _typeLookup.findClass("Bug441081Client");
        MutableMethodDeclaration _findDeclaredMethod = c.findDeclaredMethod("m");
        TypeReference _returnType = _findDeclaredMethod.getReturnType();
        Type _type = _returnType.getType();
        final TypeParameterDeclaration typeParam = ((TypeParameterDeclaration) _type);
        Iterable<? extends TypeReference> _upperBounds = typeParam.getUpperBounds();
        boolean _isEmpty = IterableExtensions.isEmpty(_upperBounds);
        Assert.assertFalse(_isEmpty);
        XtendFile _xtendFile = it.getXtendFile();
        AbstractReusableActiveAnnotationTests.this.validator.assertNoIssues(_xtendFile);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testInferredMethodReturnType() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractMethodProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractMethodProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableMethodDeclaration annotatedMethod, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethod.declaringType.addField(annotatedMethod.simpleName + \'_field\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = annotatedMethod.returnType");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Client {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def bar() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("1");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def create new Integer(1) foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration foo = _typeLookup.findClass("myusercode.Client");
        MutableFieldDeclaration _findDeclaredField = foo.findDeclaredField("bar_field");
        final TypeReference barType = _findDeclaredField.getType();
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _primitiveInt = _typeReferenceProvider.getPrimitiveInt();
        AbstractReusableActiveAnnotationTests.this.assertSameType(barType, _primitiveInt);
        MutableMethodDeclaration _findDeclaredMethod = foo.findDeclaredMethod("bar");
        TypeReference _returnType = _findDeclaredMethod.getReturnType();
        AbstractReusableActiveAnnotationTests.this.assertSameType(barType, _returnType);
        MutableFieldDeclaration _findDeclaredField_1 = foo.findDeclaredField("foo_field");
        final TypeReference fooType = _findDeclaredField_1.getType();
        TypeReferenceProvider _typeReferenceProvider_1 = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider_1.newTypeReference(Integer.class);
        AbstractReusableActiveAnnotationTests.this.assertSameType(fooType, _newTypeReference);
        MutableMethodDeclaration _findDeclaredMethod_1 = foo.findDeclaredMethod("foo");
        TypeReference _returnType_1 = _findDeclaredMethod_1.getReturnType();
        AbstractReusableActiveAnnotationTests.this.assertSameType(fooType, _returnType_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testTracing() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(GettersProcessor)");
    _builder.newLine();
    _builder.append("annotation Getters {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class GettersProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.declaredFields.filter[isThePrimaryGeneratedJavaElement].forEach [field|");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("cls.addMethod(\"get\" + field.simpleName.toFirstUpper) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("primarySourceElement = field");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\"return this.\" + field.simpleName + \";\"]");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("field.markAsRead");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/Getters.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.Getters");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Getters");
    _builder_1.newLine();
    _builder_1.append("class Client {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val int bar = 1");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def create new Integer(1) foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Client");
        final MutableFieldDeclaration barField = cls.findDeclaredField("bar");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = cls.getDeclaredMethods();
        final Function1<MutableMethodDeclaration, Boolean> _function = new Function1<MutableMethodDeclaration, Boolean>() {
          @Override
          public Boolean apply(final MutableMethodDeclaration it) {
            String _simpleName = it.getSimpleName();
            return Boolean.valueOf(_simpleName.startsWith("get"));
          }
        };
        final Iterable<? extends MutableMethodDeclaration> getters = IterableExtensions.filter(_declaredMethods, _function);
        int _size = IterableExtensions.size(getters);
        Assert.assertEquals(1, _size);
        final MutableMethodDeclaration getBar = IterableExtensions.head(getters);
        String _simpleName = getBar.getSimpleName();
        Assert.assertEquals("getBar", _simpleName);
        final JvmField barJvmField = ((MutableJvmFieldDeclarationImpl) barField).getDelegate();
        final JvmOperation getBarJvmMethod = ((MutableJvmMethodDeclarationImpl) getBar).getDelegate();
        IXtendJvmAssociations _jvmModelAssociations = it.getJvmModelAssociations();
        IXtendJvmAssociations _jvmModelAssociations_1 = it.getJvmModelAssociations();
        EObject _primarySourceElement = _jvmModelAssociations_1.getPrimarySourceElement(barJvmField);
        final Set<EObject> elementsAssociatedWithBarField = _jvmModelAssociations.getJvmElements(_primarySourceElement);
        int _size_1 = elementsAssociatedWithBarField.size();
        Assert.assertEquals(2, _size_1);
        Object _get = ((Object[])Conversions.unwrapArray(elementsAssociatedWithBarField, Object.class))[0];
        Assert.assertEquals(barJvmField, _get);
        Object _get_1 = ((Object[])Conversions.unwrapArray(elementsAssociatedWithBarField, Object.class))[1];
        Assert.assertEquals(getBarJvmMethod, _get_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testTracing2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.typeParameters.head");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client<A> {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Client");
        final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
        TracabilityImpl _tracability = it.getTracability();
        Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = cls.getTypeParameters();
        MutableTypeParameterDeclaration _head = IterableExtensions.head(_typeParameters);
        final Element typeParameter = _tracability.getPrimarySourceElement(_head);
        TracabilityImpl _tracability_1 = it.getTracability();
        Element _primarySourceElement = _tracability_1.getPrimarySourceElement(fooMethod);
        Assert.assertEquals(typeParameter, _primarySourceElement);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testTracing3() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.extendedClass");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client extends Object{}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Client");
        final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
        TracabilityImpl _tracability = it.getTracability();
        TypeReference _extendedClass = cls.getExtendedClass();
        final Element extendsClause = _tracability.getPrimarySourceElement(_extendedClass);
        Assert.assertTrue((extendsClause instanceof TypeReference));
        TracabilityImpl _tracability_1 = it.getTracability();
        Element _primarySourceElement = _tracability_1.getPrimarySourceElement(((Element) fooMethod));
        Assert.assertEquals(extendsClause, _primarySourceElement);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testTracing4() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.annotations.head");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client extends Object{}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Client");
        final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
        TracabilityImpl _tracability = it.getTracability();
        Iterable<? extends AnnotationReference> _annotations = cls.getAnnotations();
        AnnotationReference _head = IterableExtensions.head(_annotations);
        final Element anno = _tracability.getPrimarySourceElement(_head);
        Assert.assertTrue((anno instanceof AnnotationReference));
        TracabilityImpl _tracability_1 = it.getTracability();
        Element _primarySourceElement = _tracability_1.getPrimarySourceElement(((Element) fooMethod));
        Assert.assertEquals(anno, _primarySourceElement);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testValidationPhase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ValidatingProcessor)");
    _builder.newLine();
    _builder.append("annotation ValidatingAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ValidatingProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Foo\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Bar\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doValidate(ClassDeclaration cls, extension ValidationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Baz\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"There were \" + cls.problems.size + \" problems\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ValidatingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ValidatingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Foo");
        ProblemSupportImpl _problemSupport = it.getProblemSupport();
        final List<? extends Problem> problems = _problemSupport.getProblems(cls);
        int _size = problems.size();
        Assert.assertEquals(4, _size);
        Problem _get = problems.get(0);
        String _message = _get.getMessage();
        Assert.assertEquals("Foo", _message);
        Problem _get_1 = problems.get(1);
        String _message_1 = _get_1.getMessage();
        Assert.assertEquals("Bar", _message_1);
        Problem _get_2 = problems.get(2);
        String _message_2 = _get_2.getMessage();
        Assert.assertEquals("Baz", _message_2);
        Problem _get_3 = problems.get(3);
        String _message_3 = _get_3.getMessage();
        Assert.assertEquals("There were 3 problems", _message_3);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testValidateLater() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractFieldProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ValidateLaterProcessor)");
    _builder.newLine();
    _builder.append("annotation ValidateLater {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ValidateLaterProcessor extends AbstractFieldProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableFieldDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("validateLater[ |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (type == primitiveBoolean)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("addWarning(\"The type was inferred and boolean\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ValidateLater.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@ValidateLater val foo = true");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration cls = _typeLookup.findClass("myusercode.Foo");
        ProblemSupportImpl _problemSupport = it.getProblemSupport();
        Iterable<? extends MutableFieldDeclaration> _declaredFields = cls.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        final List<? extends Problem> problems = _problemSupport.getProblems(_head);
        int _size = problems.size();
        Assert.assertEquals(1, _size);
        Problem _get = problems.get(0);
        String _message = _get.getMessage();
        Assert.assertEquals("The type was inferred and boolean", _message);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testNoMutationInValidationPhase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(EvilProcessor)");
    _builder.newLine();
    _builder.append("annotation EvilAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class EvilProcessor implements TransformationParticipant<MutableClassDeclaration>, ValidationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("final = false");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doValidate(List<? extends MutableClassDeclaration> classes, extension ValidationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("final = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/EvilAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@EvilAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        XtendFile _xtendFile = it.getXtendFile();
        Resource _eResource = _xtendFile.eResource();
        EList<Resource.Diagnostic> _errors = _eResource.getErrors();
        final Function1<Resource.Diagnostic, Boolean> _function = new Function1<Resource.Diagnostic, Boolean>() {
          @Override
          public Boolean apply(final Resource.Diagnostic it) {
            String _message = it.getMessage();
            return Boolean.valueOf(_message.contains("cannot be modified"));
          }
        };
        IterableExtensions.<Resource.Diagnostic>exists(_errors, _function);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetEmptyListAsAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("annotation Values {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] intValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("long[] longValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("short[] shortValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("double[] doubleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("float[] floatValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("byte[] byteValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleanValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("char[] charValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] stringValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] classValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Enum1[] enumValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Annotation2[] annotationValue");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum Enum1 {}");
    _builder.newLine();
    _builder.append("annotation Annotation2 {}");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("removeAnnotation(annotations.head)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("addAnnotation(Values.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setIntValue(\'intValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setLongValue(\'longValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setShortValue(\'shortValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setDoubleValue(\'doubleValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setFloatValue(\'floatValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setByteValue(\'byteValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setBooleanValue(\'booleanValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setCharValue(\'charValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setStringValue(\'stringValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'classValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'enumValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotationValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration foo = _typeLookup.findClass("myusercode.Foo");
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final Type annotationType = _typeLookup_1.findTypeGlobally("myannotation.Values");
        final AnnotationReference values = foo.findAnnotation(annotationType);
        int[] _intArrayValue = values.getIntArrayValue("intValue");
        int _size = ((List<Integer>)Conversions.doWrapArray(_intArrayValue)).size();
        Assert.assertEquals(0, _size);
        long[] _longArrayValue = values.getLongArrayValue("longValue");
        int _size_1 = ((List<Long>)Conversions.doWrapArray(_longArrayValue)).size();
        Assert.assertEquals(0, _size_1);
        short[] _shortArrayValue = values.getShortArrayValue("shortValue");
        int _size_2 = ((List<Short>)Conversions.doWrapArray(_shortArrayValue)).size();
        Assert.assertEquals(0, _size_2);
        double[] _doubleArrayValue = values.getDoubleArrayValue("doubleValue");
        int _size_3 = ((List<Double>)Conversions.doWrapArray(_doubleArrayValue)).size();
        Assert.assertEquals(0, _size_3);
        float[] _floatArrayValue = values.getFloatArrayValue("floatValue");
        int _size_4 = ((List<Float>)Conversions.doWrapArray(_floatArrayValue)).size();
        Assert.assertEquals(0, _size_4);
        byte[] _byteArrayValue = values.getByteArrayValue("byteValue");
        int _size_5 = ((List<Byte>)Conversions.doWrapArray(_byteArrayValue)).size();
        Assert.assertEquals(0, _size_5);
        boolean[] _booleanArrayValue = values.getBooleanArrayValue("booleanValue");
        int _size_6 = ((List<Boolean>)Conversions.doWrapArray(_booleanArrayValue)).size();
        Assert.assertEquals(0, _size_6);
        char[] _charArrayValue = values.getCharArrayValue("charValue");
        int _size_7 = ((List<Character>)Conversions.doWrapArray(_charArrayValue)).size();
        Assert.assertEquals(0, _size_7);
        String[] _stringArrayValue = values.getStringArrayValue("stringValue");
        int _size_8 = ((List<String>)Conversions.doWrapArray(_stringArrayValue)).size();
        Assert.assertEquals(0, _size_8);
        TypeReference[] _classArrayValue = values.getClassArrayValue("classValue");
        int _size_9 = ((List<TypeReference>)Conversions.doWrapArray(_classArrayValue)).size();
        Assert.assertEquals(0, _size_9);
        EnumerationValueDeclaration[] _enumArrayValue = values.getEnumArrayValue("enumValue");
        int _size_10 = ((List<EnumerationValueDeclaration>)Conversions.doWrapArray(_enumArrayValue)).size();
        Assert.assertEquals(0, _size_10);
        AnnotationReference[] _annotationArrayValue = values.getAnnotationArrayValue("annotationValue");
        int _size_11 = ((List<AnnotationReference>)Conversions.doWrapArray(_annotationArrayValue)).size();
        Assert.assertEquals(0, _size_11);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testInferredTypeReferences() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?> value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (field : declaredFields) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\'return 1;\']");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val myAnnotation = findAnnotation(MyAnnotation.findTypeGlobally)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val type = myAnnotation.getClassValue(\"value\").type as ClassDeclaration");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (field : type.declaredFields) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\'return 1;\']");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(Bar)");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val y = 1");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Bar {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val x = 1");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration foo = _typeLookup.findClass("myusercode.Foo");
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableClassDeclaration bar = _typeLookup_1.findClass("myusercode.Bar");
        MutableFieldDeclaration _findDeclaredField = foo.findDeclaredField("y");
        TypeReference _type = _findDeclaredField.getType();
        MutableMethodDeclaration _findDeclaredMethod = foo.findDeclaredMethod("y");
        TypeReference _returnType = _findDeclaredMethod.getReturnType();
        AbstractReusableActiveAnnotationTests.this.assertSameType(_type, _returnType);
        MutableFieldDeclaration _findDeclaredField_1 = bar.findDeclaredField("x");
        TypeReference _type_1 = _findDeclaredField_1.getType();
        MutableMethodDeclaration _findDeclaredMethod_1 = foo.findDeclaredMethod("x");
        TypeReference _returnType_1 = _findDeclaredMethod_1.getReturnType();
        AbstractReusableActiveAnnotationTests.this.assertSameType(_type_1, _returnType_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_1() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite color");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite[] colors");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?> type");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("SomeAnnotation annotation");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("SomeAnnotation[] annotations");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum BlackOrWhite {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BLACK, WHITE");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val someAnnotationType = findTypeGlobally(SomeAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val enumType = findTypeGlobally(\'myannotation.BlackOrWhite\') as EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val white = enumType.findDeclaredValue(\'WHITE\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val black = enumType.findDeclaredValue(\'BLACK\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'color\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingValue != white)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"color\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithColor = annotatedClass.addAnnotation(newAnnotationReference(anno) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'color\', black)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(anno)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingColorsValue = annoWithColor.getValue(\'colors\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingColorsValue.get(0) != white && existingColorsValue.get(1) != black && existingColorsValue.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"colors\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithColors = annotatedClass.addAnnotation(newAnnotationReference(annoWithColor) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'colors\', black, white)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithColor)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingType = annoWithColors.getValue(\'type\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingType != string)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"type\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithType = annotatedClass.addAnnotation(newAnnotationReference(annoWithColors) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'type\', annotatedClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithColors)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingTypes = annoWithType.getValue(\'types\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingTypes.get(0) != primitiveInt && existingTypes.get(1) != annotatedClass.newTypeReference && existingTypes.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"types\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithTypes = annotatedClass.addAnnotation(newAnnotationReference(annoWithType) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'types\', primitiveBoolean)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithType)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReference = annoWithTypes.getAnnotationValue(\'annotation\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (someAnnotationType != annotationReference.annotationTypeDeclaration)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"someAnnotationType != annotationReference.annotationTypeDeclaration\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithAnnotation = annotatedClass.addAnnotation(newAnnotationReference(annoWithTypes) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotation\', ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append(")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithTypes)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReferences = annoWithAnnotation.getAnnotationArrayValue(\'annotations\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (annotationReferences.size != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"annotationReferences.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationReferences.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (someAnnotationType != annotationTypeDeclaration)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\"someAnnotationType != annotationTypeDeclaration\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.addAnnotation(newAnnotationReference(annoWithAnnotation) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotations\', ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("],");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append(")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithAnnotation)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("color=BlackOrWhite.WHITE, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("colors=#[BlackOrWhite.WHITE, BlackOrWhite.BLACK], ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("type = String, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("types=#[Integer, MyClass],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation=@SomeAnnotation(true),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotations=#[@SomeAnnotation(true), @SomeAnnotation(true)]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        Type _findTypeGlobally = _typeLookup_1.findTypeGlobally("myannotation.BlackOrWhite");
        final EnumerationTypeDeclaration colorEnum = ((EnumerationTypeDeclaration) _findTypeGlobally);
        TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
        final Type annotationType = _typeLookup_2.findTypeGlobally("myannotation.ConfigurableAnnotation");
        final AnnotationReference annotation = clazz.findAnnotation(annotationType);
        EnumerationValueDeclaration _findDeclaredValue = colorEnum.findDeclaredValue("BLACK");
        Object _value = annotation.getValue("color");
        Assert.assertEquals(_findDeclaredValue, _value);
        Object _value_1 = annotation.getValue("colors");
        final Object[] colors = ((Object[]) _value_1);
        int _length = colors.length;
        Assert.assertEquals(2, _length);
        EnumerationValueDeclaration _findDeclaredValue_1 = colorEnum.findDeclaredValue("BLACK");
        Object _get = colors[0];
        Assert.assertEquals(_findDeclaredValue_1, _get);
        EnumerationValueDeclaration _findDeclaredValue_2 = colorEnum.findDeclaredValue("WHITE");
        Object _get_1 = colors[1];
        Assert.assertEquals(_findDeclaredValue_2, _get_1);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(clazz);
        Object _value_2 = annotation.getValue("type");
        Assert.assertEquals(_newTypeReference, _value_2);
        final TypeReference[] types = annotation.getClassArrayValue("types");
        int _length_1 = types.length;
        Assert.assertEquals(1, _length_1);
        TypeReferenceProvider _typeReferenceProvider_1 = it.getTypeReferenceProvider();
        TypeReference _primitiveBoolean = _typeReferenceProvider_1.getPrimitiveBoolean();
        Object _get_2 = types[0];
        Assert.assertEquals(_primitiveBoolean, _get_2);
        TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
        final Type someAnnotationType = _typeLookup_3.findTypeGlobally("myannotation.SomeAnnotation");
        final AnnotationReference annotationValue = annotation.getAnnotationValue("annotation");
        Assert.assertNotNull(annotationValue);
        AnnotationTypeDeclaration _annotationTypeDeclaration = annotationValue.getAnnotationTypeDeclaration();
        Assert.assertEquals(someAnnotationType, _annotationTypeDeclaration);
        boolean _booleanValue = annotationValue.getBooleanValue("value");
        Assert.assertFalse(_booleanValue);
        final AnnotationReference[] annotationsValue = annotation.getAnnotationArrayValue("annotations");
        Assert.assertNotNull(annotationsValue);
        int _size = ((List<AnnotationReference>)Conversions.doWrapArray(annotationsValue)).size();
        Assert.assertEquals(2, _size);
        final Procedure1<AnnotationReference> _function = new Procedure1<AnnotationReference>() {
          @Override
          public void apply(final AnnotationReference it) {
            AnnotationTypeDeclaration _annotationTypeDeclaration = annotationValue.getAnnotationTypeDeclaration();
            Assert.assertEquals(someAnnotationType, _annotationTypeDeclaration);
            boolean _booleanValue = annotationValue.getBooleanValue("value");
            Assert.assertFalse(_booleanValue);
          }
        };
        IterableExtensions.<AnnotationReference>forEach(((Iterable<AnnotationReference>)Conversions.doWrapArray(annotationsValue)), _function);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int someValue");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Constants {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static val int MYCONSTANT = Integer.MAX_VALUE - 42");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'someValue\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.docComment = \'\'+existingValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(someValue=MoreConstants.MY_CONSTANT * 1)");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MoreConstants {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("public static val int MY_CONSTANT = myannotation.Constants.MYCONSTANT - Integer.MAX_VALUE + 42 * 2");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("42", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_3() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val field = annotatedClass.declaredFields.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = field.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.removeAnnotation(fieldAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.addAnnotation(fieldAnnotation.annotationTypeDeclaration.qualifiedName.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanValue\', classAnnotation.getValue(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intValue\', classAnnotation.getValue(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longValue\', classAnnotation.getValue(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringValue\', classAnnotation.getValue(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanArrayValue\', classAnnotation.getValue(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intArrayValue\', classAnnotation.getValue(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longArrayValue\', classAnnotation.getValue(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringArrayValue\', classAnnotation.getValue(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeValue\', classAnnotation.getValue(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeArrayValue\', classAnnotation.getValue(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2Value\', classAnnotation.getValue(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2ArrayValue\', classAnnotation.getValue(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumValue\', classAnnotation.getValue(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumArrayValue\', classAnnotation.getValue(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.UserCode");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        Iterable<? extends AnnotationReference> _annotations = _head.getAnnotations();
        final AnnotationReference annoRef = IterableExtensions.head(_annotations);
        Object _value = annoRef.getValue("intValue");
        Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), _value);
        Object _value_1 = annoRef.getValue("longValue");
        Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), _value_1);
        Object _value_2 = annoRef.getValue("stringValue");
        Assert.assertEquals("foobaz", _value_2);
        Object _value_3 = annoRef.getValue("booleanArrayValue");
        final boolean[] bools = ((boolean[]) _value_3);
        boolean _get = bools[0];
        Assert.assertTrue(_get);
        boolean _get_1 = bools[1];
        Assert.assertFalse(_get_1);
        Object _value_4 = annoRef.getValue("intArrayValue");
        Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_4));
        Object _value_5 = annoRef.getValue("typeArrayValue");
        final TypeReference[] type = ((TypeReference[]) _value_5);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Integer.class);
        Object _get_2 = type[1];
        Assert.assertEquals(_newTypeReference, _get_2);
        Object _value_6 = annoRef.getValue("annotation2Value");
        final AnnotationReference anno = ((AnnotationReference) _value_6);
        Object _value_7 = anno.getValue("value");
        Assert.assertEquals("foowuppa", _value_7);
        Object _value_8 = annoRef.getValue("annotation2ArrayValue");
        final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_8);
        AnnotationReference _get_3 = annoArray[0];
        Object _value_9 = _get_3.getValue("value");
        Assert.assertEquals("HUBBA BUBBA!", _value_9);
        Object _value_10 = annoRef.getValue("enumValue");
        final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_10);
        String _simpleName = enum1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName);
        Object _value_11 = annoRef.getValue("enumArrayValue");
        final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_11);
        EnumerationValueDeclaration _head_1 = IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray)));
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationArrayValueGetting_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def check(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("switch qualifiedName {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode2\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode4\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getBooleanArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!value.head) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"!value.head\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getBooleanValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getBooleanValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode3\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode5\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getBooleanArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 2) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!value.head) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"!value.head\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.last) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.last\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getBooleanValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getBooleanValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\'Unexpected type: \' + qualifiedName)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(true)");
    _builder_1.newLine();
    _builder_1.append("class UserCode {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(#[true])");
    _builder_1.newLine();
    _builder_1.append("class UserCode2 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(true, false)");
    _builder_1.newLine();
    _builder_1.append("class UserCode3 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=true)");
    _builder_1.newLine();
    _builder_1.append("class UserCode4 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=#[true, false])");
    _builder_1.newLine();
    _builder_1.append("class UserCode5 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationArrayValueGetting_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def check(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("switch qualifiedName {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode2\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode4\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getClassArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.head.name != \'java.lang.String\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.head.name != \'java.lang.String\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getClassValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getClassValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode3\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode5\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getClassArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 2) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.head.name != \'java.lang.String\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.head.name != \'java.lang.String\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.last.name != \'java.lang.Integer\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.last.name != \'java.lang.Integer\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getClassValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getClassValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\'Unexpected type: \' + qualifiedName)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(String)");
    _builder_1.newLine();
    _builder_1.append("class UserCode {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(#[String])");
    _builder_1.newLine();
    _builder_1.append("class UserCode2 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(String, Integer)");
    _builder_1.newLine();
    _builder_1.append("class UserCode3 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=String)");
    _builder_1.newLine();
    _builder_1.append("class UserCode4 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=#[String, Integer])");
    _builder_1.newLine();
    _builder_1.append("class UserCode5 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Ignore("Setting annotation values of type Expression is not possible")
  @Test
  public void testAnnotationValueSetting_AsExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val field = annotatedClass.declaredFields.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = field.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.removeAnnotation(fieldAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.addAnnotation(fieldAnnotation.annotationTypeDeclaration.qualifiedName.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanValue\', classAnnotation.getExpression(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intValue\', classAnnotation.getExpression(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longValue\', classAnnotation.getExpression(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringValue\', classAnnotation.getExpression(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanArrayValue\', classAnnotation.getExpression(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intArrayValue\', classAnnotation.getExpression(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longArrayValue\', classAnnotation.getExpression(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringArrayValue\', classAnnotation.getExpression(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeValue\', classAnnotation.getExpression(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeArrayValue\', classAnnotation.getExpression(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2Value\', classAnnotation.getExpression(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2ArrayValue\', classAnnotation.getExpression(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumValue\', classAnnotation.getExpression(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumArrayValue\', classAnnotation.getExpression(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanValue = true,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.UserCode");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        Iterable<? extends AnnotationReference> _annotations = _head.getAnnotations();
        final AnnotationReference annoRef = IterableExtensions.head(_annotations);
        Object _value = annoRef.getValue("intValue");
        Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), _value);
        Object _value_1 = annoRef.getValue("longValue");
        Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), _value_1);
        Object _value_2 = annoRef.getValue("stringValue");
        Assert.assertEquals("foobaz", _value_2);
        Object _value_3 = annoRef.getValue("booleanValue");
        Assert.assertTrue((((Boolean) _value_3)).booleanValue());
        Object _value_4 = annoRef.getValue("booleanArrayValue");
        final boolean[] bools = ((boolean[]) _value_4);
        boolean _get = bools[0];
        Assert.assertTrue(_get);
        boolean _get_1 = bools[1];
        Assert.assertFalse(_get_1);
        Object _value_5 = annoRef.getValue("intArrayValue");
        Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_5));
        Object _value_6 = annoRef.getValue("typeArrayValue");
        final TypeReference[] type = ((TypeReference[]) _value_6);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Integer.class);
        Object _get_2 = type[1];
        Assert.assertEquals(_newTypeReference, _get_2);
        Object _value_7 = annoRef.getValue("annotation2Value");
        final AnnotationReference anno = ((AnnotationReference) _value_7);
        Object _value_8 = anno.getValue("value");
        Assert.assertEquals("foowuppa", _value_8);
        Object _value_9 = annoRef.getValue("annotation2ArrayValue");
        final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_9);
        AnnotationReference _get_3 = annoArray[0];
        Object _value_10 = _get_3.getValue("value");
        Assert.assertEquals("HUBBA BUBBA!", _value_10);
        Object _value_11 = annoRef.getValue("enumValue");
        final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_11);
        String _simpleName = enum1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName);
        Object _value_12 = annoRef.getValue("enumArrayValue");
        final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_12);
        EnumerationValueDeclaration _head_1 = IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray)));
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAccessAndModifyEnumerationValueDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import static com.google.common.base.Preconditions.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements RegisterGlobalsParticipant<EnumerationTypeDeclaration>, TransformationParticipant<MutableEnumerationTypeDeclaration>, CodeGenerationParticipant<EnumerationTypeDeclaration> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doGenerateCode(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension CodeGenerationContext context) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedSourceElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationTypeDeclaration enumeration) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val values = enumeration.declaredValues");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(values.size == 3, \"enumeration.declaredValues.size != 3\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(0).simpleName).checkState(\"A\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(1).simpleName).checkState(\"B\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(2).simpleName).checkState(\"C\", enumeration)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationValueDeclaration value, String expectedSimpleName, TypeDeclaration expectedType) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.simpleName == expectedSimpleName, \"value.simpleName != expectedSimpleName\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.declaringType == expectedType, \"value.declaringType != expectedType\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.visibility == Visibility.PUBLIC, \"value.visibility != Visibility.PUBLIC\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.annotations.size == 0, \"value.annotations.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.findAnnotation(null) == null, \"value.findAnnotation(null) != null\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableEnumerationTypeDeclaration> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (value : enumeration.declaredValues) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 0, value.annotations.size != 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.addAnnotation(Deprecated.newAnnotationReference)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 1, value.annotations.size != 1)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.addValue(\"D\") [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("addAnnotation(Deprecated.newAnnotationReference)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("enum UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("A, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("B,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("C");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableEnumerationTypeDeclaration enumerationType = _typeLookup.findEnumerationType("myusercode.UserCode");
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues = enumerationType.getDeclaredValues();
        int _size = IterableExtensions.size(_declaredValues);
        Assert.assertEquals(4, _size);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Deprecated.class);
        final Type deprecatedAnnotationType = _newTypeReference.getType();
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues_1 = enumerationType.getDeclaredValues();
        for (final MutableEnumerationValueDeclaration value : _declaredValues_1) {
          {
            Iterable<? extends AnnotationReference> _annotations = value.getAnnotations();
            int _size_1 = IterableExtensions.size(_annotations);
            Assert.assertEquals(1, _size_1);
            AnnotationReference _findAnnotation = value.findAnnotation(deprecatedAnnotationType);
            Assert.assertNotNull(_findAnnotation);
          }
        }
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues_2 = enumerationType.getDeclaredValues();
        MutableEnumerationValueDeclaration _last = IterableExtensions.last(_declaredValues_2);
        String _simpleName = _last.getSimpleName();
        Assert.assertEquals("D", _simpleName);
        MutableEnumerationValueDeclaration _findDeclaredValue = enumerationType.findDeclaredValue("D");
        Assert.assertNotNull(_findDeclaredValue);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testModifyTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 0) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"Before: typeParameters.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("addTypeParameter(\"T\", String.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: typeParameters.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val typeParameter = typeParameters.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (!typeParameter.simpleName.equals(\"T\")) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: expected type name: \'T\', actual type name: \'\" + typeParameter.simpleName + \"\'\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          @Override
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(1, _size);
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = it.getTypeParameters();
            final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(_typeParameters_1);
            String _simpleName = typeParameter.getSimpleName();
            Assert.assertEquals("T", _simpleName);
            Iterable<? extends TypeReference> _upperBounds = typeParameter.getUpperBounds();
            int _size_1 = IterableExtensions.size(_upperBounds);
            Assert.assertEquals(1, _size_1);
            Iterable<? extends TypeReference> _upperBounds_1 = typeParameter.getUpperBounds();
            TypeReference _head = IterableExtensions.head(_upperBounds_1);
            String _name = _head.getName();
            Assert.assertEquals("java.lang.String", _name);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(clazz);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors);
        assertMyAnnotationChanges.apply(_head);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head_1 = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testRemoveTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.remove");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends String> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends String> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends String> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          @Override
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(0, _size);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetUpperBoundsForMutableTypeParameterDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.upperBounds = #[String.newTypeReference]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends CharSequence> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          @Override
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(1, _size);
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = it.getTypeParameters();
            final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(_typeParameters_1);
            Iterable<? extends TypeReference> _upperBounds = typeParameter.getUpperBounds();
            int _size_1 = IterableExtensions.size(_upperBounds);
            Assert.assertEquals(1, _size_1);
            Iterable<? extends TypeReference> _upperBounds_1 = typeParameter.getUpperBounds();
            TypeReference _head = IterableExtensions.head(_upperBounds_1);
            String _name = _head.getName();
            Assert.assertEquals("java.lang.String", _name);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testRemoveAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(RemoveAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation RemoveAnnotation{ }");
    _builder.newLine();
    _builder.append("class RemoveAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReference = clazz.findAnnotation(RemoveAnnotation.newTypeReference.type)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.removeAnnotation(annotationReference)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/RemoveAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.RemoveAnnotation class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends AnnotationReference> _annotations = clazz.getAnnotations();
        int _size = IterableExtensions.size(_annotations);
        Assert.assertEquals(1, _size);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testChangeJavaDoc() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ChangeDocProcessor))");
    _builder.newLine();
    _builder.append("annotation ChangeDoc{ }");
    _builder.newLine();
    _builder.append("class ChangeDocProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.docComment = clazz.docComment.toLowerCase");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ChangeDocAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.ChangeDoc class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("make me lower case!", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testMarkAsDeprecated() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MarkAsDeprecatedProcessor)");
    _builder.newLine();
    _builder.append("annotation MarkAsDeprecated{ }");
    _builder.newLine();
    _builder.append("class MarkAsDeprecatedProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.deprecated = true");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.MarkAsDeprecated class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.MarkAsDeprecated;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@MarkAsDeprecated");
    _builder_2.newLine();
    _builder_2.append("@Deprecated");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }
  
  @Test
  public void testMarkAsDeprecated_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(UnmarkDeprecatedProcessor)");
    _builder.newLine();
    _builder.append("annotation UnmarkDeprecated{ }");
    _builder.newLine();
    _builder.append("class UnmarkDeprecatedProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.deprecated = false");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.UnmarkDeprecated @Deprecated class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.UnmarkDeprecated;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@UnmarkDeprecated");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }
  
  @Test
  public void testAddDispatchCase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AddDispatchCaseProcessor)");
    _builder.newLine();
    _builder.append("annotation AddDispatchCase{ }");
    _builder.newLine();
    _builder.append("class AddDispatchCaseProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addMethod(\'_m\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("visibility = Visibility.PROTECTED");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("returnType = string");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = \'");
    _builder.append("\'\'return null;\'\'");
    _builder.append("\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddDispatchCase class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Integer i) { return null }");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import java.util.Arrays;");
    _builder_2.newLine();
    _builder_2.append("import myannotation.AddDispatchCase;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@AddDispatchCase");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("protected String _m(final Integer i) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("return null;");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("public String m(final Object i) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("if (i instanceof Integer) {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("return _m((Integer)i);");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("} else if (i instanceof String) {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("return _m((String)i);");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("} else {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("throw new IllegalArgumentException(\"Unhandled parameter types: \" +");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("Arrays.<Object>asList(i).toString());");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("protected String _m(final String foo) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("return null;");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }
  
  @Test
  public void testChangeDispatchHierachy() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyDeriveParticipant)");
    _builder.newLine();
    _builder.append("annotation MyDerive {}");
    _builder.newLine();
    _builder.append("class MyDeriveParticipant extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.setExtendedClass(newTypeReference(Base))");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("class Base {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Derived1 extends myannotation.Base {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyDerive");
    _builder_1.newLine();
    _builder_1.append("class Derived2 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyDerive");
    _builder_1.newLine();
    _builder_1.append("class Derived3 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("class D1 {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch void m(myannotation.Base b) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("class D2 extends D1 {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived1 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived2 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived3 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.Base;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class Derived1 extends Base {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    StringConcatenation _builder_3 = new StringConcatenation();
    _builder_3.append("package myusercode;");
    _builder_3.newLine();
    _builder_3.newLine();
    _builder_3.append("import myannotation.Base;");
    _builder_3.newLine();
    _builder_3.append("import myannotation.MyDerive;");
    _builder_3.newLine();
    _builder_3.newLine();
    _builder_3.append("@MyDerive");
    _builder_3.newLine();
    _builder_3.append("@SuppressWarnings(\"all\")");
    _builder_3.newLine();
    _builder_3.append("public class Derived2 extends Base {");
    _builder_3.newLine();
    _builder_3.append("}");
    _builder_3.newLine();
    StringConcatenation _builder_4 = new StringConcatenation();
    _builder_4.append("package myusercode;");
    _builder_4.newLine();
    _builder_4.newLine();
    _builder_4.append("import myannotation.Base;");
    _builder_4.newLine();
    _builder_4.append("import myannotation.MyDerive;");
    _builder_4.newLine();
    _builder_4.newLine();
    _builder_4.append("@MyDerive");
    _builder_4.newLine();
    _builder_4.append("@SuppressWarnings(\"all\")");
    _builder_4.newLine();
    _builder_4.append("public class Derived3 extends Base {");
    _builder_4.newLine();
    _builder_4.append("}");
    _builder_4.newLine();
    StringConcatenation _builder_5 = new StringConcatenation();
    _builder_5.append("package myusercode;");
    _builder_5.newLine();
    _builder_5.newLine();
    _builder_5.append("import myannotation.Base;");
    _builder_5.newLine();
    _builder_5.newLine();
    _builder_5.append("@SuppressWarnings(\"all\")");
    _builder_5.newLine();
    _builder_5.append("public class D1 {");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("protected void _m(final Base b) {");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("}");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("public void m(final Base b) {");
    _builder_5.newLine();
    _builder_5.append("    ");
    _builder_5.append("_m(b);");
    _builder_5.newLine();
    _builder_5.append("    ");
    _builder_5.append("return;");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("}");
    _builder_5.newLine();
    _builder_5.append("}");
    _builder_5.newLine();
    StringConcatenation _builder_6 = new StringConcatenation();
    _builder_6.append("package myusercode;");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("import java.util.Arrays;");
    _builder_6.newLine();
    _builder_6.append("import myannotation.Base;");
    _builder_6.newLine();
    _builder_6.append("import myusercode.D1;");
    _builder_6.newLine();
    _builder_6.append("import myusercode.Derived1;");
    _builder_6.newLine();
    _builder_6.append("import myusercode.Derived2;");
    _builder_6.newLine();
    _builder_6.append("import myusercode.Derived3;");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("@SuppressWarnings(\"all\")");
    _builder_6.newLine();
    _builder_6.append("public class D2 extends D1 {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived1 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived2 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived3 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("public void m(final Base d) {");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("if (d instanceof Derived1) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived1)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d instanceof Derived2) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived2)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d instanceof Derived3) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived3)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d != null) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m(d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("throw new IllegalArgumentException(\"Unhandled parameter types: \" +");
    _builder_6.newLine();
    _builder_6.append("        ");
    _builder_6.append("Arrays.<Object>asList(d).toString());");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("}");
    _builder_6.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString(), _builder_3.toString(), _builder_4.toString(), _builder_5.toString(), _builder_6.toString());
  }
  
  @Test
  public void testAddConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters);
        String _simpleName = _head_1.getSimpleName();
        Assert.assertEquals("foo", _simpleName);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddDefaultConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=[\'System.out.println(\"Hello World\");\']");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        boolean _isEmpty = IterableExtensions.isEmpty(_parameters);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddDefaultConstructorWithTemplate() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.append("System.out.println(\"Hello World\");");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        it.getCompilationUnit();
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        boolean _isEmpty = IterableExtensions.isEmpty(_parameters);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> methods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = methods.get(0).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = methods.get(1).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(0).body = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(1).body = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def foo(String a) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return b");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def bar(String b) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return a");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> fields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = fields.get(0).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = fields.get(1).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(0).initializer = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(1).initializer = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap String a = 42");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap int b = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSimpleModification() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("^abstract = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        boolean _isAbstract = clazz.isAbstract();
        Assert.assertTrue(_isAbstract);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testParameterAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ParamProcessor))");
    _builder.newLine();
    _builder.append("annotation Param { }");
    _builder.newLine();
    _builder.append("class ParamProcessor implements TransformationParticipant<MutableParameterDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableParameterDeclaration> params, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("params.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("simpleName = simpleName+\'foo\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(@myannotation.Param String a, @myannotation.Param String b) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        final Function1<MutableParameterDeclaration, Boolean> _function = new Function1<MutableParameterDeclaration, Boolean>() {
          @Override
          public Boolean apply(final MutableParameterDeclaration it) {
            String _simpleName = it.getSimpleName();
            return Boolean.valueOf(_simpleName.endsWith("foo"));
          }
        };
        boolean _forall = IterableExtensions.forall(_parameters, _function);
        Assert.assertTrue(_forall);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testConstantExpressionEvaluation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package annotations");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Processor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Processor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration annotatedClass, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("registerClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val newClass = findClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (method : annotatedClass.declaredMethods) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.addParameter(value, newClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("newClass.addField(value) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = string");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("visibility = Visibility.PUBLIC");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("initializer = \'");
    _builder.append("\'\'\"FOO\"\'");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("annotations/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package application");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import annotations.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(\"FOO\") class MyClient {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def myMethod() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("FOO.FOO");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("application/MyAnnotation.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("application.MyClient.FOO");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("FOO", _simpleName);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableClassDeclaration clazz2 = _typeLookup_1.findClass("application.MyClient");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz2.getDeclaredMethods();
        MutableMethodDeclaration _head_1 = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head_1.getParameters();
        MutableParameterDeclaration _head_2 = IterableExtensions.head(_parameters);
        String _simpleName_1 = _head_2.getSimpleName();
        Assert.assertEquals("FOO", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetDocumentation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("docComment = docComment.toCharArray.reverse.join");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* dlroW olleH");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("Hello World", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationDefaultValuesBug463161() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration mutableClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationRef = mutableClass.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("mutableClass.addField(annotationRef.getExpression(\'value\')?.toString ?: \'wasNull\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = string");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int value = 1");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        final MutableFieldDeclaration field = IterableExtensions.head(_declaredFields);
        String _simpleName = field.getSimpleName();
        Assert.assertEquals("wasNull", _simpleName);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationDefaultValues_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach[ annotationTarget |");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotation = annotationTarget.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val strings = annotation.getStringArrayValue(\'value\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("strings.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val booleans = annotation.getBooleanArrayValue(\'booleans\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("booleans.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val types = annotation.getClassArrayValue(\'types\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val policies = annotation.getEnumArrayValue(\'policies\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("policies.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val nested = annotation.getAnnotationArrayValue(\'nested\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("nested.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("RetentionPolicy[] policies = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Active[] nested = #[]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        boolean _isEmpty = IterableExtensions.isEmpty(_declaredFields);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationDefaultValues_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach[ annotationTarget |");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotation = annotationTarget.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val strings = annotation.getStringArrayValue(\'value\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("strings.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val booleans = annotation.getBooleanArrayValue(\'booleans\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("booleans.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val types = annotation.getClassArrayValue(\'types\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val policies = annotation.getEnumArrayValue(\'policies\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("policies.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val nested = annotation.getAnnotationArrayValue(\'nested\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("nested.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("RetentionPolicy[] policies = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Active[] nested = #[]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("value = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleans = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("types = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("policies = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("nested = #[]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        boolean _isEmpty = IterableExtensions.isEmpty(_declaredFields);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTarget");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AddAnnotationValueProcessor)");
    _builder.newLine();
    _builder.append("annotation AddAnnotationValue { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AddAnnotationValueProcessor implements TransformationParticipant<MutableAnnotationTarget> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableAnnotationTarget> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addAnnotation(");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MyAnnotation.findTypeGlobally.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'value\', #[\'foo\', \'bar\', \'baz\'] as String[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleValue\', \'foo\')");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'booleans\', #[true, false, true] as boolean[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleBoolean\', true)");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'numbers\', #[1, 2, 3] as int[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleNumber\', 1)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String singleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean singleBoolean");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] numbers");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int singleNumber");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddAnnotationValue.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddAnnotationValue");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference("myannotation.MyAnnotation");
        Type _type = _newTypeReference.getType();
        final AnnotationReference annotation = clazz.findAnnotation(_type);
        Object _value = annotation.getValue("value");
        Assert.assertArrayEquals(((String[]) ((String[])Conversions.unwrapArray(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("foo", "bar", "baz")), String.class))), ((String[]) _value));
        Object _value_1 = annotation.getValue("singleValue");
        Assert.assertEquals("foo", _value_1);
        Object _value_2 = annotation.getValue("booleans");
        final boolean[] booleans = ((boolean[]) _value_2);
        boolean _get = booleans[2];
        Assert.assertTrue(_get);
        Object _value_3 = annotation.getValue("singleBoolean");
        Assert.assertEquals(Boolean.valueOf(true), _value_3);
        Object _value_4 = annotation.getValue("numbers");
        Assert.assertArrayEquals(new int[] { 1, 2, 3 }, ((int[]) _value_4));
        Object _value_5 = annotation.getValue("singleNumber");
        Assert.assertEquals(Integer.valueOf(1), _value_5);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testCreateTypeFromUsage() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.Documented");
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SomeProcessor))");
    _builder.newLine();
    _builder.append("@Documented");
    _builder.newLine();
    _builder.append("@Target(ElementType::TYPE)");
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {}");
    _builder.newLine();
    _builder.append("class SomeProcessor implements RegisterGlobalsParticipant<TypeDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends TypeDeclaration> types, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("declaredMethods.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("context.registerClass(parameterType)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private def getParameterType(MethodDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("parameters.head.type.type.qualifiedName");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SomeAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.SomeAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void myMethod(DoesNotExist p) {}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.DoesNotExist");
        String _simpleName = _findClass.getSimpleName();
        boolean _equals = Objects.equal(_simpleName, "DoesNotExist");
        Assert.assertTrue(_equals);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testMarkReadAndInitialized() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/InitAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(InitProcessor)\n\t\t\t\tannotation Init { }\n\t\t\t\tclass InitProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tval ctor = annotatedTargetFields.head.declaringType.addConstructor [\n\t\t\t\t\t\t\tprimarySourceElement = declaringType\n\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\tFOR f : annotatedTargetFields\n\t\t\t\t\t\t\t\t\tthis.f.simpleName = \"foo\";\n\t\t\t\t\t\t\t\tENDFOR\n\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t]\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tfield.setFinal(true)\n\t\t\t\t\t\t\tfield.markAsRead\n\t\t\t\t\t\t\tfield.markAsInitializedBy(ctor)\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Init String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        final JvmGenericType clazz = ((MutableJvmClassDeclarationImpl) _findClass).getDelegate();
        AbstractReusableActiveAnnotationTests.this.validator.assertNoIssues(clazz);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testMarkReadAndInitialized2() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/InitAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(InitProcessor)\n\t\t\t\tannotation Init { }\n\t\t\t\tclass InitProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tval ctor = annotatedTargetFields.head.declaringType.addConstructor [\n\t\t\t\t\t\t\tprimarySourceElement = declaringType\n\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\tFOR f : annotatedTargetFields\n\t\t\t\t\t\t\t\t\tthis.f.simpleName = \"foo\";\n\t\t\t\t\t\t\t\tENDFOR\n\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t]\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tfield.setFinal(true)\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Init String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        XtendFile _xtendFile = it.getXtendFile();
        Resource _eResource = _xtendFile.eResource();
        EList<Resource.Diagnostic> _errors = _eResource.getErrors();
        final Function1<Resource.Diagnostic, Boolean> _function = new Function1<Resource.Diagnostic, Boolean>() {
          @Override
          public Boolean apply(final Resource.Diagnostic it) {
            String _message = it.getMessage();
            return Boolean.valueOf(_message.contains("myField may not have been initialized"));
          }
        };
        IterableExtensions.<Resource.Diagnostic>exists(_errors, _function);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testPropertyAnnotation() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/PropertyAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(typeof(PropertyProcessor))\n\t\t\t\tannotation Property2 { }\n\t\t\t\tclass PropertyProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tval declaringType = field.declaringType \n\t\t\t\t\t\t\tdeclaringType.addMethod(field.getterName) [\n\t\t\t\t\t\t\t\treturnType = field.type\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\treturn this.field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\tdeclaringType.addMethod(\'set\'+field.simpleName.toFirstUpper) [\n\t\t\t\t\t\t\t\taddParameter(field.simpleName, field.type)\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\tthis.field.simpleName = field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdef private String getterName(MutableFieldDeclaration field) {\n\t\t\t\t\t\treturn \'get\'+field.simpleName.toFirstUpper\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Property2 String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
        final MutableMethodDeclaration getter = IterableExtensions.head(_declaredMethods);
        String _simpleName = getter.getSimpleName();
        Assert.assertEquals("getMyField", _simpleName);
        TypeReference _returnType = getter.getReturnType();
        String _string = _returnType.toString();
        Assert.assertEquals("String", _string);
        TypeReference _returnType_1 = getter.getReturnType();
        final MutableMethodDeclaration setter = clazz.findDeclaredMethod("setMyField", _returnType_1);
        String _simpleName_1 = setter.getSimpleName();
        Assert.assertEquals("setMyField", _simpleName_1);
        TypeReference _returnType_2 = setter.getReturnType();
        String _string_1 = _returnType_2.toString();
        Assert.assertEquals("void", _string_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = setter.getParameters();
        MutableParameterDeclaration _head = IterableExtensions.head(_parameters);
        String _simpleName_2 = _head.getSimpleName();
        Assert.assertEquals("myField", _simpleName_2);
        Iterable<? extends MutableParameterDeclaration> _parameters_1 = setter.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters_1);
        TypeReference _type = _head_1.getType();
        String _string_2 = _type.toString();
        Assert.assertEquals("String", _string_2);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testThrowsAndTypeParam() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ThrowsAndTypeParamProcessor))");
    _builder.newLine();
    _builder.append("annotation ThrowsAndTypeParam { }");
    _builder.newLine();
    _builder.append("class ThrowsAndTypeParamProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val type = addTypeParameter(\'A\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\'myParam\', newTypeReference(type))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setExceptions(newTypeReference(\'java.lang.Exception\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.ThrowsAndTypeParam");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(){");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
        final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = method.getTypeParameters();
        MutableTypeParameterDeclaration _head = IterableExtensions.head(_typeParameters);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("A", _simpleName);
        Iterable<? extends MutableParameterDeclaration> _parameters = method.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters);
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("myParam", _simpleName_1);
        Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = method.getTypeParameters();
        MutableTypeParameterDeclaration _head_2 = IterableExtensions.head(_typeParameters_1);
        Iterable<? extends MutableParameterDeclaration> _parameters_1 = method.getParameters();
        MutableParameterDeclaration _head_3 = IterableExtensions.head(_parameters_1);
        TypeReference _type = _head_3.getType();
        Type _type_1 = _type.getType();
        Assert.assertSame(_head_2, _type_1);
        Iterable<? extends TypeReference> _exceptions = method.getExceptions();
        int _size = IterableExtensions.size(_exceptions);
        Assert.assertEquals(1, _size);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testMovingComputedTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Field2MethodProcessor)");
    _builder.newLine();
    _builder.append("annotation Field2Method { }");
    _builder.newLine();
    _builder.append("class Field2MethodProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> annotatedFields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedFields.forEach [ field |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("field.declaringType.addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = field.initializer");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("field.remove");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val foo = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Field2Method");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val x = foo");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Field2Method");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val y = x");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
        final MutableMethodDeclaration method = ((MutableMethodDeclaration[])Conversions.unwrapArray(_declaredMethods, MutableMethodDeclaration.class))[1];
        TypeReference _returnType = method.getReturnType();
        String _name = _returnType.getName();
        Assert.assertEquals("java.lang.String", _name);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testMovingComputedTypes_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Method2FieldProcessor)");
    _builder.newLine();
    _builder.append("annotation Method2Field { }");
    _builder.newLine();
    _builder.append("class Method2FieldProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ method |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.declaringType.addField(method.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("type = method.returnType");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("initializer = method.body");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.remove");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val foo = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Method2Field");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def x() { foo }");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Method2Field");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def y() { x }");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = type.getDeclaredFields();
        final MutableFieldDeclaration field = ((MutableFieldDeclaration[])Conversions.unwrapArray(_declaredFields, MutableFieldDeclaration.class))[1];
        TypeReference _type = field.getType();
        String _name = _type.getName();
        Assert.assertEquals("java.lang.String", _name);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testValidation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ValidatedProcessor))");
    _builder.newLine();
    _builder.append("annotation Validated { }");
    _builder.newLine();
    _builder.append("class ValidatedProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch ele {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MutableFieldDeclaration : ele.addWarning(\'field-warning\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default : ele.addWarning(\'warning\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String name");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
        final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableFieldDeclaration> _declaredFields = type.getDeclaredFields();
        final MutableFieldDeclaration field = IterableExtensions.head(_declaredFields);
        ProblemSupportImpl _problemSupport = it.getProblemSupport();
        List<? extends Problem> _problems = _problemSupport.getProblems(field);
        Problem _head = IterableExtensions.head(_problems);
        String _message = _head.getMessage();
        Assert.assertEquals("field-warning", _message);
        ProblemSupportImpl _problemSupport_1 = it.getProblemSupport();
        List<? extends Problem> _problems_1 = _problemSupport_1.getProblems(method);
        Problem _head_1 = IterableExtensions.head(_problems_1);
        String _message_1 = _head_1.getMessage();
        Assert.assertEquals("warning", _message_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testIntroduceNewTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\".InnerClass\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerInterface(clazz.qualifiedName+\"Interface\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerEnumerationType(clazz.qualifiedName+\"Enum\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerAnnotationType(clazz.qualifiedName+\"Annotation\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        Assert.assertNotNull(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        MutableClassDeclaration _findClass_1 = _typeLookup_1.findClass("myusercode.MyClass.InnerClass");
        Assert.assertNotNull(_findClass_1);
        TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
        MutableInterfaceDeclaration _findInterface = _typeLookup_2.findInterface("myusercode.MyClassInterface");
        Assert.assertNotNull(_findInterface);
        TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
        MutableEnumerationTypeDeclaration _findEnumerationType = _typeLookup_3.findEnumerationType("myusercode.MyClassEnum");
        Assert.assertNotNull(_findEnumerationType);
        TypeLookupImpl _typeLookup_4 = it.getTypeLookup();
        MutableAnnotationTypeDeclaration _findAnnotationType = _typeLookup_4.findAnnotationType("myusercode.MyClassAnnotation");
        Assert.assertNotNull(_findAnnotationType);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testImportFromTypeReference_01() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationImportFromTypeReference.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.text.DateFormat\n\t\t\t\timport java.text.SimpleDateFormat\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\t\n\t\t\t\t@Active(AnnotationImportFromTypeReferenceProcessor)\n\t\t\t\tannotation AnnotationImportFromTypeReference { }\n\t\t\t\tclass AnnotationImportFromTypeReferenceProcessor extends AbstractClassProcessor {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedClass.addField(\'myDateFormat\') [\n\t\t\t\t\t\t\ttype = DateFormat.newTypeReference\n\t\t\t\t\t\t\tinitializer = \'\'\'new SimpleDateFormat.newTypeReference()\'\'\'\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.AnnotationImportFromTypeReference");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import java.text.DateFormat;");
    _builder_1.newLine();
    _builder_1.append("import java.text.SimpleDateFormat;");
    _builder_1.newLine();
    _builder_1.append("import myannotation.AnnotationImportFromTypeReference;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@AnnotationImportFromTypeReference");
    _builder_1.newLine();
    _builder_1.append("@SuppressWarnings(\"all\")");
    _builder_1.newLine();
    _builder_1.append("public class MyClass {");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private DateFormat myDateFormat = new SimpleDateFormat();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_1.toString());
  }
  
  @Test
  public void testImportFromTypeReference_02() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationImportFromTypeReference.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\t\n\t\t\t\t@Active(AnnotationImportFromTypeReferenceProcessor)\n\t\t\t\tannotation AnnotationImportFromTypeReference { }\n\t\t\t\tclass AnnotationImportFromTypeReferenceProcessor extends AbstractClassProcessor {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedClass.declaredFields.forEach [\n\t\t\t\t\t\t\tinitializer = \'\'\'new type.type()\'\'\'\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.Timer");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.AnnotationImportFromTypeReference");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Timer t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("MyClass child");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import java.util.Timer;");
    _builder_1.newLine();
    _builder_1.append("import myannotation.AnnotationImportFromTypeReference;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@AnnotationImportFromTypeReference");
    _builder_1.newLine();
    _builder_1.append("@SuppressWarnings(\"all\")");
    _builder_1.newLine();
    _builder_1.append("public class MyClass {");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private Timer t = new Timer();");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private MyClass child = new MyClass();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_1.toString());
  }
  
  @Test
  public void testIntroduceNewTypeAndWorkWithIt() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration>, TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val cl = context.findClass(ele.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("cl.extendedClass = newTypeReference(ele)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration declaredClass = _typeLookup.findClass("myusercode.MyClass");
        Assert.assertNotNull(declaredClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup_1.findClass("myusercode.MyClassDerived");
        Assert.assertNotNull(clazz);
        String _qualifiedName = declaredClass.getQualifiedName();
        TypeReference _extendedClass = clazz.getExtendedClass();
        Type _type = _extendedClass.getType();
        String _qualifiedName_1 = _type.getQualifiedName();
        Assert.assertEquals(_qualifiedName, _qualifiedName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  private final Pair<String, String> THREE_ANNOTATIONS = new Function0<Pair<String, String>>() {
    public Pair<String, String> apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package myannotation");
      _builder.newLine();
      _builder.newLine();
      _builder.append("import java.util.List");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.Active");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Aprocessor))");
      _builder.newLine();
      _builder.append("annotation _A {}");
      _builder.newLine();
      _builder.append("class Aprocessor implements TransformationParticipant<MutableNamedElement> {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements, extension TransformationContext context) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("annotatedTargetElements.forEach[");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("simpleName = simpleName + num()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def num() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\'_A\'");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("@Active(typeof(Bprocessor))");
      _builder.newLine();
      _builder.append("annotation _B {}");
      _builder.newLine();
      _builder.append("class Bprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_B\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Cprocessor))");
      _builder.newLine();
      _builder.append("annotation _C {}");
      _builder.newLine();
      _builder.append("class Cprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_C\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/three.xtend", _builder.toString());
      return _mappedTo;
    }
  }.apply();
  
  @Test
  public void testDeterministicExecutionOrder_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("field_A_B_C", _simpleName);
      }
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  @Test
  public void testDeterministicExecutionOrder_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_C @_B @_A String field2");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("field1_A_B_C", _simpleName);
        Iterable<? extends MutableFieldDeclaration> _declaredFields_1 = myClass.getDeclaredFields();
        MutableFieldDeclaration _get = ((MutableFieldDeclaration[])Conversions.unwrapArray(_declaredFields_1, MutableFieldDeclaration.class))[1];
        String _simpleName_1 = _get.getSimpleName();
        Assert.assertEquals("field2_A_B_C", _simpleName_1);
      }
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  public abstract void assertProcessing(final Pair<String, String> macroFile, final Pair<String, String> clientFile, final Procedure1<? super CompilationUnitImpl> expectations);
  
  public void assertGeneratedCode(final Pair<String, String> macroFile, final Pair<String, String> clientFile, final String... compiledClientFiles) {
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        final Function1<String, String> _function = new Function1<String, String>() {
          @Override
          public String apply(final String it) {
            return LineDelimiters.toUnix(it);
          }
        };
        List<String> _map = ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(compiledClientFiles)), _function);
        final Set<String> clientFilesAsSet = IterableExtensions.<String>toSet(_map);
        int _size = clientFilesAsSet.size();
        int _length = compiledClientFiles.length;
        Assert.assertEquals(_size, _length);
        XtendFile _xtendFile = it.getXtendFile();
        final Resource resource = _xtendFile.eResource();
        EList<EObject> _contents = resource.getContents();
        final Iterable<EObject> jvmTypes = IterableExtensions.<EObject>tail(_contents);
        final Procedure1<EObject> _function_1 = new Procedure1<EObject>() {
          @Override
          public void apply(final EObject it) {
            if ((it instanceof JvmDeclaredType)) {
              GeneratorConfig _get = AbstractReusableActiveAnnotationTests.this.generatorConfigProvider.get(it);
              CharSequence _generateType = AbstractReusableActiveAnnotationTests.this.generator.generateType(((JvmDeclaredType)it), _get);
              final String generated = String.valueOf(_generateType);
              boolean _remove = clientFilesAsSet.remove(generated);
              boolean _not = (!_remove);
              if (_not) {
                String _join = IterableExtensions.join(clientFilesAsSet, "\n");
                String _plus = ((("Unexpected compiled code:\n" + generated) + "\nExpected :\n") + _join);
                Assert.assertEquals("", _plus);
              }
            } else {
              String _valueOf = String.valueOf(it);
              throw new IllegalArgumentException(_valueOf);
            }
          }
        };
        IterableExtensions.<EObject>forEach(jvmTypes, _function_1);
        boolean _isEmpty = clientFilesAsSet.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          String _join = IterableExtensions.join(clientFilesAsSet, "\n");
          String _plus = ("Missing compiled code. Expected :\n" + _join);
          Assert.fail(_plus);
        }
      }
    };
    this.assertProcessing(macroFile, clientFile, _function);
  }
  
  @Test
  public void testFileSystemSupport_01() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/FileSystemSupportTest.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\t\n\t\t\t\t@Active(FileSystemUsingProcessor)\n\t\t\t\tannotation FileSystemSupportTest { }\n\t\t\t\t\n\t\t\t\tclass FileSystemUsingProcessor extends AbstractClassProcessor {\n\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tval path = annotatedClass.compilationUnit.filePath\n\t\t\t\t\t\tannotatedClass.docComment = \'\'\'\n\t\t\t\t\t\t\tPath \'path.toString\' {\n\t\t\t\t\t\t\t\texists: path.exists\n\t\t\t\t\t\t\t\tisFolder: path.isFolder\n\t\t\t\t\t\t\t\tisFile: path.isFile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceFolder : path.sourceFolder\n\t\t\t\t\t\t\ttargetFolder : path.targetFolder\n\t\t\t\t\t\t\tprojectFolder: path.projectFolder\n\t\t\t\t\t\t\'\'\'\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.FileSystemSupportTest");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration declaredClass = _typeLookup.findClass("myusercode.MyClass");
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Path \'/userProject/src/myusercode/UserCode.xtend\' {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("exists: true");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("isFolder: false");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("isFile: true");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
        _builder.append("sourceFolder : /userProject/src");
        _builder.newLine();
        _builder.append("targetFolder : /userProject/xtend-gen");
        _builder.newLine();
        _builder.append("projectFolder: /userProject");
        _builder.newLine();
        String _string = _builder.toString();
        String _docComment = declaredClass.getDocComment();
        Assert.assertEquals(_string, _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testRemove() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import com.google.common.base.Preconditions");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("remove(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def dispatch void remove(MutableNamedElement annotatedTargetElement, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val sourceElement = annotatedTargetElement.primarySourceElement");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement != null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a source element should not be null before removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement.primaryGeneratedJavaElement == annotatedTargetElement,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'expected: ");
    _builder.append("", "\t\t\t");
    _builder.append("annotatedTargetElement");
    _builder.append("", "\t\t\t");
    _builder.append(", but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement.primaryGeneratedJavaElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(annotatedTargetElement.primarySourceElement == null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a source element should be null after removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("annotatedTargetElement.primarySourceElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement.primaryGeneratedJavaElement == null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a target element should be null after removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement.primaryGeneratedJavaElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(false, \'");
    _builder.append("\'\'");
    _builder.append("", "\t\t\t");
    _builder.append("IllegalArgumentException");
    _builder.append("", "\t\t\t");
    _builder.append(" is expected\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("} catch (IllegalStateException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(e.message.startsWith(\"This element has already been removed: \"),");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'Wrong error message: ");
    _builder.append("", "\t\t\t\t");
    _builder.append("e.message");
    _builder.append("", "\t\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def dispatch void remove(MutableTypeDeclaration annotatedTargetElement, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(false, \'");
    _builder.append("\'\'");
    _builder.append("", "\t\t\t");
    _builder.append("UnsupportedOperationException");
    _builder.append("", "\t\t\t");
    _builder.append(" is expected\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("} catch (UnsupportedOperationException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(e.message == \"The type cannot be removed.\", \'\'");
    _builder.append("\'Wrong error message: ");
    _builder.append("", "\t\t\t");
    _builder.append("e.message");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class UserClass {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String fieldToRemove");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new(String arg) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new(@MyAnnotation Integer argToRemove) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def methodToRemove() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static class NestedClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static interface NestedInteface {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static annotation NestedAnnotation {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static enum NestedEnum {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("enum UserEnum {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface UserInterface {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def String methodToRemove();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("annotation UserAnnotation {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String fieldToRemove");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      @Override
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.UserClass");
        Assert.assertNotNull(clazz);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers = clazz.getDeclaredMembers();
        int _size = IterableExtensions.size(_declaredMembers);
        Assert.assertEquals(5, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        final MutableConstructorDeclaration constructor = IterableExtensions.head(_declaredConstructors);
        Assert.assertNotNull(clazz);
        Iterable<? extends MutableParameterDeclaration> _parameters = constructor.getParameters();
        int _size_1 = IterableExtensions.size(_parameters);
        Assert.assertEquals(0, _size_1);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_1 = clazz.getDeclaredMembers();
        Iterable<ClassDeclaration> _filter = Iterables.<ClassDeclaration>filter(_declaredMembers_1, ClassDeclaration.class);
        int _size_2 = IterableExtensions.size(_filter);
        Assert.assertEquals(1, _size_2);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_2 = clazz.getDeclaredMembers();
        Iterable<InterfaceDeclaration> _filter_1 = Iterables.<InterfaceDeclaration>filter(_declaredMembers_2, InterfaceDeclaration.class);
        int _size_3 = IterableExtensions.size(_filter_1);
        Assert.assertEquals(1, _size_3);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_3 = clazz.getDeclaredMembers();
        Iterable<EnumerationTypeDeclaration> _filter_2 = Iterables.<EnumerationTypeDeclaration>filter(_declaredMembers_3, EnumerationTypeDeclaration.class);
        int _size_4 = IterableExtensions.size(_filter_2);
        Assert.assertEquals(1, _size_4);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_4 = clazz.getDeclaredMembers();
        Iterable<AnnotationTypeDeclaration> _filter_3 = Iterables.<AnnotationTypeDeclaration>filter(_declaredMembers_4, AnnotationTypeDeclaration.class);
        int _size_5 = IterableExtensions.size(_filter_3);
        Assert.assertEquals(1, _size_5);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableEnumerationTypeDeclaration enum_ = _typeLookup_1.findEnumerationType("myusercode.UserEnum");
        Assert.assertNotNull(enum_);
        TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
        final MutableInterfaceDeclaration interface_ = _typeLookup_2.findInterface("myusercode.UserInterface");
        Assert.assertNotNull(interface_);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_5 = interface_.getDeclaredMembers();
        int _size_6 = IterableExtensions.size(_declaredMembers_5);
        Assert.assertEquals(0, _size_6);
        TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
        final MutableAnnotationTypeDeclaration annotation = _typeLookup_3.findAnnotationType("myusercode.UserAnnotation");
        Assert.assertNotNull(annotation);
        Iterable<? extends MutableMemberDeclaration> _declaredMembers_6 = annotation.getDeclaredMembers();
        int _size_7 = IterableExtensions.size(_declaredMembers_6);
        Assert.assertEquals(0, _size_7);
        TracabilityImpl _tracability = it.getTracability();
        Element _primarySourceElement = _tracability.getPrimarySourceElement(clazz);
        final MethodDeclaration removedMethod = ((ClassDeclaration) _primarySourceElement).findDeclaredMethod("methodToRemove");
        Expression _body = removedMethod.getBody();
        final XExpression expression = ((ExpressionImpl) _body).getDelegate();
        JvmIdentifiableElement _logicalContainer = AbstractReusableActiveAnnotationTests.this.logicalContainerProvider.getLogicalContainer(expression);
        Assert.assertNull(_logicalContainer);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  public void assertSameType(final TypeReference first, final TypeReference second) {
    boolean _notEquals = (!Objects.equal(first, second));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(first, "");
      _builder.append(" does not refer to the same type as ");
      _builder.append(second, "");
      Assert.fail(_builder.toString());
    }
  }
}
