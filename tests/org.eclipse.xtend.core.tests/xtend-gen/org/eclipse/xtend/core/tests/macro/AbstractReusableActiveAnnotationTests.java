package org.eclipse.xtend.core.tests.macro;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import java.util.Collections;
import java.util.List;
import org.eclipse.xtend.core.macro.declaration.CompilationUnitImpl;
import org.eclipse.xtend.core.macro.declaration.TypeLookupImpl;
import org.eclipse.xtend.lib.macro.declaration.AnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableInterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.services.Problem;
import org.eclipse.xtend.lib.macro.services.ProblemSupport;
import org.eclipse.xtend.lib.macro.services.TypeReferenceProvider;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Test;

@SuppressWarnings("all")
public abstract class AbstractReusableActiveAnnotationTests {
  @Test
  public void testAnnotationValueSetting_1() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import static com.google.common.base.Preconditions.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite color");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite[] colors");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?> type");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum BlackOrWhite {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BLACK, WHITE");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val enumType = findTypeGlobally(\'myannotation.BlackOrWhite\') as EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val white = enumType.findDeclaredValue(\'WHITE\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val black = enumType.findDeclaredValue(\'BLACK\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'color\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingValue !=  white)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"color\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("anno.setEnumValue(\'color\', black)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingColorsValue = anno.getValue(\'colors\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingColorsValue.get(0) !=  white && existingColorsValue.get(1) != black && existingColorsValue.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"colors\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("anno.setEnumValue(\'colors\', black, white)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingType = anno.getValue(\'type\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingType != string)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"type\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("anno.setClassValue(\'type\', annotatedClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingTypes = anno.getValue(\'types\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingTypes.get(0) !=  primitiveInt && existingTypes.get(1) != annotatedClass.newTypeReference && existingTypes.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"types\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("anno.setClassValue(\'types\', primitiveBoolean)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(color=BlackOrWhite.WHITE, colors=#[BlackOrWhite.WHITE, BlackOrWhite.BLACK], type = String, types=#[Integer, MyClass])");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        Type _findTypeGlobally = _typeLookup_1.findTypeGlobally("myannotation.BlackOrWhite");
        final EnumerationTypeDeclaration colorEnum = ((EnumerationTypeDeclaration) _findTypeGlobally);
        Iterable<? extends MutableAnnotationReference> _annotations = clazz.getAnnotations();
        final MutableAnnotationReference annotation = IterableExtensions.head(_annotations);
        EnumerationValueDeclaration _findDeclaredValue = colorEnum.findDeclaredValue("BLACK");
        Object _value = annotation.getValue("color");
        Assert.assertEquals(_findDeclaredValue, _value);
        Object _value_1 = annotation.getValue("colors");
        final Object[] colors = ((Object[]) _value_1);
        int _length = colors.length;
        Assert.assertEquals(2, _length);
        EnumerationValueDeclaration _findDeclaredValue_1 = colorEnum.findDeclaredValue("BLACK");
        Object _get = colors[0];
        Assert.assertEquals(_findDeclaredValue_1, _get);
        EnumerationValueDeclaration _findDeclaredValue_2 = colorEnum.findDeclaredValue("WHITE");
        Object _get_1 = colors[1];
        Assert.assertEquals(_findDeclaredValue_2, _get_1);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(clazz);
        Object _value_2 = annotation.getValue("type");
        Assert.assertEquals(_newTypeReference, _value_2);
        final TypeReference[] types = annotation.getClassArrayValue("types");
        int _length_1 = types.length;
        Assert.assertEquals(1, _length_1);
        TypeReferenceProvider _typeReferenceProvider_1 = it.getTypeReferenceProvider();
        TypeReference _primitiveBoolean = _typeReferenceProvider_1.getPrimitiveBoolean();
        Object _get_2 = types[0];
        Assert.assertEquals(_primitiveBoolean, _get_2);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int someValue");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Constants {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static val int MYCONSTANT = Integer.MAX_VALUE - 42");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'someValue\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.docComment = \'\'+existingValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(someValue=MoreConstants.MY_CONSTANT * 1)");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MoreConstants {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("public static val int MY_CONSTANT = myannotation.Constants.MYCONSTANT - Integer.MAX_VALUE + 42 * 2");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("42", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_3() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeReference");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = annotatedClass.declaredFields.head.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'booleanValue\', classAnnotation.getValue(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'intValue\', classAnnotation.getValue(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'longValue\', classAnnotation.getValue(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'stringValue\', classAnnotation.getValue(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'booleanArrayValue\', classAnnotation.getValue(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'intArrayValue\', classAnnotation.getValue(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'longArrayValue\', classAnnotation.getValue(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'stringArrayValue\', classAnnotation.getValue(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'typeValue\', classAnnotation.getValue(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'typeArrayValue\', classAnnotation.getValue(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("  \t\t");
    _builder.append("fieldAnnotation.set(\'annotation2Value\', classAnnotation.getValue(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("  \t\t");
    _builder.append("fieldAnnotation.set(\'annotation2ArrayValue\', classAnnotation.getExpression(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'enumValue\', classAnnotation.getValue(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'enumArrayValue\', classAnnotation.getValue(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.UserCode");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        Iterable<? extends MutableAnnotationReference> _annotations = _head.getAnnotations();
        final MutableAnnotationReference annoRef = IterableExtensions.head(_annotations);
        Object _value = annoRef.getValue("intValue");
        Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), _value);
        Object _value_1 = annoRef.getValue("longValue");
        Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), _value_1);
        Object _value_2 = annoRef.getValue("stringValue");
        Assert.assertEquals("foobaz", _value_2);
        Object _value_3 = annoRef.getValue("booleanArrayValue");
        final boolean[] bools = ((boolean[]) _value_3);
        boolean _get = bools[0];
        Assert.assertTrue(_get);
        boolean _get_1 = bools[1];
        Assert.assertFalse(_get_1);
        Object _value_4 = annoRef.getValue("intArrayValue");
        Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_4));
        Object _value_5 = annoRef.getValue("typeArrayValue");
        final TypeReference[] type = ((TypeReference[]) _value_5);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Integer.class);
        Object _get_2 = type[1];
        Assert.assertEquals(_newTypeReference, _get_2);
        Object _value_6 = annoRef.getValue("annotation2Value");
        final AnnotationReference anno = ((AnnotationReference) _value_6);
        Object _value_7 = anno.getValue("value");
        Assert.assertEquals("foowuppa", _value_7);
        Object _value_8 = annoRef.getValue("annotation2ArrayValue");
        final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_8);
        AnnotationReference _get_3 = annoArray[0];
        Object _value_9 = _get_3.getValue("value");
        Assert.assertEquals("HUBBA BUBBA!", _value_9);
        Object _value_10 = annoRef.getValue("enumValue");
        final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_10);
        String _simpleName = enum1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName);
        Object _value_11 = annoRef.getValue("enumArrayValue");
        final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_11);
        EnumerationValueDeclaration _head_1 = IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray)));
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAnnotationValueSetting_AsExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeReference");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = annotatedClass.declaredFields.head.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'booleanValue\', classAnnotation.getExpression(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'intValue\', classAnnotation.getExpression(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'longValue\', classAnnotation.getExpression(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'stringValue\', classAnnotation.getExpression(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'booleanArrayValue\', classAnnotation.getExpression(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'intArrayValue\', classAnnotation.getExpression(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'longArrayValue\', classAnnotation.getExpression(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'stringArrayValue\', classAnnotation.getExpression(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'typeValue\', classAnnotation.getExpression(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'typeArrayValue\', classAnnotation.getExpression(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("  \t\t");
    _builder.append("fieldAnnotation.set(\'annotation2Value\', classAnnotation.getExpression(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("  \t\t");
    _builder.append("fieldAnnotation.set(\'annotation2ArrayValue\', classAnnotation.getExpression(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'enumValue\', classAnnotation.getExpression(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldAnnotation.set(\'enumArrayValue\', classAnnotation.getExpression(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanValue = true,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.UserCode");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        Iterable<? extends MutableAnnotationReference> _annotations = _head.getAnnotations();
        final MutableAnnotationReference annoRef = IterableExtensions.head(_annotations);
        Object _value = annoRef.getValue("intValue");
        Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), _value);
        Object _value_1 = annoRef.getValue("longValue");
        Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), _value_1);
        Object _value_2 = annoRef.getValue("stringValue");
        Assert.assertEquals("foobaz", _value_2);
        Object _value_3 = annoRef.getValue("booleanValue");
        Assert.assertTrue((((Boolean) _value_3)).booleanValue());
        Object _value_4 = annoRef.getValue("booleanArrayValue");
        final boolean[] bools = ((boolean[]) _value_4);
        boolean _get = bools[0];
        Assert.assertTrue(_get);
        boolean _get_1 = bools[1];
        Assert.assertFalse(_get_1);
        Object _value_5 = annoRef.getValue("intArrayValue");
        Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_5));
        Object _value_6 = annoRef.getValue("typeArrayValue");
        final TypeReference[] type = ((TypeReference[]) _value_6);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Integer.class);
        Object _get_2 = type[1];
        Assert.assertEquals(_newTypeReference, _get_2);
        Object _value_7 = annoRef.getValue("annotation2Value");
        final AnnotationReference anno = ((AnnotationReference) _value_7);
        Object _value_8 = anno.getValue("value");
        Assert.assertEquals("foowuppa", _value_8);
        Object _value_9 = annoRef.getValue("annotation2ArrayValue");
        final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_9);
        AnnotationReference _get_3 = annoArray[0];
        Object _value_10 = _get_3.getValue("value");
        Assert.assertEquals("HUBBA BUBBA!", _value_10);
        Object _value_11 = annoRef.getValue("enumValue");
        final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_11);
        String _simpleName = enum1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName);
        Object _value_12 = annoRef.getValue("enumArrayValue");
        final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_12);
        EnumerationValueDeclaration _head_1 = IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray)));
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("YELLOW", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAccessAndModifyEnumerationValueDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import static com.google.common.base.Preconditions.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements RegisterGlobalsParticipant<EnumerationTypeDeclaration>, TransformationParticipant<MutableEnumerationTypeDeclaration>, CodeGenerationParticipant<EnumerationTypeDeclaration> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doGenerateCode(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension CodeGenerationContext context) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedSourceElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationTypeDeclaration enumeration) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val values = enumeration.declaredValues");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(values.size == 3, \"enumeration.declaredValues.size != 3\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(0).simpleName).checkState(\"A\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(1).simpleName).checkState(\"B\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(2).simpleName).checkState(\"C\", enumeration)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationValueDeclaration value, String expectedSimpleName, TypeDeclaration expectedType) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.simpleName == expectedSimpleName, \"value.simpleName != expectedSimpleName\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.declaringType == expectedType, \"value.declaringType != expectedType\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.visibility == Visibility.PUBLIC, \"value.visibility != Visibility.PUBLIC\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.annotations.size == 0, \"value.annotations.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.findAnnotation(null) == null, \"value.findAnnotation(null) != null\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableEnumerationTypeDeclaration> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (value : enumeration.declaredValues) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 0, value.annotations.size != 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.addAnnotation(Deprecated.newTypeReference.type)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 1, value.annotations.size != 1)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.addValue(\"D\") [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("addAnnotation(Deprecated.newTypeReference.type)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("enum UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("A, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("B,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("C");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableEnumerationTypeDeclaration enumerationType = _typeLookup.findEnumerationType("myusercode.UserCode");
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues = enumerationType.getDeclaredValues();
        int _size = IterableExtensions.size(_declaredValues);
        Assert.assertEquals(4, _size);
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference(Deprecated.class);
        final Type deprecatedAnnotationType = _newTypeReference.getType();
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues_1 = enumerationType.getDeclaredValues();
        for (final MutableEnumerationValueDeclaration value : _declaredValues_1) {
          {
            Iterable<? extends MutableAnnotationReference> _annotations = value.getAnnotations();
            int _size_1 = IterableExtensions.size(_annotations);
            Assert.assertEquals(1, _size_1);
            MutableAnnotationReference _findAnnotation = value.findAnnotation(deprecatedAnnotationType);
            Assert.assertNotNull(_findAnnotation);
          }
        }
        Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues_2 = enumerationType.getDeclaredValues();
        MutableEnumerationValueDeclaration _last = IterableExtensions.last(_declaredValues_2);
        String _simpleName = _last.getSimpleName();
        Assert.assertEquals("D", _simpleName);
        MutableEnumerationValueDeclaration _findDeclaredValue = enumerationType.findDeclaredValue("D");
        Assert.assertNotNull(_findDeclaredValue);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testModifyTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 0) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"Before: typeParameters.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("addTypeParameter(\"T\", String.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: typeParameters.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val typeParameter = typeParameters.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (!typeParameter.simpleName.equals(\"T\")) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: expected type name: \'T\', actual type name: \'\" + typeParameter.simpleName + \"\'\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(1, _size);
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = it.getTypeParameters();
            final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(_typeParameters_1);
            String _simpleName = typeParameter.getSimpleName();
            Assert.assertEquals("T", _simpleName);
            Iterable<? extends TypeReference> _upperBounds = typeParameter.getUpperBounds();
            int _size_1 = IterableExtensions.size(_upperBounds);
            Assert.assertEquals(1, _size_1);
            Iterable<? extends TypeReference> _upperBounds_1 = typeParameter.getUpperBounds();
            TypeReference _head = IterableExtensions.head(_upperBounds_1);
            String _name = _head.getName();
            Assert.assertEquals("java.lang.String", _name);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(clazz);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors);
        assertMyAnnotationChanges.apply(_head);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head_1 = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testRemoveTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.remove");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends String> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends String> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends String> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(0, _size);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetUpperBoundsForMutableTypeParameterDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.upperBounds = #[String.newTypeReference]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends CharSequence> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        final Procedure1<MutableTypeParameterDeclarator> _function = new Procedure1<MutableTypeParameterDeclarator>() {
          public void apply(final MutableTypeParameterDeclarator it) {
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = it.getTypeParameters();
            int _size = IterableExtensions.size(_typeParameters);
            Assert.assertEquals(1, _size);
            Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = it.getTypeParameters();
            final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(_typeParameters_1);
            Iterable<? extends TypeReference> _upperBounds = typeParameter.getUpperBounds();
            int _size_1 = IterableExtensions.size(_upperBounds);
            Assert.assertEquals(1, _size_1);
            Iterable<? extends TypeReference> _upperBounds_1 = typeParameter.getUpperBounds();
            TypeReference _head = IterableExtensions.head(_upperBounds_1);
            String _name = _head.getName();
            Assert.assertEquals("java.lang.String", _name);
          }
        };
        final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function;
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        assertMyAnnotationChanges.apply(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableInterfaceDeclaration myInterface = _typeLookup_1.findInterface("myusercode.MyInterface");
        assertMyAnnotationChanges.apply(myInterface);
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = myInterface.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        assertMyAnnotationChanges.apply(_head);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testRemoveAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(RemoveAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation RemoveAnnotation{ }");
    _builder.newLine();
    _builder.append("class RemoveAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.findAnnotation(RemoveAnnotation.newTypeReference.type).remove");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/RemoveAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.RemoveAnnotation class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableAnnotationReference> _annotations = clazz.getAnnotations();
        int _size = IterableExtensions.size(_annotations);
        Assert.assertEquals(0, _size);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testChangeJavaDoc() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ChangeDocProcessor))");
    _builder.newLine();
    _builder.append("annotation ChangeDoc{ }");
    _builder.newLine();
    _builder.append("class ChangeDocProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.docComment = clazz.docComment.toLowerCase");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/ChangeDocAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.ChangeDoc class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("make me lower case!", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters);
        String _simpleName = _head_1.getSimpleName();
        Assert.assertEquals("foo", _simpleName);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddDefaultConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=[\'System.out.println(\"Hello World\");\']");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        boolean _isEmpty = IterableExtensions.isEmpty(_parameters);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddDefaultConstructorWithTemplate() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.append("System.out.println(\"Hello World\");");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        it.getCompilationUnit();
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
        int _size = IterableExtensions.size(_declaredConstructors);
        Assert.assertEquals(1, _size);
        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
        MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        boolean _isEmpty = IterableExtensions.isEmpty(_parameters);
        Assert.assertTrue(_isEmpty);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> methods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = methods.get(0).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = methods.get(1).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(0).body = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(1).body = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def foo(String a) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return b");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def bar(String b) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return a");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> fields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = fields.get(0).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = fields.get(1).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(0).initializer = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(1).initializer = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap String a = 42");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap int b = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSimpleModification() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("^abstract = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        boolean _isAbstract = clazz.isAbstract();
        Assert.assertTrue(_isAbstract);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testParameterAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ParamProcessor))");
    _builder.newLine();
    _builder.append("annotation Param { }");
    _builder.newLine();
    _builder.append("class ParamProcessor implements TransformationParticipant<MutableParameterDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableParameterDeclaration> params, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("params.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("simpleName = simpleName+\'foo\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(@myannotation.Param String a, @myannotation.Param String b) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
        MutableMethodDeclaration _head = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head.getParameters();
        final Function1<MutableParameterDeclaration,Boolean> _function = new Function1<MutableParameterDeclaration,Boolean>() {
          public Boolean apply(final MutableParameterDeclaration it) {
            String _simpleName = it.getSimpleName();
            return Boolean.valueOf(_simpleName.endsWith("foo"));
          }
        };
        boolean _forall = IterableExtensions.forall(_parameters, _function);
        Assert.assertTrue(_forall);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testConstantExpressionEvaluation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package annotations");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Processor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Processor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration annotatedClass, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("registerClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val newClass = findClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (method : annotatedClass.declaredMethods) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.addParameter(value, newClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("newClass.addField(value) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = string");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("visibility = Visibility.PUBLIC");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("initializer = \'");
    _builder.append("\'\'\"FOO\"\'");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("annotations/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package application");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import annotations.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(\"FOO\") class MyClient {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def myMethod() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("FOO.FOO");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}  ");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("application/MyAnnotation.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("application.MyClient.FOO");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = clazz.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("FOO", _simpleName);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableClassDeclaration clazz2 = _typeLookup_1.findClass("application.MyClient");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz2.getDeclaredMethods();
        MutableMethodDeclaration _head_1 = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableParameterDeclaration> _parameters = _head_1.getParameters();
        MutableParameterDeclaration _head_2 = IterableExtensions.head(_parameters);
        String _simpleName_1 = _head_2.getSimpleName();
        Assert.assertEquals("FOO", _simpleName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetDocumentation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("docComment = docComment.toCharArray.reverse.join");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* dlroW olleH");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        String _docComment = clazz.getDocComment();
        Assert.assertEquals("Hello World", _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTarget");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AddAnnotationValueProcessor)");
    _builder.newLine();
    _builder.append("annotation AddAnnotationValue { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AddAnnotationValueProcessor implements TransformationParticipant<MutableAnnotationTarget> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableAnnotationTarget> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addAnnotation(typeof(MyAnnotation).findTypeGlobally) => [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(null, #[\'foo\',\'bar\',\'baz\'] as String[])");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleValue\', \'foo\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'booleans\', #[true, false, true] as boolean[])");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleBoolean\', true)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'numbers\', #[1,2,3] as int[])");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleNumber\', 1)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String singleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean singleBoolean");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] numbers");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int singleNumber");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddAnnotationValue.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddAnnotationValue");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
        TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference("myannotation.MyAnnotation");
        Type _type = _newTypeReference.getType();
        final MutableAnnotationReference annotation = clazz.findAnnotation(_type);
        Object _value = annotation.getValue("value");
        Assert.assertArrayEquals(((String[]) ((String[])Conversions.unwrapArray(Collections.<String>unmodifiableList(Lists.<String>newArrayList("foo", "bar", "baz")), String.class))), ((String[]) _value));
        Object _value_1 = annotation.getValue("singleValue");
        Assert.assertEquals("foo", _value_1);
        Object _value_2 = annotation.getValue("booleans");
        final boolean[] booleans = ((boolean[]) _value_2);
        boolean _get = booleans[2];
        Assert.assertTrue(_get);
        Object _value_3 = annotation.getValue("singleBoolean");
        Assert.assertEquals(Boolean.valueOf(true), _value_3);
        Object _value_4 = annotation.getValue("numbers");
        Assert.assertArrayEquals(new int[] { 1, 2, 3 }, ((int[]) _value_4));
        Object _value_5 = annotation.getValue("singleNumber");
        Assert.assertEquals(Integer.valueOf(1), _value_5);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testCreateTypeFromUsage() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.Documented");
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SomeProcessor))");
    _builder.newLine();
    _builder.append("@Documented");
    _builder.newLine();
    _builder.append("@Target(ElementType::TYPE)");
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {}");
    _builder.newLine();
    _builder.append("class SomeProcessor implements RegisterGlobalsParticipant<TypeDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends TypeDeclaration> types, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("declaredMethods.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("context.registerClass(parameterType)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private def getParameterType(MethodDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("parameters.head.type.type.qualifiedName");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SomeAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.SomeAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void myMethod(DoesNotExist p) {}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.DoesNotExist");
        String _simpleName = _findClass.getSimpleName();
        boolean _equals = Objects.equal(_simpleName, "DoesNotExist");
        Assert.assertTrue(_equals);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testPropertyAnnotation() {
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/PropertyAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(typeof(PropertyProcessor))\n\t\t\t\tannotation Property2 { }\n\t\t\t\tclass PropertyProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tval declaringType = field.declaringType \n\t\t\t\t\t\t\tdeclaringType.addMethod(field.getterName) [\n\t\t\t\t\t\t\t\treturnType = field.type\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\treturn this.field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\tdeclaringType.addMethod(\'set\'+field.simpleName.toFirstUpper) [\n\t\t\t\t\t\t\t\taddParameter(field.simpleName, field.type)\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\tthis.field.simpleName = field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdef private String getterName(MutableFieldDeclaration field) {\n\t\t\t\t\t\treturn \'get\'+field.simpleName.toFirstUpper\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Property2 String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
        final MutableMethodDeclaration getter = IterableExtensions.head(_declaredMethods);
        String _simpleName = getter.getSimpleName();
        Assert.assertEquals("getMyField", _simpleName);
        TypeReference _returnType = getter.getReturnType();
        String _string = _returnType.toString();
        Assert.assertEquals("String", _string);
        TypeReference _returnType_1 = getter.getReturnType();
        final MutableMethodDeclaration setter = clazz.findDeclaredMethod("setMyField", _returnType_1);
        String _simpleName_1 = setter.getSimpleName();
        Assert.assertEquals("setMyField", _simpleName_1);
        TypeReference _returnType_2 = setter.getReturnType();
        String _string_1 = _returnType_2.toString();
        Assert.assertEquals("void", _string_1);
        Iterable<? extends MutableParameterDeclaration> _parameters = setter.getParameters();
        MutableParameterDeclaration _head = IterableExtensions.head(_parameters);
        String _simpleName_2 = _head.getSimpleName();
        Assert.assertEquals("myField", _simpleName_2);
        Iterable<? extends MutableParameterDeclaration> _parameters_1 = setter.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters_1);
        TypeReference _type = _head_1.getType();
        String _string_2 = _type.toString();
        Assert.assertEquals("String", _string_2);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testThrowsAndTypeParam() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ThrowsAndTypeParamProcessor))");
    _builder.newLine();
    _builder.append("annotation ThrowsAndTypeParam { }");
    _builder.newLine();
    _builder.append("class ThrowsAndTypeParamProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val type = addTypeParameter(\'A\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\'myParam\', newTypeReference(type))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setExceptions(newTypeReference(\'java.lang.Exception\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.ThrowsAndTypeParam");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(){");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
        final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableTypeParameterDeclaration> _typeParameters = method.getTypeParameters();
        MutableTypeParameterDeclaration _head = IterableExtensions.head(_typeParameters);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("A", _simpleName);
        Iterable<? extends MutableParameterDeclaration> _parameters = method.getParameters();
        MutableParameterDeclaration _head_1 = IterableExtensions.head(_parameters);
        String _simpleName_1 = _head_1.getSimpleName();
        Assert.assertEquals("myParam", _simpleName_1);
        Iterable<? extends MutableTypeParameterDeclaration> _typeParameters_1 = method.getTypeParameters();
        MutableTypeParameterDeclaration _head_2 = IterableExtensions.head(_typeParameters_1);
        Iterable<? extends MutableParameterDeclaration> _parameters_1 = method.getParameters();
        MutableParameterDeclaration _head_3 = IterableExtensions.head(_parameters_1);
        TypeReference _type = _head_3.getType();
        Type _type_1 = _type.getType();
        Assert.assertSame(_head_2, _type_1);
        Iterable<? extends TypeReference> _exceptions = method.getExceptions();
        int _size = IterableExtensions.size(_exceptions);
        Assert.assertEquals(1, _size);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testValidation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ValidatedProcessor))");
    _builder.newLine();
    _builder.append("annotation Validated { }");
    _builder.newLine();
    _builder.append("class ValidatedProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch ele {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MutableFieldDeclaration : ele.addWarning(\'field-warning\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default : ele.addWarning(\'warning\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String name");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
        Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
        final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
        Iterable<? extends MutableFieldDeclaration> _declaredFields = type.getDeclaredFields();
        final MutableFieldDeclaration field = IterableExtensions.head(_declaredFields);
        ProblemSupport _problemSupport = it.getProblemSupport();
        List<Problem> _problems = _problemSupport.getProblems(field);
        Problem _head = IterableExtensions.<Problem>head(_problems);
        String _message = _head.getMessage();
        Assert.assertEquals("field-warning", _message);
        ProblemSupport _problemSupport_1 = it.getProblemSupport();
        List<Problem> _problems_1 = _problemSupport_1.getProblems(method);
        Problem _head_1 = IterableExtensions.<Problem>head(_problems_1);
        String _message_1 = _head_1.getMessage();
        Assert.assertEquals("warning", _message_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testIntroduceNewTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\".InnerClass\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerInterface(clazz.qualifiedName+\"Interface\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerEnumerationType(clazz.qualifiedName+\"Enum\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerAnnotationType(clazz.qualifiedName+\"Annotation\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
        Assert.assertNotNull(_findClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        MutableClassDeclaration _findClass_1 = _typeLookup_1.findClass("myusercode.MyClass.InnerClass");
        Assert.assertNotNull(_findClass_1);
        TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
        MutableInterfaceDeclaration _findInterface = _typeLookup_2.findInterface("myusercode.MyClassInterface");
        Assert.assertNotNull(_findInterface);
        TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
        MutableEnumerationTypeDeclaration _findEnumerationType = _typeLookup_3.findEnumerationType("myusercode.MyClassEnum");
        Assert.assertNotNull(_findEnumerationType);
        TypeLookupImpl _typeLookup_4 = it.getTypeLookup();
        MutableAnnotationTypeDeclaration _findAnnotationType = _typeLookup_4.findAnnotationType("myusercode.MyClassAnnotation");
        Assert.assertNotNull(_findAnnotationType);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testIntroduceNewTypeAndWorkWithIt() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration>, TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val cl = context.findClass(ele.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("cl.extendedClass = newTypeReference(ele)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration declaredClass = _typeLookup.findClass("myusercode.MyClass");
        Assert.assertNotNull(declaredClass);
        TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
        final MutableClassDeclaration clazz = _typeLookup_1.findClass("myusercode.MyClassDerived");
        Assert.assertNotNull(clazz);
        String _qualifiedName = declaredClass.getQualifiedName();
        TypeReference _extendedClass = clazz.getExtendedClass();
        Type _type = _extendedClass.getType();
        String _qualifiedName_1 = _type.getQualifiedName();
        Assert.assertEquals(_qualifiedName, _qualifiedName_1);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  private final Pair<String,String> THREE_ANNOTATIONS = new Function0<Pair<String,String>>() {
    public Pair<String,String> apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package myannotation");
      _builder.newLine();
      _builder.newLine();
      _builder.append("import java.util.List");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.Active");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Aprocessor))");
      _builder.newLine();
      _builder.append("annotation _A {}");
      _builder.newLine();
      _builder.append("class Aprocessor implements TransformationParticipant<MutableNamedElement> {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements, extension TransformationContext context) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("annotatedTargetElements.forEach[");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("simpleName = simpleName + num()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def num() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\'_A\'");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("@Active(typeof(Bprocessor))");
      _builder.newLine();
      _builder.append("annotation _B {}");
      _builder.newLine();
      _builder.append("class Bprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_B\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Cprocessor))");
      _builder.newLine();
      _builder.append("annotation _C {}");
      _builder.newLine();
      _builder.append("class Cprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_C\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/three.xtend", _builder.toString());
      return _mappedTo;
    }
  }.apply();
  
  @Test
  public void testDeterministicExecutionOrder_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("field_A_B_C", _simpleName);
      }
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  @Test
  public void testDeterministicExecutionOrder_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_C @_B @_A String field2");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
        Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
        MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
        String _simpleName = _head.getSimpleName();
        Assert.assertEquals("field1_A_B_C", _simpleName);
        Iterable<? extends MutableFieldDeclaration> _declaredFields_1 = myClass.getDeclaredFields();
        MutableFieldDeclaration _get = ((MutableFieldDeclaration[])Conversions.unwrapArray(_declaredFields_1, MutableFieldDeclaration.class))[1];
        String _simpleName_1 = _get.getSimpleName();
        Assert.assertEquals("field2_A_B_C", _simpleName_1);
      }
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  public abstract void assertProcessing(final Pair<String,String> macroFile, final Pair<String,String> clientFile, final Procedure1<? super CompilationUnitImpl> expectations);
  
  @Test
  public void testFileSystemSupport_01() {
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/FileSystemSupportTest.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\t\n\t\t\t\t@Active(FileSystemUsingProcessor)\n\t\t\t\tannotation FileSystemSupportTest { }\n\t\t\t\t\n\t\t\t\tclass FileSystemUsingProcessor extends AbstractClassProcessor {\n\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tval path = annotatedClass.compilationUnit.filePath\n\t\t\t\t\t\tannotatedClass.docComment = \'\'\'\n\t\t\t\t\t\t\tPath \'path.toString\' {\n\t\t\t\t\t\t\t\texists: path.exists\n\t\t\t\t\t\t\t\tisFolder: path.isFolder\n\t\t\t\t\t\t\t\tisFile: path.isFile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceFolder : path.sourceFolder\n\t\t\t\t\t\t\ttargetFolder : path.targetFolder\n\t\t\t\t\t\t\tprojectFolder: path.projectFolder\n\t\t\t\t\t\t\'\'\'\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.FileSystemSupportTest");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
      public void apply(final CompilationUnitImpl it) {
        TypeLookupImpl _typeLookup = it.getTypeLookup();
        final MutableClassDeclaration declaredClass = _typeLookup.findClass("myusercode.MyClass");
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Path \'/userProject/src/myusercode/UserCode.xtend\' {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("exists: true");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("isFolder: false");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("isFile: true");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
        _builder.append("sourceFolder : /userProject/src");
        _builder.newLine();
        _builder.append("targetFolder : /userProject/xtend-gen");
        _builder.newLine();
        _builder.append("projectFolder: /userProject");
        _builder.newLine();
        String _string = _builder.toString();
        String _docComment = declaredClass.getDocComment();
        Assert.assertEquals(_string, _docComment);
      }
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
}
