/*******************************************************************************
* Copyright (c) 2008 itemis AG and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
grammar org.eclipse.xtext.parser.terminalrules.XtextTerminalsTestLanguage extends NULL hidden(WS, ML_COMMENT, SL_COMMENT)

generate xtextTerminalsTestLanguage "http://www.eclipse.org/2008/tmf/xtext/XtextTerminalsTestLanguage"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Grammar:
    'grammar' name=GrammarID ('extends' superGrammar=[Grammar|GrammarID])?
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule] (',' hiddenTokens+=[AbstractRule])*)? ')')?
	metamodelDeclarations+=AbstractMetamodelDeclaration* 
    (rules+=AbstractRule)+
;

GrammarID returns EString:
  ID ('.' ID)*;
  
AbstractRule : ParserRule | TerminalRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;
	
// constraint: typeSelect(GeneratedMetamodel).size() == typeSelect(GeneratedMetamodel).alias.size()
// generated metamodels have to have different aliases
GeneratedMetamodel :
	'generate' name=ID ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

// referenced metamodels may share aliases with other referenced metamodels
// and with generated metamodels
ReferencedMetamodel :
	'import' ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

ParserRule :
    name=ID ('returns' type=TypeRef)? (definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule] (',' hiddenTokens+=[AbstractRule])*)? ')')?':' 
    	alternatives=Alternatives   
    ';'
;

TerminalRule :
	'terminal' name=ID ('returns' type=TypeRef)? ':'
		alternatives=TerminalAlternatives
	';'
;

TypeRef :
	(metamodel=[AbstractMetamodelDeclaration] '::')? type=[EClassifier]
;

Alternatives returns AbstractElement:
    Group ({Alternatives.groups+=current} '|' groups+=Group)*
;

TerminalAlternatives returns AbstractElement:
	TerminalGroup ({Alternatives.groups+=current} '|' groups+=TerminalGroup)*
;

Group returns AbstractElement:
    AbstractToken ( {current=Group.abstractTokens+=current} abstractTokens+=AbstractToken)*
;

TerminalGroup returns AbstractElement:
	TerminalToken ( {current=Group.abstractTokens+=current} abstractTokens+=TerminalToken)*
;

AbstractToken returns AbstractElement:
	(Assignment | 
	 Action |
	 AbstractTerminal) (cardinality=('?'|'*'|'+'))?
;

TerminalToken returns AbstractElement:
	TerminalTokenElement (cardinality=('?'|'*'|'+'))?
;

Assignment returns Assignment:
   feature=ID operator=('+='|'='|'?=') ^terminal=AbstractTerminal;

Action returns Action:
	'{' ('current' '=')? typeName=TypeRef '.' feature=ID operator=('='|'+=') 'current' '}';//TODO make assignment optional

AbstractTerminal returns AbstractElement: 
   Keyword | RuleCall | ParenthesizedElement | CrossReference
;

TerminalTokenElement returns AbstractElement: 
   CharacterRange | RuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard
;

AbstractNegatedToken:
   NegatedToken | UpToToken
;

NegatedToken:
	'!' ^terminal=TerminalTokenElement
;

UpToToken:
	'->' ^terminal=TerminalTokenElement
;

Wildcard:
	isWildcard?='.'
;

CharacterRange returns AbstractElement:
	Keyword ( {current=CharacterRange.left=current} '..' right=Keyword)?
;

CrossReference :
	'[' type=TypeRef ('|' rule=[AbstractRule])? ']'
;

ParenthesizedElement returns AbstractElement:
   '(' Alternatives ')'
;

ParenthesizedTerminalElement returns AbstractElement:
   '(' TerminalAlternatives ')'
;

Keyword : 
   value=STRING 
;

RuleCall :
   rule=[AbstractRule]
;
 
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT 		: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;