/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.assignments.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.parser.assignments.services.AssignmentsTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class AssignmentsTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private AssignmentsTestLanguageGrammarAccess grammarAccess;
		
	public AssignmentsTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Alternatives(this, this, 0, inst);
			case 1: return new SingleValue_Alternatives(this, this, 1, inst);
			case 2: return new MultiValue_Alternatives(this, this, 2, inst);
			case 3: return new SingleDatatype_Alternatives(this, this, 3, inst);
			case 4: return new MultiDatatype_Alternatives(this, this, 4, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   "simple" (single=SingleValue|multi=MultiValue|single=SingleDatatype|multi=
 *   MultiDatatype)|"complex" object=( SingleValue | MultiValue | SingleDatatype |
 *   MultiDatatype );
 *
 **/

// "simple" (single=SingleValue|multi=MultiValue|single=SingleDatatype|multi=
// MultiDatatype)|"complex" object=( SingleValue | MultiValue | SingleDatatype |
// MultiDatatype )
protected class Model_Alternatives extends AlternativesToken {

	public Model_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group_0(parent, this, 0, inst);
			case 1: return new Model_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "simple" (single=SingleValue|multi=MultiValue|single=SingleDatatype|multi=
// MultiDatatype)
protected class Model_Group_0 extends GroupToken {
	
	public Model_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Alternatives_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "simple"
protected class Model_SimpleKeyword_0_0 extends KeywordToken  {
	
	public Model_SimpleKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getSimpleKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// single=SingleValue|multi=MultiValue|single=SingleDatatype|multi=MultiDatatype
protected class Model_Alternatives_0_1 extends AlternativesToken {

	public Model_Alternatives_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_SingleAssignment_0_1_0(parent, this, 0, inst);
			case 1: return new Model_MultiAssignment_0_1_1(parent, this, 1, inst);
			case 2: return new Model_SingleAssignment_0_1_2(parent, this, 2, inst);
			case 3: return new Model_MultiAssignment_0_1_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// single=SingleValue
protected class Model_SingleAssignment_0_1_0 extends AssignmentToken  {
	
	public Model_SingleAssignment_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getSingleAssignment_0_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("single",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("single");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getSingleSingleValueParserRuleCall_0_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SimpleKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// multi=MultiValue
protected class Model_MultiAssignment_0_1_1 extends AssignmentToken  {
	
	public Model_MultiAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getMultiAssignment_0_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("multi",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("multi");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getMultiMultiValueParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SimpleKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// single=SingleDatatype
protected class Model_SingleAssignment_0_1_2 extends AssignmentToken  {
	
	public Model_SingleAssignment_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getSingleAssignment_0_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("single",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("single");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleDatatypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getSingleSingleDatatypeParserRuleCall_0_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SimpleKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// multi=MultiDatatype
protected class Model_MultiAssignment_0_1_3 extends AssignmentToken  {
	
	public Model_MultiAssignment_0_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getMultiAssignment_0_1_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("multi",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("multi");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiDatatypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getMultiMultiDatatypeParserRuleCall_0_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SimpleKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "complex" object=( SingleValue | MultiValue | SingleDatatype | MultiDatatype )
protected class Model_Group_1 extends GroupToken {
	
	public Model_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ObjectAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "complex"
protected class Model_ComplexKeyword_1_0 extends KeywordToken  {
	
	public Model_ComplexKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getComplexKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// object=( SingleValue | MultiValue | SingleDatatype | MultiDatatype )
protected class Model_ObjectAssignment_1_1 extends AssignmentToken  {
	
	public Model_ObjectAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getObjectAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_Alternatives(this, this, 0, inst);
			case 1: return new MultiValue_Alternatives(this, this, 1, inst);
			case 2: return new SingleDatatype_Alternatives(this, this, 2, inst);
			case 3: return new MultiDatatype_Alternatives(this, this, 3, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("object",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("object");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getObjectSingleValueParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getObjectMultiValueParserRuleCall_1_1_0_1(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleDatatypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getObjectSingleDatatypeParserRuleCall_1_1_0_2(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiDatatypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getObjectMultiDatatypeParserRuleCall_1_1_0_3(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_ComplexKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Model ****************/


/************ begin Rule SingleValue ****************
 *
 * SingleValue:
 *   "id" value=ID|"alternative" value=( ID | STRING )|"string" value=STRING;
 *
 **/

// "id" value=ID|"alternative" value=( ID | STRING )|"string" value=STRING
protected class SingleValue_Alternatives extends AlternativesToken {

	public SingleValue_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_Group_0(parent, this, 0, inst);
			case 1: return new SingleValue_Group_1(parent, this, 1, inst);
			case 2: return new SingleValue_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSingleValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "id" value=ID
protected class SingleValue_Group_0 extends GroupToken {
	
	public SingleValue_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_ValueAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "id"
protected class SingleValue_IdKeyword_0_0 extends KeywordToken  {
	
	public SingleValue_IdKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getIdKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=ID
protected class SingleValue_ValueAssignment_0_1 extends AssignmentToken  {
	
	public SingleValue_ValueAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getValueAssignment_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_IdKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleValueAccess().getValueIDTerminalRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// "alternative" value=( ID | STRING )
protected class SingleValue_Group_1 extends GroupToken {
	
	public SingleValue_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_ValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "alternative"
protected class SingleValue_AlternativeKeyword_1_0 extends KeywordToken  {
	
	public SingleValue_AlternativeKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getAlternativeKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=( ID | STRING )
protected class SingleValue_ValueAssignment_1_1 extends AssignmentToken  {
	
	public SingleValue_ValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_AlternativeKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleValueAccess().getValueIDTerminalRuleCall_1_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleValueAccess().getValueSTRINGTerminalRuleCall_1_1_0_1();
			return obj;
		}
		return null;
	}

}


// "string" value=STRING
protected class SingleValue_Group_2 extends GroupToken {
	
	public SingleValue_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_ValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "string"
protected class SingleValue_StringKeyword_2_0 extends KeywordToken  {
	
	public SingleValue_StringKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getStringKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=STRING
protected class SingleValue_ValueAssignment_2_1 extends AssignmentToken  {
	
	public SingleValue_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleValueAccess().getValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleValue_StringKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleValueAccess().getValueSTRINGTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule SingleValue ****************/


/************ begin Rule MultiValue ****************
 *
 * MultiValue:
 *   "ids" value+=ID|"alternatives" value+=( ID | STRING )|"strings" value+=STRING;
 *
 **/

// "ids" value+=ID|"alternatives" value+=( ID | STRING )|"strings" value+=STRING
protected class MultiValue_Alternatives extends AlternativesToken {

	public MultiValue_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_Group_0(parent, this, 0, inst);
			case 1: return new MultiValue_Group_1(parent, this, 1, inst);
			case 2: return new MultiValue_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "ids" value+=ID
protected class MultiValue_Group_0 extends GroupToken {
	
	public MultiValue_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_ValueAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "ids"
protected class MultiValue_IdsKeyword_0_0 extends KeywordToken  {
	
	public MultiValue_IdsKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getIdsKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=ID
protected class MultiValue_ValueAssignment_0_1 extends AssignmentToken  {
	
	public MultiValue_ValueAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getValueAssignment_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_IdsKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMultiValueAccess().getValueIDTerminalRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// "alternatives" value+=( ID | STRING )
protected class MultiValue_Group_1 extends GroupToken {
	
	public MultiValue_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_ValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "alternatives"
protected class MultiValue_AlternativesKeyword_1_0 extends KeywordToken  {
	
	public MultiValue_AlternativesKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getAlternativesKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=( ID | STRING )
protected class MultiValue_ValueAssignment_1_1 extends AssignmentToken  {
	
	public MultiValue_ValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_AlternativesKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMultiValueAccess().getValueIDTerminalRuleCall_1_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMultiValueAccess().getValueSTRINGTerminalRuleCall_1_1_0_1();
			return obj;
		}
		return null;
	}

}


// "strings" value+=STRING
protected class MultiValue_Group_2 extends GroupToken {
	
	public MultiValue_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_ValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "strings"
protected class MultiValue_StringsKeyword_2_0 extends KeywordToken  {
	
	public MultiValue_StringsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getStringsKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=STRING
protected class MultiValue_ValueAssignment_2_1 extends AssignmentToken  {
	
	public MultiValue_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiValueAccess().getValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiValue_StringsKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMultiValueAccess().getValueSTRINGTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule MultiValue ****************/


/************ begin Rule SingleDatatype ****************
 *
 * SingleDatatype returns SingleValue:
 *   "datatypeid" value=IdDatatype|"datatypealternative" value=( IdDatatype |
 *   StringDatatype )|"datatypestring" value=StringDatatype;
 *
 **/

// "datatypeid" value=IdDatatype|"datatypealternative" value=( IdDatatype |
// StringDatatype )|"datatypestring" value=StringDatatype
protected class SingleDatatype_Alternatives extends AlternativesToken {

	public SingleDatatype_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_Group_0(parent, this, 0, inst);
			case 1: return new SingleDatatype_Group_1(parent, this, 1, inst);
			case 2: return new SingleDatatype_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSingleDatatypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "datatypeid" value=IdDatatype
protected class SingleDatatype_Group_0 extends GroupToken {
	
	public SingleDatatype_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_ValueAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypeid"
protected class SingleDatatype_DatatypeidKeyword_0_0 extends KeywordToken  {
	
	public SingleDatatype_DatatypeidKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getDatatypeidKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=IdDatatype
protected class SingleDatatype_ValueAssignment_0_1 extends AssignmentToken  {
	
	public SingleDatatype_ValueAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getValueAssignment_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_DatatypeidKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSingleDatatypeAccess().getValueIdDatatypeParserRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// "datatypealternative" value=( IdDatatype | StringDatatype )
protected class SingleDatatype_Group_1 extends GroupToken {
	
	public SingleDatatype_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_ValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypealternative"
protected class SingleDatatype_DatatypealternativeKeyword_1_0 extends KeywordToken  {
	
	public SingleDatatype_DatatypealternativeKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getDatatypealternativeKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=( IdDatatype | StringDatatype )
protected class SingleDatatype_ValueAssignment_1_1 extends AssignmentToken  {
	
	public SingleDatatype_ValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_DatatypealternativeKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSingleDatatypeAccess().getValueIdDatatypeParserRuleCall_1_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSingleDatatypeAccess().getValueStringDatatypeParserRuleCall_1_1_0_1();
			return obj;
		}
		return null;
	}

}


// "datatypestring" value=StringDatatype
protected class SingleDatatype_Group_2 extends GroupToken {
	
	public SingleDatatype_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_ValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypestring"
protected class SingleDatatype_DatatypestringKeyword_2_0 extends KeywordToken  {
	
	public SingleDatatype_DatatypestringKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getDatatypestringKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=StringDatatype
protected class SingleDatatype_ValueAssignment_2_1 extends AssignmentToken  {
	
	public SingleDatatype_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleDatatypeAccess().getValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SingleDatatype_DatatypestringKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSingleDatatypeAccess().getValueStringDatatypeParserRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule SingleDatatype ****************/


/************ begin Rule MultiDatatype ****************
 *
 * MultiDatatype returns MultiValue:
 *   "datatypeids" value+=IdDatatype|"datatypealternatives" value+=( IdDatatype |
 *   StringDatatype )|"datatypestrings" value+=StringDatatype;
 *
 **/

// "datatypeids" value+=IdDatatype|"datatypealternatives" value+=( IdDatatype |
// StringDatatype )|"datatypestrings" value+=StringDatatype
protected class MultiDatatype_Alternatives extends AlternativesToken {

	public MultiDatatype_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_Group_0(parent, this, 0, inst);
			case 1: return new MultiDatatype_Group_1(parent, this, 1, inst);
			case 2: return new MultiDatatype_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiDatatypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "datatypeids" value+=IdDatatype
protected class MultiDatatype_Group_0 extends GroupToken {
	
	public MultiDatatype_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_ValueAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypeids"
protected class MultiDatatype_DatatypeidsKeyword_0_0 extends KeywordToken  {
	
	public MultiDatatype_DatatypeidsKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getDatatypeidsKeyword_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=IdDatatype
protected class MultiDatatype_ValueAssignment_0_1 extends AssignmentToken  {
	
	public MultiDatatype_ValueAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getValueAssignment_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_DatatypeidsKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getMultiDatatypeAccess().getValueIdDatatypeParserRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// "datatypealternatives" value+=( IdDatatype | StringDatatype )
protected class MultiDatatype_Group_1 extends GroupToken {
	
	public MultiDatatype_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_ValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypealternatives"
protected class MultiDatatype_DatatypealternativesKeyword_1_0 extends KeywordToken  {
	
	public MultiDatatype_DatatypealternativesKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getDatatypealternativesKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=( IdDatatype | StringDatatype )
protected class MultiDatatype_ValueAssignment_1_1 extends AssignmentToken  {
	
	public MultiDatatype_ValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_DatatypealternativesKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getMultiDatatypeAccess().getValueIdDatatypeParserRuleCall_1_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getMultiDatatypeAccess().getValueStringDatatypeParserRuleCall_1_1_0_1();
			return obj;
		}
		return null;
	}

}


// "datatypestrings" value+=StringDatatype
protected class MultiDatatype_Group_2 extends GroupToken {
	
	public MultiDatatype_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_ValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "datatypestrings"
protected class MultiDatatype_DatatypestringsKeyword_2_0 extends KeywordToken  {
	
	public MultiDatatype_DatatypestringsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getDatatypestringsKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value+=StringDatatype
protected class MultiDatatype_ValueAssignment_2_1 extends AssignmentToken  {
	
	public MultiDatatype_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiDatatypeAccess().getValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiDatatype_DatatypestringsKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getMultiDatatypeAccess().getValueStringDatatypeParserRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule MultiDatatype ****************/



}
