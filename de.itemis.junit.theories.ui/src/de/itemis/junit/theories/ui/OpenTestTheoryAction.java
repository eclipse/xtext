package de.itemis.junit.theories.ui;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.ITypeHierarchy;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.corext.util.JavaConventionsUtil;
import org.eclipse.jdt.internal.junit.BasicElementLabels;
import org.eclipse.jdt.internal.junit.Messages;
import org.eclipse.jdt.internal.junit.model.TestCaseElement;
import org.eclipse.jdt.internal.junit.ui.JUnitMessages;
import org.eclipse.jdt.internal.junit.ui.OpenTestAction;
import org.eclipse.jdt.internal.junit.ui.TestRunnerViewPart;
import org.eclipse.jdt.junit.runners.ReflectionUtil;
import org.eclipse.jface.dialogs.MessageDialog;

@SuppressWarnings("restriction")
public class OpenTestTheoryAction extends OpenTestAction {

	public OpenTestTheoryAction(TestRunnerViewPart testRunnerPart, TestCaseElement testCase) {
		super(testRunnerPart, testCase);
		setText("Go to Theory");
	}

	@Override
	protected IJavaElement findElement(IJavaProject project, String className) throws JavaModelException {
		IType type = findType(project, className);
		if (type == null)
			return null;
		String fMethodName = ReflectionUtil.readField(OpenTestAction.class, this, "fMethodName", String.class);
		if (fMethodName == null)
			return type;

		IMethod method = findMethod(type);
		if (method == null) {
			ITypeHierarchy typeHierarchy = type.newSupertypeHierarchy(null);
			IType[] supertypes = typeHierarchy.getAllSuperclasses(type);
			for (IType supertype : supertypes) {
				method = findMethod(supertype);
				if (method != null)
					break;
			}
		}
		if (method == null) {
			String title = JUnitMessages.OpenTestAction_error_title;
			String message = Messages.format(JUnitMessages.OpenTestAction_error_methodNoFound,
					BasicElementLabels.getJavaElementName(fMethodName));
			MessageDialog.openInformation(getShell(), title, message);
			return type;
		}

		ReflectionUtil.writeField(OpenTestAction.class, this, "fMethod", method);
		return method;
	}

	private IMethod findMethod(IType type) {
		String fMethodName = ReflectionUtil.readField(OpenTestAction.class, this, "fMethodName", String.class);
		IStatus status = JavaConventionsUtil.validateMethodName(fMethodName, type);

		// FIX: also find methods with parameters
		if (!status.isOK() || fMethodName == null)
			return null;
		try {
			for (IMethod m : type.getMethods()) {
				if (fMethodName.equals(m.getElementName()) && m.exists())
					return m;

			}
		} catch (JavaModelException e) {
			return null;
		}
		return null;
	}

}
