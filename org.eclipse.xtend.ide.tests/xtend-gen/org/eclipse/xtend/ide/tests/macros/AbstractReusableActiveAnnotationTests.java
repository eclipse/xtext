/**
 * Copyright (c) 2017, 2020 itemis AG (http://www.itemis.eu) and others.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 * 
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.xtend.ide.tests.macros;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend.core.compiler.XtendGenerator;
import org.eclipse.xtend.core.macro.declaration.CompilationUnitImpl;
import org.eclipse.xtend.core.macro.declaration.ExpressionImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmClassDeclarationImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmFieldDeclarationImpl;
import org.eclipse.xtend.core.macro.declaration.MutableJvmMethodDeclarationImpl;
import org.eclipse.xtend.lib.macro.declaration.AnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.AnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.Element;
import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.InterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationValueDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableInterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.expression.Expression;
import org.eclipse.xtend.lib.macro.services.Problem;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.ui.testing.util.LineDelimiters;
import org.eclipse.xtext.xbase.XExpression;
import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;
import org.eclipse.xtext.xbase.jvmmodel.ILogicalContainerProvider;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

@SuppressWarnings("all")
public abstract class AbstractReusableActiveAnnotationTests {
  @Inject
  private XtendGenerator generator;

  @Inject
  private IGeneratorConfigProvider generatorConfigProvider;

  @Inject
  private ValidationTestHelper validator;

  @Inject
  private ILogicalContainerProvider logicalContainerProvider;

  @Test
  public void testBug453273() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Target(ElementType.TYPE)");
    _builder.newLine();
    _builder.append("@Active(AddNestedTypesProcessor)");
    _builder.newLine();
    _builder.append("annotation AddNestedTypes {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AddNestedTypesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, RegisterGlobalsContext registerGlobalsContext) {");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(qualifiedName + \".NestedType\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(qualifiedName + \".NestedType.NestedType2\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(packageName + \".OtherTopLevelClass\")");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("registerGlobalsContext.registerClass(packageName + \".OtherTopLevelClass.NestedType\")");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("   ");
    _builder.append("def String getPackageName(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("   \t  ");
    _builder.append("qualifiedName.substring(0,qualifiedName.lastIndexOf(\'.\'))");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddNestedTypes.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package my.client");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddNestedTypes");
    _builder_1.newLine();
    _builder_1.append("class TopLevelClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("my/client/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      this.validator.assertNoErrors(it.getXtendFile());
      Assert.assertNotNull(it.getTypeLookup().findClass("my.client.TopLevelClass"));
      Assert.assertNotNull(it.getTypeLookup().findClass("my.client.TopLevelClass.NestedType"));
      Assert.assertNotNull(it.getTypeLookup().findClass("my.client.TopLevelClass.NestedType.NestedType2"));
      Assert.assertNotNull(it.getTypeLookup().findClass("my.client.OtherTopLevelClass"));
      Assert.assertNotNull(it.getTypeLookup().findClass("my.client.OtherTopLevelClass.NestedType"));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testBug441081() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package bug441081");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("interface GenericInterface {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def <T> T m()");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Bug441081Processor)");
    _builder.newLine();
    _builder.append("annotation Bug441081 {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Bug441081Processor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces + #[findTypeGlobally(GenericInterface).newTypeReference]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.addMethod(\"m\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("returnType = addTypeParameter(\"T\", object).newTypeReference");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = \'");
    _builder.append("\'\'return null;\'");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = annotatedClass");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("bug441081/Bug441081.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("import bug441081.Bug441081");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Bug441081");
    _builder_1.newLine();
    _builder_1.append("class Bug441081Client {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("Bug441081Client.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration c = it.getTypeLookup().findClass("Bug441081Client");
      Type _type = c.findDeclaredMethod("m").getReturnType().getType();
      final TypeParameterDeclaration typeParam = ((TypeParameterDeclaration) _type);
      Assert.assertFalse(IterableExtensions.isEmpty(typeParam.getUpperBounds()));
      this.validator.assertNoIssues(it.getXtendFile());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testInferredMethodReturnType() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractMethodProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractMethodProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableMethodDeclaration annotatedMethod, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethod.declaringType.addField(annotatedMethod.simpleName + \'_field\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = annotatedMethod.returnType");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Client {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def bar() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("1");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def create new Integer(1) foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration foo = it.getTypeLookup().findClass("myusercode.Client");
      final TypeReference barType = foo.findDeclaredField("bar_field").getType();
      this.assertSameType(barType, it.getTypeReferenceProvider().getPrimitiveInt());
      this.assertSameType(barType, foo.findDeclaredMethod("bar").getReturnType());
      final TypeReference fooType = foo.findDeclaredField("foo_field").getType();
      this.assertSameType(fooType, it.getTypeReferenceProvider().newTypeReference(Integer.class));
      this.assertSameType(fooType, foo.findDeclaredMethod("foo").getReturnType());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testTracing() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(GettersProcessor)");
    _builder.newLine();
    _builder.append("annotation Getters {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class GettersProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.declaredFields.filter[isThePrimaryGeneratedJavaElement].forEach [field|");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("cls.addMethod(\"get\" + field.simpleName.toFirstUpper) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("primarySourceElement = field");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\"return this.\" + field.simpleName + \";\"]");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("field.markAsRead");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/Getters.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.Getters");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Getters");
    _builder_1.newLine();
    _builder_1.append("class Client {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val int bar = 1");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def create new Integer(1) foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Client");
      final MutableFieldDeclaration barField = cls.findDeclaredField("bar");
      final Function1<MutableMethodDeclaration, Boolean> _function_1 = (MutableMethodDeclaration it_1) -> {
        return Boolean.valueOf(it_1.getSimpleName().startsWith("get"));
      };
      final Iterable<? extends MutableMethodDeclaration> getters = IterableExtensions.filter(cls.getDeclaredMethods(), _function_1);
      Assert.assertEquals(1, IterableExtensions.size(getters));
      final MutableMethodDeclaration getBar = IterableExtensions.head(getters);
      Assert.assertEquals("getBar", getBar.getSimpleName());
      final JvmField barJvmField = ((MutableJvmFieldDeclarationImpl) barField).getDelegate();
      final JvmOperation getBarJvmMethod = ((MutableJvmMethodDeclarationImpl) getBar).getDelegate();
      final Set<EObject> elementsAssociatedWithBarField = it.getJvmModelAssociations().getJvmElements(it.getJvmModelAssociations().getPrimarySourceElement(barJvmField));
      Assert.assertEquals(2, elementsAssociatedWithBarField.size());
      Assert.assertEquals(barJvmField, ((Object[])Conversions.unwrapArray(elementsAssociatedWithBarField, Object.class))[0]);
      Assert.assertEquals(getBarJvmMethod, ((Object[])Conversions.unwrapArray(elementsAssociatedWithBarField, Object.class))[1]);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testTracing2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.typeParameters.head");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client<A> {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Client");
      final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
      final Element typeParameter = it.getTracability().getPrimarySourceElement(IterableExtensions.head(cls.getTypeParameters()));
      Assert.assertEquals(typeParameter, it.getTracability().getPrimarySourceElement(fooMethod));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testTracing3() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.extendedClass");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client extends Object{}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Client");
      final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
      final Element extendsClause = it.getTracability().getPrimarySourceElement(cls.getExtendedClass());
      Assert.assertTrue((extendsClause instanceof TypeReference));
      Assert.assertEquals(extendsClause, it.getTracability().getPrimarySourceElement(((Element) fooMethod)));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testTracing4() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnoProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnno {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnoProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addMethod(\"foo\") [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("primarySourceElement = cls.annotations.head");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = [\"return;\"]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnno.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnno");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnno");
    _builder_1.newLine();
    _builder_1.append("class Client extends Object{}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Client");
      final MutableMethodDeclaration fooMethod = cls.findDeclaredMethod("foo");
      final Element anno = it.getTracability().getPrimarySourceElement(IterableExtensions.head(cls.getAnnotations()));
      Assert.assertTrue((anno instanceof AnnotationReference));
      Assert.assertEquals(anno, it.getTracability().getPrimarySourceElement(((Element) fooMethod)));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testValidationPhase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ValidatingProcessor)");
    _builder.newLine();
    _builder.append("annotation ValidatingAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ValidatingProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Foo\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Bar\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doValidate(ClassDeclaration cls, extension ValidationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"Baz\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("cls.addWarning(\"There were \" + cls.problems.size + \" problems\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ValidatingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ValidatingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Foo");
      final List<? extends Problem> problems = it.getProblemSupport().getProblems(cls);
      Assert.assertEquals(4, problems.size());
      Assert.assertEquals("Foo", problems.get(0).getMessage());
      Assert.assertEquals("Bar", problems.get(1).getMessage());
      Assert.assertEquals("Baz", problems.get(2).getMessage());
      Assert.assertEquals("There were 3 problems", problems.get(3).getMessage());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testValidateLater() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractFieldProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ValidateLaterProcessor)");
    _builder.newLine();
    _builder.append("annotation ValidateLater {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ValidateLaterProcessor extends AbstractFieldProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableFieldDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("validateLater[ |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (type == primitiveBoolean)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("addWarning(\"The type was inferred and boolean\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ValidateLater.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@ValidateLater val foo = true");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration cls = it.getTypeLookup().findClass("myusercode.Foo");
      final List<? extends Problem> problems = it.getProblemSupport().getProblems(IterableExtensions.head(cls.getDeclaredFields()));
      Assert.assertEquals(1, problems.size());
      Assert.assertEquals("The type was inferred and boolean", problems.get(0).getMessage());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testNoMutationInValidationPhase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.ValidationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(EvilProcessor)");
    _builder.newLine();
    _builder.append("annotation EvilAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class EvilProcessor implements TransformationParticipant<MutableClassDeclaration>, ValidationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("final = false");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doValidate(List<? extends MutableClassDeclaration> classes, extension ValidationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("final = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/EvilAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@EvilAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Function1<Resource.Diagnostic, Boolean> _function_1 = (Resource.Diagnostic it_1) -> {
        return Boolean.valueOf(it_1.getMessage().contains("cannot be modified"));
      };
      IterableExtensions.<Resource.Diagnostic>exists(it.getXtendFile().eResource().getErrors(), _function_1);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSetEmptyListAsAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("annotation Values {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] intValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("long[] longValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("short[] shortValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("double[] doubleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("float[] floatValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("byte[] byteValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleanValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("char[] charValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] stringValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] classValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Enum1[] enumValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Annotation2[] annotationValue");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum Enum1 {}");
    _builder.newLine();
    _builder.append("annotation Annotation2 {}");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("removeAnnotation(annotations.head)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("addAnnotation(Values.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setIntValue(\'intValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setLongValue(\'longValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setShortValue(\'shortValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setDoubleValue(\'doubleValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setFloatValue(\'floatValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setByteValue(\'byteValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setBooleanValue(\'booleanValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setCharValue(\'charValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setStringValue(\'stringValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'classValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'enumValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotationValue\', emptyList)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration foo = it.getTypeLookup().findClass("myusercode.Foo");
      final Type annotationType = it.getTypeLookup().findTypeGlobally("myannotation.Values");
      final AnnotationReference values = foo.findAnnotation(annotationType);
      Assert.assertEquals(0, ((List<Integer>)Conversions.doWrapArray(values.getIntArrayValue("intValue"))).size());
      Assert.assertEquals(0, ((List<Long>)Conversions.doWrapArray(values.getLongArrayValue("longValue"))).size());
      Assert.assertEquals(0, ((List<Short>)Conversions.doWrapArray(values.getShortArrayValue("shortValue"))).size());
      Assert.assertEquals(0, ((List<Double>)Conversions.doWrapArray(values.getDoubleArrayValue("doubleValue"))).size());
      Assert.assertEquals(0, ((List<Float>)Conversions.doWrapArray(values.getFloatArrayValue("floatValue"))).size());
      Assert.assertEquals(0, ((List<Byte>)Conversions.doWrapArray(values.getByteArrayValue("byteValue"))).size());
      Assert.assertEquals(0, ((List<Boolean>)Conversions.doWrapArray(values.getBooleanArrayValue("booleanValue"))).size());
      Assert.assertEquals(0, ((List<Character>)Conversions.doWrapArray(values.getCharArrayValue("charValue"))).size());
      Assert.assertEquals(0, ((List<String>)Conversions.doWrapArray(values.getStringArrayValue("stringValue"))).size());
      Assert.assertEquals(0, ((List<TypeReference>)Conversions.doWrapArray(values.getClassArrayValue("classValue"))).size());
      Assert.assertEquals(0, ((List<EnumerationValueDeclaration>)Conversions.doWrapArray(values.getEnumArrayValue("enumValue"))).size());
      Assert.assertEquals(0, ((List<AnnotationReference>)Conversions.doWrapArray(values.getAnnotationArrayValue("annotationValue"))).size());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testInferredTypeReferences() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?> value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (field : declaredFields) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\'return 1;\']");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val myAnnotation = findAnnotation(MyAnnotation.findTypeGlobally)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val type = myAnnotation.getClassValue(\"value\").type as ClassDeclaration");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (field : type.declaredFields) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = [\'return 1;\']");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(Bar)");
    _builder_1.newLine();
    _builder_1.append("class Foo {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val y = 1");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Bar {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val x = 1");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration foo = it.getTypeLookup().findClass("myusercode.Foo");
      final MutableClassDeclaration bar = it.getTypeLookup().findClass("myusercode.Bar");
      this.assertSameType(foo.findDeclaredField("y").getType(), foo.findDeclaredMethod("y").getReturnType());
      this.assertSameType(bar.findDeclaredField("x").getType(), foo.findDeclaredMethod("x").getReturnType());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationValueSetting_1() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite color");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BlackOrWhite[] colors");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?> type");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("SomeAnnotation annotation");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("SomeAnnotation[] annotations");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum BlackOrWhite {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BLACK, WHITE");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val someAnnotationType = findTypeGlobally(SomeAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val enumType = findTypeGlobally(\'myannotation.BlackOrWhite\') as EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val white = enumType.findDeclaredValue(\'WHITE\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val black = enumType.findDeclaredValue(\'BLACK\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'color\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingValue != white)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"color\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithColor = annotatedClass.addAnnotation(newAnnotationReference(anno) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'color\', black)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(anno)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingColorsValue = annoWithColor.getValue(\'colors\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingColorsValue.get(0) != white && existingColorsValue.get(1) != black && existingColorsValue.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"colors\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithColors = annotatedClass.addAnnotation(newAnnotationReference(annoWithColor) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setEnumValue(\'colors\', black, white)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithColor)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingType = annoWithColors.getValue(\'type\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingType != string)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"type\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithType = annotatedClass.addAnnotation(newAnnotationReference(annoWithColors) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'type\', annotatedClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithColors)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingTypes = annoWithType.getValue(\'types\') as Object[]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (existingTypes.get(0) != primitiveInt && existingTypes.get(1) != annotatedClass.newTypeReference && existingTypes.length != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"types\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithTypes = annotatedClass.addAnnotation(newAnnotationReference(annoWithType) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setClassValue(\'types\', primitiveBoolean)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithType)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReference = annoWithTypes.getAnnotationValue(\'annotation\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (someAnnotationType != annotationReference.annotationTypeDeclaration)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"someAnnotationType != annotationReference.annotationTypeDeclaration\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annoWithAnnotation = annotatedClass.addAnnotation(newAnnotationReference(annoWithTypes) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotation\', ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append(")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithTypes)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReferences = annoWithAnnotation.getAnnotationArrayValue(\'annotations\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (annotationReferences.size != 2)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new AssertionError(\"annotationReferences.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationReferences.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (someAnnotationType != annotationTypeDeclaration)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\"someAnnotationType != annotationTypeDeclaration\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.addAnnotation(newAnnotationReference(annoWithAnnotation) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setAnnotationValue(\'annotations\', ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("],");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("newAnnotationReference(someAnnotationType) [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("setBooleanValue(\'value\', false)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append(")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.removeAnnotation(annoWithAnnotation)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("color=BlackOrWhite.WHITE, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("colors=#[BlackOrWhite.WHITE, BlackOrWhite.BLACK], ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("type = String, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("types=#[Integer, MyClass],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation=@SomeAnnotation(true),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotations=#[@SomeAnnotation(true), @SomeAnnotation(true)]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Type _findTypeGlobally = it.getTypeLookup().findTypeGlobally("myannotation.BlackOrWhite");
      final EnumerationTypeDeclaration colorEnum = ((EnumerationTypeDeclaration) _findTypeGlobally);
      final Type annotationType = it.getTypeLookup().findTypeGlobally("myannotation.ConfigurableAnnotation");
      final AnnotationReference annotation = clazz.findAnnotation(annotationType);
      Assert.assertEquals(colorEnum.findDeclaredValue("BLACK"), annotation.getValue("color"));
      Object _value = annotation.getValue("colors");
      final Object[] colors = ((Object[]) _value);
      Assert.assertEquals(2, colors.length);
      Assert.assertEquals(colorEnum.findDeclaredValue("BLACK"), colors[0]);
      Assert.assertEquals(colorEnum.findDeclaredValue("WHITE"), colors[1]);
      Assert.assertEquals(it.getTypeReferenceProvider().newTypeReference(clazz), annotation.getValue("type"));
      final TypeReference[] types = annotation.getClassArrayValue("types");
      Assert.assertEquals(1, types.length);
      Assert.assertEquals(it.getTypeReferenceProvider().getPrimitiveBoolean(), types[0]);
      final Type someAnnotationType = it.getTypeLookup().findTypeGlobally("myannotation.SomeAnnotation");
      final AnnotationReference annotationValue = annotation.getAnnotationValue("annotation");
      Assert.assertNotNull(annotationValue);
      Assert.assertEquals(someAnnotationType, annotationValue.getAnnotationTypeDeclaration());
      Assert.assertFalse(annotationValue.getBooleanValue("value"));
      final AnnotationReference[] annotationsValue = annotation.getAnnotationArrayValue("annotations");
      Assert.assertNotNull(annotationsValue);
      Assert.assertEquals(2, ((List<AnnotationReference>)Conversions.doWrapArray(annotationsValue)).size());
      final Consumer<AnnotationReference> _function_1 = (AnnotationReference it_1) -> {
        Assert.assertEquals(someAnnotationType, annotationValue.getAnnotationTypeDeclaration());
        Assert.assertFalse(annotationValue.getBooleanValue("value"));
      };
      ((List<AnnotationReference>)Conversions.doWrapArray(annotationsValue)).forEach(_function_1);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationValueSetting_2() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.*");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(ConfigurableAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation ConfigurableAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int someValue");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Constants {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static val int MYCONSTANT = Integer.MAX_VALUE - 42");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ConfigurableAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val anno = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val existingValue = anno.getValue(\'someValue\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.docComment = \'\'+existingValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ConfigurableAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.*");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@ConfigurableAnnotation(someValue=MoreConstants.MY_CONSTANT * 1)");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MoreConstants {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("public static val int MY_CONSTANT = myannotation.Constants.MYCONSTANT - Integer.MAX_VALUE + 42 * 2");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals("42", clazz.getDocComment());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationValueSetting_3() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val field = annotatedClass.declaredFields.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = field.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.removeAnnotation(fieldAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.addAnnotation(fieldAnnotation.annotationTypeDeclaration.qualifiedName.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanValue\', classAnnotation.getValue(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intValue\', classAnnotation.getValue(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longValue\', classAnnotation.getValue(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringValue\', classAnnotation.getValue(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanArrayValue\', classAnnotation.getValue(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intArrayValue\', classAnnotation.getValue(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longArrayValue\', classAnnotation.getValue(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringArrayValue\', classAnnotation.getValue(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeValue\', classAnnotation.getValue(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeArrayValue\', classAnnotation.getValue(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2Value\', classAnnotation.getValue(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2ArrayValue\', classAnnotation.getValue(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumValue\', classAnnotation.getValue(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumArrayValue\', classAnnotation.getValue(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.UserCode");
      final AnnotationReference annoRef = IterableExtensions.head(IterableExtensions.head(clazz.getDeclaredFields()).getAnnotations());
      Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), annoRef.getValue("intValue"));
      Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), annoRef.getValue("longValue"));
      Assert.assertEquals("foobaz", annoRef.getValue("stringValue"));
      Object _value = annoRef.getValue("booleanArrayValue");
      final boolean[] bools = ((boolean[]) _value);
      Assert.assertTrue(bools[0]);
      Assert.assertFalse(bools[1]);
      Object _value_1 = annoRef.getValue("intArrayValue");
      Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_1));
      Object _value_2 = annoRef.getValue("typeArrayValue");
      final TypeReference[] type = ((TypeReference[]) _value_2);
      Assert.assertEquals(it.getTypeReferenceProvider().newTypeReference(Integer.class), type[1]);
      Object _value_3 = annoRef.getValue("annotation2Value");
      final AnnotationReference anno = ((AnnotationReference) _value_3);
      Assert.assertEquals("foowuppa", anno.getValue("value"));
      Object _value_4 = annoRef.getValue("annotation2ArrayValue");
      final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_4);
      Assert.assertEquals("HUBBA BUBBA!", (annoArray[0]).getValue("value"));
      Object _value_5 = annoRef.getValue("enumValue");
      final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_5);
      Assert.assertEquals("YELLOW", enum1.getSimpleName());
      Object _value_6 = annoRef.getValue("enumArrayValue");
      final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_6);
      Assert.assertEquals("YELLOW", IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray))).getSimpleName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationArrayValueGetting_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def check(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("switch qualifiedName {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode2\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode4\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getBooleanArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!value.head) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"!value.head\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getBooleanValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getBooleanValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode3\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode5\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getBooleanArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 2) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!value.head) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"!value.head\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.last) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.last\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getBooleanValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getBooleanValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\'Unexpected type: \' + qualifiedName)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(true)");
    _builder_1.newLine();
    _builder_1.append("class UserCode {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(#[true])");
    _builder_1.newLine();
    _builder_1.append("class UserCode2 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(true, false)");
    _builder_1.newLine();
    _builder_1.append("class UserCode3 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=true)");
    _builder_1.newLine();
    _builder_1.append("class UserCode4 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=#[true, false])");
    _builder_1.newLine();
    _builder_1.append("class UserCode5 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationArrayValueGetting_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration it, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("check");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def check(ClassDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("switch qualifiedName {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode2\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode4\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getClassArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.head.name != \'java.lang.String\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.head.name != \'java.lang.String\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getClassValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getClassValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode3\',");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'myusercode.UserCode5\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("val value = annotations.head.getClassArrayValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.size != 2) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.size != 2\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.head.name != \'java.lang.String\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.head.name != \'java.lang.String\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value.last.name != \'java.lang.Integer\') {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\"value.last.name != \'java.lang.Integer\'\")");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("annotations.head.getClassValue(\"value\")");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("throw new AssertionError(\'annotations.head.getClassValue(\"value\")\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new AssertionError(\'Unexpected type: \' + qualifiedName)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(String)");
    _builder_1.newLine();
    _builder_1.append("class UserCode {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(#[String])");
    _builder_1.newLine();
    _builder_1.append("class UserCode2 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(String, Integer)");
    _builder_1.newLine();
    _builder_1.append("class UserCode3 {}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=String)");
    _builder_1.newLine();
    _builder_1.append("class UserCode4 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(value=#[String, Integer])");
    _builder_1.newLine();
    _builder_1.append("class UserCode5 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Ignore("Setting annotation values of type Expression is not possible")
  @Test
  public void testAnnotationValueSetting_AsExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MoveAnnotationValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation MoveValues {}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MoveAnnotationValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val classAnnotation = annotatedClass.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val field = annotatedClass.declaredFields.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val fieldAnnotation = field.annotations.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.removeAnnotation(fieldAnnotation)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("field.addAnnotation(fieldAnnotation.annotationTypeDeclaration.qualifiedName.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanValue\', classAnnotation.getExpression(\'booleanValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intValue\', classAnnotation.getExpression(\'intValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longValue\', classAnnotation.getExpression(\'longValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringValue\', classAnnotation.getExpression(\'stringValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'booleanArrayValue\', classAnnotation.getExpression(\'booleanArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'intArrayValue\', classAnnotation.getExpression(\'intArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'longArrayValue\', classAnnotation.getExpression(\'longArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'stringArrayValue\', classAnnotation.getExpression(\'stringArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeValue\', classAnnotation.getExpression(\'typeValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'typeArrayValue\', classAnnotation.getExpression(\'typeArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2Value\', classAnnotation.getExpression(\'annotation2Value\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'annotation2ArrayValue\', classAnnotation.getExpression(\'annotation2ArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumValue\', classAnnotation.getExpression(\'enumValue\'))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("set(\'enumArrayValue\', classAnnotation.getExpression(\'enumArrayValue\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MoveValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import test.Annotation");
    _builder_1.newLine();
    _builder_1.append("import test.Annotation2");
    _builder_1.newLine();
    _builder_1.append("import myannotation.MoveValues");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@Annotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intValue = 2 / 2 + 2 * 3 - 4 % 1,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longValue = 42 + 4 + 6 * 42 - 4 / 45,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringValue = \'foo\' + \'baz\',");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanValue = true,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleanArrayValue = #[true, false],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("intArrayValue = #[ -1, 34 + 45, 2 - 6 ],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("longArrayValue = #[42, 5 * -3],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("stringArrayValue = #[\'foo\', \'bla\' + \'buzz\'],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeValue = String,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("typeArrayValue = #[String, Integer],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2Value = @Annotation2(\'foo\' + \'wuppa\'),");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("annotation2ArrayValue = #[@Annotation2, @Annotation2(\'foo\'+\'wuppa\')],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumValue = test.Enum1.YELLOW,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("enumArrayValue = #[test.Enum1.YELLOW, test.Enum1.RED]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("@MoveValues ");
    _builder_1.newLine();
    _builder_1.append("class UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@Annotation() String foo");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.UserCode");
      final AnnotationReference annoRef = IterableExtensions.head(IterableExtensions.head(clazz.getDeclaredFields()).getAnnotations());
      Assert.assertEquals(Integer.valueOf((((2 / 2) + (2 * 3)) - (4 % 1))), annoRef.getValue("intValue"));
      Assert.assertEquals(Long.valueOf(((long) (((42 + 4) + (6 * 42)) - (4 / 45)))), annoRef.getValue("longValue"));
      Assert.assertEquals("foobaz", annoRef.getValue("stringValue"));
      Object _value = annoRef.getValue("booleanValue");
      Assert.assertTrue((((Boolean) _value)).booleanValue());
      Object _value_1 = annoRef.getValue("booleanArrayValue");
      final boolean[] bools = ((boolean[]) _value_1);
      Assert.assertTrue(bools[0]);
      Assert.assertFalse(bools[1]);
      Object _value_2 = annoRef.getValue("intArrayValue");
      Assert.assertArrayEquals(new int[] { (-1), (34 + 45), (2 - 6) }, ((int[]) _value_2));
      Object _value_3 = annoRef.getValue("typeArrayValue");
      final TypeReference[] type = ((TypeReference[]) _value_3);
      Assert.assertEquals(it.getTypeReferenceProvider().newTypeReference(Integer.class), type[1]);
      Object _value_4 = annoRef.getValue("annotation2Value");
      final AnnotationReference anno = ((AnnotationReference) _value_4);
      Assert.assertEquals("foowuppa", anno.getValue("value"));
      Object _value_5 = annoRef.getValue("annotation2ArrayValue");
      final AnnotationReference[] annoArray = ((AnnotationReference[]) _value_5);
      Assert.assertEquals("HUBBA BUBBA!", (annoArray[0]).getValue("value"));
      Object _value_6 = annoRef.getValue("enumValue");
      final EnumerationValueDeclaration enum1 = ((EnumerationValueDeclaration) _value_6);
      Assert.assertEquals("YELLOW", enum1.getSimpleName());
      Object _value_7 = annoRef.getValue("enumArrayValue");
      final EnumerationValueDeclaration[] enumArray = ((EnumerationValueDeclaration[]) _value_7);
      Assert.assertEquals("YELLOW", IterableExtensions.<EnumerationValueDeclaration>head(((Iterable<EnumerationValueDeclaration>)Conversions.doWrapArray(enumArray))).getSimpleName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAccessAndModifyEnumerationValueDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.CodeGenerationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.EnumerationValueDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import static com.google.common.base.Preconditions.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements RegisterGlobalsParticipant<EnumerationTypeDeclaration>, TransformationParticipant<MutableEnumerationTypeDeclaration>, CodeGenerationParticipant<EnumerationTypeDeclaration> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doGenerateCode(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension CodeGenerationContext context) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends EnumerationTypeDeclaration> annotatedSourceElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedSourceElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationTypeDeclaration enumeration) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val values = enumeration.declaredValues");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(values.size == 3, \"enumeration.declaredValues.size != 3\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(0).simpleName).checkState(\"A\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(1).simpleName).checkState(\"B\", enumeration)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enumeration.findDeclaredValue(values.get(2).simpleName).checkState(\"C\", enumeration)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def checkState(EnumerationValueDeclaration value, String expectedSimpleName, TypeDeclaration expectedType) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.simpleName == expectedSimpleName, \"value.simpleName != expectedSimpleName\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.declaringType == expectedType, \"value.declaringType != expectedType\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.visibility == Visibility.PUBLIC, \"value.visibility != Visibility.PUBLIC\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.annotations.size == 0, \"value.annotations.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("checkState(value.findAnnotation(null) == null, \"value.findAnnotation(null) != null\")");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableEnumerationTypeDeclaration> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (enumeration : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.checkState");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (value : enumeration.declaredValues) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 0, value.annotations.size != 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.addAnnotation(Deprecated.newAnnotationReference)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("checkState(value.annotations.size == 1, value.annotations.size != 1)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("enumeration.addValue(\"D\") [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("addAnnotation(Deprecated.newAnnotationReference)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("enum UserCode {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("A, ");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("B,");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("C");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableEnumerationTypeDeclaration enumerationType = it.getTypeLookup().findEnumerationType("myusercode.UserCode");
      Assert.assertEquals(4, IterableExtensions.size(enumerationType.getDeclaredValues()));
      final Type deprecatedAnnotationType = it.getTypeReferenceProvider().newTypeReference(Deprecated.class).getType();
      Iterable<? extends MutableEnumerationValueDeclaration> _declaredValues = enumerationType.getDeclaredValues();
      for (final MutableEnumerationValueDeclaration value : _declaredValues) {
        {
          Assert.assertEquals(1, IterableExtensions.size(value.getAnnotations()));
          Assert.assertNotNull(value.findAnnotation(deprecatedAnnotationType));
        }
      }
      Assert.assertEquals("D", IterableExtensions.lastOrNull(enumerationType.getDeclaredValues()).getSimpleName());
      Assert.assertNotNull(enumerationType.findDeclaredValue("D"));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testModifyTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 0) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"Before: typeParameters.size != 0\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("addTypeParameter(\"T\", String.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (typeParameters.size != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: typeParameters.size != 1\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val typeParameter = typeParameters.head");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (!typeParameter.simpleName.equals(\"T\")) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalStateException(\"After: expected type name: \'T\', actual type name: \'\" + typeParameter.simpleName + \"\'\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Procedure1<MutableTypeParameterDeclarator> _function_1 = (MutableTypeParameterDeclarator it_1) -> {
        Assert.assertEquals(1, IterableExtensions.size(it_1.getTypeParameters()));
        final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(it_1.getTypeParameters());
        Assert.assertEquals("T", typeParameter.getSimpleName());
        Assert.assertEquals(1, IterableExtensions.size(typeParameter.getUpperBounds()));
        Assert.assertEquals("java.lang.String", IterableExtensions.head(typeParameter.getUpperBounds()).getName());
      };
      final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function_1;
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      assertMyAnnotationChanges.apply(clazz);
      assertMyAnnotationChanges.apply(IterableExtensions.head(clazz.getDeclaredConstructors()));
      final MutableInterfaceDeclaration myInterface = it.getTypeLookup().findInterface("myusercode.MyInterface");
      assertMyAnnotationChanges.apply(myInterface);
      assertMyAnnotationChanges.apply(IterableExtensions.head(myInterface.getDeclaredMethods()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testRemoveTypeParameters() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.remove");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends String> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends String> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends String> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Procedure1<MutableTypeParameterDeclarator> _function_1 = (MutableTypeParameterDeclarator it_1) -> {
        Assert.assertEquals(0, IterableExtensions.size(it_1.getTypeParameters()));
      };
      final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function_1;
      assertMyAnnotationChanges.apply(it.getTypeLookup().findClass("myusercode.MyClass"));
      final MutableInterfaceDeclaration myInterface = it.getTypeLookup().findInterface("myusercode.MyInterface");
      assertMyAnnotationChanges.apply(myInterface);
      assertMyAnnotationChanges.apply(IterableExtensions.head(myInterface.getDeclaredMethods()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSetUpperBoundsForMutableTypeParameterDeclaration() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclarator");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableTypeParameterDeclarator> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableTypeParameterDeclarator> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("doTransform(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def doTransform(MutableTypeParameterDeclarator it, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("typeParameters.head.upperBounds = #[String.newTypeReference]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface MyInterface<T extends CharSequence> {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("abstract def <T extends CharSequence> void foo();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Procedure1<MutableTypeParameterDeclarator> _function_1 = (MutableTypeParameterDeclarator it_1) -> {
        Assert.assertEquals(1, IterableExtensions.size(it_1.getTypeParameters()));
        final MutableTypeParameterDeclaration typeParameter = IterableExtensions.head(it_1.getTypeParameters());
        Assert.assertEquals(1, IterableExtensions.size(typeParameter.getUpperBounds()));
        Assert.assertEquals("java.lang.String", IterableExtensions.head(typeParameter.getUpperBounds()).getName());
      };
      final Procedure1<? super MutableTypeParameterDeclarator> assertMyAnnotationChanges = _function_1;
      assertMyAnnotationChanges.apply(it.getTypeLookup().findClass("myusercode.MyClass"));
      final MutableInterfaceDeclaration myInterface = it.getTypeLookup().findInterface("myusercode.MyInterface");
      assertMyAnnotationChanges.apply(myInterface);
      assertMyAnnotationChanges.apply(IterableExtensions.head(myInterface.getDeclaredMethods()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testRemoveAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(RemoveAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation RemoveAnnotation{ }");
    _builder.newLine();
    _builder.append("class RemoveAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationReference = clazz.findAnnotation(RemoveAnnotation.newTypeReference.type)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.removeAnnotation(annotationReference)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/RemoveAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.RemoveAnnotation class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals(1, IterableExtensions.size(clazz.getAnnotations()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testChangeJavaDoc() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ChangeDocProcessor))");
    _builder.newLine();
    _builder.append("annotation ChangeDoc{ }");
    _builder.newLine();
    _builder.append("class ChangeDocProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.docComment = clazz.docComment.toLowerCase");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/ChangeDocAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* MAKE ME LOWER CASE!");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.ChangeDoc class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals("make me lower case!", clazz.getDocComment());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMarkAsDeprecated() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MarkAsDeprecatedProcessor)");
    _builder.newLine();
    _builder.append("annotation MarkAsDeprecated{ }");
    _builder.newLine();
    _builder.append("class MarkAsDeprecatedProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.deprecated = true");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.MarkAsDeprecated class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.MarkAsDeprecated;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@MarkAsDeprecated");
    _builder_2.newLine();
    _builder_2.append("@Deprecated");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }

  @Test
  public void testMarkAsDeprecated_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(UnmarkDeprecatedProcessor)");
    _builder.newLine();
    _builder.append("annotation UnmarkDeprecated{ }");
    _builder.newLine();
    _builder.append("class UnmarkDeprecatedProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.deprecated = false");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.UnmarkDeprecated @Deprecated class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.UnmarkDeprecated;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@UnmarkDeprecated");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }

  @Test
  public void testAddDispatchCase() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AddDispatchCaseProcessor)");
    _builder.newLine();
    _builder.append("annotation AddDispatchCase{ }");
    _builder.newLine();
    _builder.append("class AddDispatchCaseProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addMethod(\'_m\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("visibility = Visibility.PROTECTED");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("returnType = string");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body = \'");
    _builder.append("\'\'return null;\'\'");
    _builder.append("\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddDispatchCase class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Integer i) { return null }");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import java.util.Arrays;");
    _builder_2.newLine();
    _builder_2.append("import myannotation.AddDispatchCase;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@AddDispatchCase");
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class MyClass {");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("protected String _m(final Integer i) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("return null;");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("public String m(final Object i) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("if (i instanceof Integer) {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("return _m((Integer)i);");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("} else if (i instanceof String) {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("return _m((String)i);");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("} else {");
    _builder_2.newLine();
    _builder_2.append("      ");
    _builder_2.append("throw new IllegalArgumentException(\"Unhandled parameter types: \" +");
    _builder_2.newLine();
    _builder_2.append("        ");
    _builder_2.append("Arrays.<Object>asList(i).toString());");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("protected String _m(final String foo) {");
    _builder_2.newLine();
    _builder_2.append("    ");
    _builder_2.append("return null;");
    _builder_2.newLine();
    _builder_2.append("  ");
    _builder_2.append("}");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString());
  }

  @Test
  public void testChangeDispatchHierachy() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyDeriveParticipant)");
    _builder.newLine();
    _builder.append("annotation MyDerive {}");
    _builder.newLine();
    _builder.append("class MyDeriveParticipant extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedClass.setExtendedClass(newTypeReference(Base))");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("class Base {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddDispatchCaseAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class Derived1 extends myannotation.Base {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyDerive");
    _builder_1.newLine();
    _builder_1.append("class Derived2 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyDerive");
    _builder_1.newLine();
    _builder_1.append("class Derived3 {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("class D1 {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch void m(myannotation.Base b) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("class D2 extends D1 {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived1 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived2 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def dispatch m(Derived3 d) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("package myusercode;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("import myannotation.Base;");
    _builder_2.newLine();
    _builder_2.newLine();
    _builder_2.append("@SuppressWarnings(\"all\")");
    _builder_2.newLine();
    _builder_2.append("public class Derived1 extends Base {");
    _builder_2.newLine();
    _builder_2.append("}");
    _builder_2.newLine();
    StringConcatenation _builder_3 = new StringConcatenation();
    _builder_3.append("package myusercode;");
    _builder_3.newLine();
    _builder_3.newLine();
    _builder_3.append("import myannotation.Base;");
    _builder_3.newLine();
    _builder_3.append("import myannotation.MyDerive;");
    _builder_3.newLine();
    _builder_3.newLine();
    _builder_3.append("@MyDerive");
    _builder_3.newLine();
    _builder_3.append("@SuppressWarnings(\"all\")");
    _builder_3.newLine();
    _builder_3.append("public class Derived2 extends Base {");
    _builder_3.newLine();
    _builder_3.append("}");
    _builder_3.newLine();
    StringConcatenation _builder_4 = new StringConcatenation();
    _builder_4.append("package myusercode;");
    _builder_4.newLine();
    _builder_4.newLine();
    _builder_4.append("import myannotation.Base;");
    _builder_4.newLine();
    _builder_4.append("import myannotation.MyDerive;");
    _builder_4.newLine();
    _builder_4.newLine();
    _builder_4.append("@MyDerive");
    _builder_4.newLine();
    _builder_4.append("@SuppressWarnings(\"all\")");
    _builder_4.newLine();
    _builder_4.append("public class Derived3 extends Base {");
    _builder_4.newLine();
    _builder_4.append("}");
    _builder_4.newLine();
    StringConcatenation _builder_5 = new StringConcatenation();
    _builder_5.append("package myusercode;");
    _builder_5.newLine();
    _builder_5.newLine();
    _builder_5.append("import myannotation.Base;");
    _builder_5.newLine();
    _builder_5.newLine();
    _builder_5.append("@SuppressWarnings(\"all\")");
    _builder_5.newLine();
    _builder_5.append("public class D1 {");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("protected void _m(final Base b) {");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("}");
    _builder_5.newLine();
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("public void m(final Base b) {");
    _builder_5.newLine();
    _builder_5.append("    ");
    _builder_5.append("_m(b);");
    _builder_5.newLine();
    _builder_5.append("    ");
    _builder_5.append("return;");
    _builder_5.newLine();
    _builder_5.append("  ");
    _builder_5.append("}");
    _builder_5.newLine();
    _builder_5.append("}");
    _builder_5.newLine();
    StringConcatenation _builder_6 = new StringConcatenation();
    _builder_6.append("package myusercode;");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("import java.util.Arrays;");
    _builder_6.newLine();
    _builder_6.append("import myannotation.Base;");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("@SuppressWarnings(\"all\")");
    _builder_6.newLine();
    _builder_6.append("public class D2 extends D1 {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived1 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived2 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("protected void _m(final Derived3 d) {");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("public void m(final Base d) {");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("if (d instanceof Derived1) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived1)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d instanceof Derived2) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived2)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d instanceof Derived3) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m((Derived3)d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else if (d != null) {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("_m(d);");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("return;");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("} else {");
    _builder_6.newLine();
    _builder_6.append("      ");
    _builder_6.append("throw new IllegalArgumentException(\"Unhandled parameter types: \" +");
    _builder_6.newLine();
    _builder_6.append("        ");
    _builder_6.append("Arrays.<Object>asList(d).toString());");
    _builder_6.newLine();
    _builder_6.append("    ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("  ");
    _builder_6.append("}");
    _builder_6.newLine();
    _builder_6.append("}");
    _builder_6.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_2.toString(), _builder_3.toString(), _builder_4.toString(), _builder_5.toString(), _builder_6.toString());
  }

  @Test
  public void testAddConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals(1, IterableExtensions.size(clazz.getDeclaredConstructors()));
      Assert.assertEquals("foo", IterableExtensions.head(IterableExtensions.head(clazz.getDeclaredConstructors()).getParameters()).getSimpleName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAddDefaultConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=[\'System.out.println(\"Hello World\");\']");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals(1, IterableExtensions.size(clazz.getDeclaredConstructors()));
      Assert.assertTrue(IterableExtensions.isEmpty(IterableExtensions.head(clazz.getDeclaredConstructors()).getParameters()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAddDefaultConstructorWithTemplate() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.append("System.out.println(\"Hello World\");");
    _builder.append("\'\'\'", "\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      it.getCompilationUnit();
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals(1, IterableExtensions.size(clazz.getDeclaredConstructors()));
      Assert.assertTrue(IterableExtensions.isEmpty(IterableExtensions.head(clazz.getDeclaredConstructors()).getParameters()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSwapExpressions() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> methods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = methods.get(0).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = methods.get(1).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(0).body = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(1).body = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def foo(String a) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return b");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def bar(String b) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return a");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSwapExpressions_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> fields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = fields.get(0).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = fields.get(1).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(0).initializer = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(1).initializer = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap String a = 42");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap int b = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSimpleModification() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("^abstract = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertTrue(clazz.isAbstract());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testParameterAnnotation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ParamProcessor))");
    _builder.newLine();
    _builder.append("annotation Param { }");
    _builder.newLine();
    _builder.append("class ParamProcessor implements TransformationParticipant<MutableParameterDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableParameterDeclaration> params, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("params.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("simpleName = simpleName+\'foo\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(@myannotation.Param String a, @myannotation.Param String b) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      final Function1<MutableParameterDeclaration, Boolean> _function_1 = (MutableParameterDeclaration it_1) -> {
        return Boolean.valueOf(it_1.getSimpleName().endsWith("foo"));
      };
      Assert.assertTrue(IterableExtensions.forall(IterableExtensions.head(clazz.getDeclaredMethods()).getParameters(), _function_1));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testConstantExpressionEvaluation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package annotations");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.Visibility");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Processor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String value");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Processor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(ClassDeclaration annotatedClass, extension RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("registerClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val value = annotatedClass.annotations.head.getValue(\'value\') as String");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val newClass = findClass(annotatedClass.qualifiedName+\'.\'+value)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (method : annotatedClass.declaredMethods) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.addParameter(value, newClass.newTypeReference)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("newClass.addField(value) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = string");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("visibility = Visibility.PUBLIC");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("initializer = \'");
    _builder.append("\'\'\"FOO\"\'");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("annotations/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package application");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import annotations.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation(\"FOO\") class MyClient {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def myMethod() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("FOO.FOO");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("application/MyAnnotation.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("application.MyClient.FOO");
      Assert.assertEquals("FOO", IterableExtensions.head(clazz.getDeclaredFields()).getSimpleName());
      final MutableClassDeclaration clazz2 = it.getTypeLookup().findClass("application.MyClient");
      Assert.assertEquals("FOO", IterableExtensions.head(IterableExtensions.head(clazz2.getDeclaredMethods()).getParameters()).getSimpleName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testSetDocumentation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("docComment = docComment.toCharArray.reverse.join");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* dlroW olleH");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertEquals("Hello World", clazz.getDocComment());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationDefaultValuesBug463161() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration mutableClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotationRef = mutableClass.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("mutableClass.addField(annotationRef.getExpression(\'value\')?.toString ?: \'wasNull\') [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("type = string");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int value = 1");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableFieldDeclaration field = IterableExtensions.head(clazz.getDeclaredFields());
      Assert.assertEquals("wasNull", field.getSimpleName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationDefaultValues_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach[ annotationTarget |");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotation = annotationTarget.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val strings = annotation.getStringArrayValue(\'value\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("strings.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val booleans = annotation.getBooleanArrayValue(\'booleans\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("booleans.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val types = annotation.getClassArrayValue(\'types\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val policies = annotation.getEnumArrayValue(\'policies\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("policies.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val nested = annotation.getAnnotationArrayValue(\'nested\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("nested.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("RetentionPolicy[] policies = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Active[] nested = #[]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertTrue(IterableExtensions.isEmpty(clazz.getDeclaredFields()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAnnotationDefaultValues_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import java.lang.annotation.RetentionPolicy");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AnnotationDefaultValuesProcessor)");
    _builder.newLine();
    _builder.append("annotation AnnotationDefaultValues { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AnnotationDefaultValuesProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach[ annotationTarget |");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val annotation = annotationTarget.findAnnotation(findTypeGlobally(MyAnnotation))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val strings = annotation.getStringArrayValue(\'value\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("strings.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val booleans = annotation.getBooleanArrayValue(\'booleans\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("booleans.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val types = annotation.getClassArrayValue(\'types\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val policies = annotation.getEnumArrayValue(\'policies\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("policies.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val nested = annotation.getAnnotationArrayValue(\'nested\').map[ toString ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("nested.forEach [ annotationTarget.addField(it) [ type = string ] ]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Class<?>[] types = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("RetentionPolicy[] policies = #[]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Active[] nested = #[]");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationDefaultValues.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AnnotationDefaultValues");
    _builder_1.newLine();
    _builder_1.append("@myannotation.MyAnnotation(");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("value = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("booleans = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("types = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("policies = #[],");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("nested = #[]");
    _builder_1.newLine();
    _builder_1.append(")");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertTrue(IterableExtensions.isEmpty(clazz.getDeclaredFields()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testAddAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTarget");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(AddAnnotationValueProcessor)");
    _builder.newLine();
    _builder.append("annotation AddAnnotationValue { }");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class AddAnnotationValueProcessor implements TransformationParticipant<MutableAnnotationTarget> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableAnnotationTarget> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addAnnotation(");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MyAnnotation.findTypeGlobally.newAnnotationReference [");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'value\', #[\'foo\', \'bar\', \'baz\'] as String[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleValue\', \'foo\')");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'booleans\', #[true, false, true] as boolean[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleBoolean\', true)");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'numbers\', #[1, 2, 3] as int[])");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("set(\'singleNumber\', 1)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String singleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean singleBoolean");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] numbers");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int singleNumber");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AddAnnotationValue.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddAnnotationValue");
    _builder_1.newLine();
    _builder_1.append("class MyClass {}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      final AnnotationReference annotation = clazz.findAnnotation(
        it.getTypeReferenceProvider().newTypeReference("myannotation.MyAnnotation").getType());
      Object _value = annotation.getValue("value");
      Assert.assertArrayEquals(((String[]) ((String[])Conversions.unwrapArray(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("foo", "bar", "baz")), String.class))), ((String[]) _value));
      Assert.assertEquals("foo", annotation.getValue("singleValue"));
      Object _value_1 = annotation.getValue("booleans");
      final boolean[] booleans = ((boolean[]) _value_1);
      Assert.assertTrue(booleans[2]);
      Assert.assertEquals(Boolean.valueOf(true), annotation.getValue("singleBoolean"));
      Object _value_2 = annotation.getValue("numbers");
      Assert.assertArrayEquals(new int[] { 1, 2, 3 }, ((int[]) _value_2));
      Assert.assertEquals(Integer.valueOf(1), annotation.getValue("singleNumber"));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testCreateTypeFromUsage() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.Documented");
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SomeProcessor))");
    _builder.newLine();
    _builder.append("@Documented");
    _builder.newLine();
    _builder.append("@Target(ElementType::TYPE)");
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {}");
    _builder.newLine();
    _builder.append("class SomeProcessor implements RegisterGlobalsParticipant<TypeDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends TypeDeclaration> types, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("declaredMethods.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("context.registerClass(parameterType)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private def getParameterType(MethodDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("parameters.head.type.type.qualifiedName");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/SomeAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.SomeAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void myMethod(DoesNotExist p) {}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      String _simpleName = it.getTypeLookup().findClass("myusercode.DoesNotExist").getSimpleName();
      boolean _equals = Objects.equals(_simpleName, "DoesNotExist");
      Assert.assertTrue(_equals);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMarkReadAndInitialized() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/InitAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(InitProcessor)\n\t\t\t\tannotation Init { }\n\t\t\t\tclass InitProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tval ctor = annotatedTargetFields.head.declaringType.addConstructor [\n\t\t\t\t\t\t\tprimarySourceElement = declaringType\n\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\tFOR f : annotatedTargetFields\n\t\t\t\t\t\t\t\t\tthis.f.simpleName = \"foo\";\n\t\t\t\t\t\t\t\tENDFOR\n\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t]\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tfield.setFinal(true)\n\t\t\t\t\t\t\tfield.markAsRead\n\t\t\t\t\t\t\tfield.markAsInitializedBy(ctor)\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Init String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      MutableClassDeclaration _findClass = it.getTypeLookup().findClass("myusercode.MyClass");
      final JvmGenericType clazz = ((MutableJvmClassDeclarationImpl) _findClass).getDelegate();
      this.validator.assertNoIssues(clazz);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMarkReadAndInitialized2() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/InitAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(InitProcessor)\n\t\t\t\tannotation Init { }\n\t\t\t\tclass InitProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tval ctor = annotatedTargetFields.head.declaringType.addConstructor [\n\t\t\t\t\t\t\tprimarySourceElement = declaringType\n\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\tFOR f : annotatedTargetFields\n\t\t\t\t\t\t\t\t\tthis.f.simpleName = \"foo\";\n\t\t\t\t\t\t\t\tENDFOR\n\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t]\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tfield.setFinal(true)\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Init String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Function1<Resource.Diagnostic, Boolean> _function_1 = (Resource.Diagnostic it_1) -> {
        return Boolean.valueOf(it_1.getMessage().contains("myField may not have been initialized"));
      };
      IterableExtensions.<Resource.Diagnostic>exists(it.getXtendFile().eResource().getErrors(), _function_1);
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testPropertyAnnotation() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/PropertyAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(typeof(PropertyProcessor))\n\t\t\t\tannotation Property2 { }\n\t\t\t\tclass PropertyProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tval declaringType = field.declaringType \n\t\t\t\t\t\t\tdeclaringType.addMethod(field.getterName) [\n\t\t\t\t\t\t\t\treturnType = field.type\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\treturn this.field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\tdeclaringType.addMethod(\'set\'+field.simpleName.toFirstUpper) [\n\t\t\t\t\t\t\t\taddParameter(field.simpleName, field.type)\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\tthis.field.simpleName = field.simpleName;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdef private String getterName(MutableFieldDeclaration field) {\n\t\t\t\t\t\treturn \'get\'+field.simpleName.toFirstUpper\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Property2 String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableMethodDeclaration getter = IterableExtensions.head(clazz.getDeclaredMethods());
      Assert.assertEquals("getMyField", getter.getSimpleName());
      Assert.assertEquals("String", getter.getReturnType().toString());
      final MutableMethodDeclaration setter = clazz.findDeclaredMethod("setMyField", getter.getReturnType());
      Assert.assertEquals("setMyField", setter.getSimpleName());
      Assert.assertEquals("void", setter.getReturnType().toString());
      Assert.assertEquals("myField", IterableExtensions.head(setter.getParameters()).getSimpleName());
      Assert.assertEquals("String", IterableExtensions.head(setter.getParameters()).getType().toString());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testThrowsAndTypeParam() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ThrowsAndTypeParamProcessor))");
    _builder.newLine();
    _builder.append("annotation ThrowsAndTypeParam { }");
    _builder.newLine();
    _builder.append("class ThrowsAndTypeParamProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val type = addTypeParameter(\'A\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\'myParam\', newTypeReference(type))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setExceptions(newTypeReference(\'java.lang.Exception\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.ThrowsAndTypeParam");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(){");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration type = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableMethodDeclaration method = IterableExtensions.head(type.getDeclaredMethods());
      Assert.assertEquals("A", IterableExtensions.head(method.getTypeParameters()).getSimpleName());
      Assert.assertEquals("myParam", IterableExtensions.head(method.getParameters()).getSimpleName());
      Assert.assertSame(IterableExtensions.head(method.getTypeParameters()), IterableExtensions.head(method.getParameters()).getType().getType());
      Assert.assertEquals(1, IterableExtensions.size(method.getExceptions()));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMovingComputedTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Field2MethodProcessor)");
    _builder.newLine();
    _builder.append("annotation Field2Method { }");
    _builder.newLine();
    _builder.append("class Field2MethodProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> annotatedFields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedFields.forEach [ field |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("field.declaringType.addMethod(field.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("returnType = field.type");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("body = field.initializer");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("field.remove");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val foo = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Field2Method");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val x = foo");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Field2Method");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val y = x");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration type = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableMethodDeclaration method = ((MutableMethodDeclaration[])Conversions.unwrapArray(type.getDeclaredMethods(), MutableMethodDeclaration.class))[1];
      Assert.assertEquals("java.lang.String", method.getReturnType().getName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMovingComputedTypes_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(Method2FieldProcessor)");
    _builder.newLine();
    _builder.append("annotation Method2Field { }");
    _builder.newLine();
    _builder.append("class Method2FieldProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ method |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.declaringType.addField(method.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("type = method.returnType");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("initializer = method.body");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("method.remove");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("val foo = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Method2Field");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def x() { foo }");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Method2Field");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def y() { x }");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration type = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableFieldDeclaration field = ((MutableFieldDeclaration[])Conversions.unwrapArray(type.getDeclaredFields(), MutableFieldDeclaration.class))[1];
      Assert.assertEquals("java.lang.String", field.getType().getName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testValidation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ValidatedProcessor))");
    _builder.newLine();
    _builder.append("annotation Validated { }");
    _builder.newLine();
    _builder.append("class ValidatedProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch ele {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MutableFieldDeclaration : ele.addWarning(\'field-warning\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default : ele.addWarning(\'warning\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String name");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration type = it.getTypeLookup().findClass("myusercode.MyClass");
      final MutableMethodDeclaration method = IterableExtensions.head(type.getDeclaredMethods());
      final MutableFieldDeclaration field = IterableExtensions.head(type.getDeclaredFields());
      Assert.assertEquals("field-warning", IterableExtensions.head(it.getProblemSupport().getProblems(field)).getMessage());
      Assert.assertEquals("warning", IterableExtensions.head(it.getProblemSupport().getProblems(method)).getMessage());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testIntroduceNewTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\".InnerClass\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerInterface(clazz.qualifiedName+\"Interface\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerEnumerationType(clazz.qualifiedName+\"Enum\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerAnnotationType(clazz.qualifiedName+\"Annotation\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      Assert.assertNotNull(it.getTypeLookup().findClass("myusercode.MyClass"));
      Assert.assertNotNull(it.getTypeLookup().findClass("myusercode.MyClass.InnerClass"));
      Assert.assertNotNull(it.getTypeLookup().findInterface("myusercode.MyClassInterface"));
      Assert.assertNotNull(it.getTypeLookup().findEnumerationType("myusercode.MyClassEnum"));
      Assert.assertNotNull(it.getTypeLookup().findAnnotationType("myusercode.MyClassAnnotation"));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testImportFromTypeReference_01() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationImportFromTypeReference.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.text.DateFormat\n\t\t\t\timport java.text.SimpleDateFormat\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\t\n\t\t\t\t@Active(AnnotationImportFromTypeReferenceProcessor)\n\t\t\t\tannotation AnnotationImportFromTypeReference { }\n\t\t\t\tclass AnnotationImportFromTypeReferenceProcessor extends AbstractClassProcessor {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedClass.addField(\'myDateFormat\') [\n\t\t\t\t\t\t\ttype = DateFormat.newTypeReference\n\t\t\t\t\t\t\tinitializer = \'\'\'new SimpleDateFormat.newTypeReference()\'\'\'\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.AnnotationImportFromTypeReference");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import java.text.DateFormat;");
    _builder_1.newLine();
    _builder_1.append("import java.text.SimpleDateFormat;");
    _builder_1.newLine();
    _builder_1.append("import myannotation.AnnotationImportFromTypeReference;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@AnnotationImportFromTypeReference");
    _builder_1.newLine();
    _builder_1.append("@SuppressWarnings(\"all\")");
    _builder_1.newLine();
    _builder_1.append("public class MyClass {");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private DateFormat myDateFormat = new SimpleDateFormat();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_1.toString());
  }

  @Test
  public void testImportFromTypeReference_02() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AnnotationImportFromTypeReference.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\t\n\t\t\t\t@Active(AnnotationImportFromTypeReferenceProcessor)\n\t\t\t\tannotation AnnotationImportFromTypeReference { }\n\t\t\t\tclass AnnotationImportFromTypeReferenceProcessor extends AbstractClassProcessor {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedClass.declaredFields.forEach [\n\t\t\t\t\t\t\tinitializer = \'\'\'new type.type()\'\'\'\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.Timer");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.AnnotationImportFromTypeReference");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Timer t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("MyClass child");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import java.util.Timer;");
    _builder_1.newLine();
    _builder_1.append("import myannotation.AnnotationImportFromTypeReference;");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@AnnotationImportFromTypeReference");
    _builder_1.newLine();
    _builder_1.append("@SuppressWarnings(\"all\")");
    _builder_1.newLine();
    _builder_1.append("public class MyClass {");
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private Timer t = new Timer();");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("  ");
    _builder_1.append("private MyClass child = new MyClass();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    this.assertGeneratedCode(_mappedTo, _mappedTo_1, _builder_1.toString());
  }

  @Test
  public void testIntroduceNewTypeAndWorkWithIt() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration>, TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("classes.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val cl = context.findClass(ele.qualifiedName+\"Derived\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("cl.extendedClass = newTypeReference(ele)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration declaredClass = it.getTypeLookup().findClass("myusercode.MyClass");
      Assert.assertNotNull(declaredClass);
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.MyClassDerived");
      Assert.assertNotNull(clazz);
      Assert.assertEquals(declaredClass.getQualifiedName(), clazz.getExtendedClass().getType().getQualifiedName());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  private final Pair<String, String> THREE_ANNOTATIONS = new Function0<Pair<String, String>>() {
    @Override
    public Pair<String, String> apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package myannotation");
      _builder.newLine();
      _builder.newLine();
      _builder.append("import java.util.List");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.Active");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Aprocessor))");
      _builder.newLine();
      _builder.append("annotation _A {}");
      _builder.newLine();
      _builder.append("class Aprocessor implements TransformationParticipant<MutableNamedElement> {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements, extension TransformationContext context) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("annotatedTargetElements.forEach[");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("simpleName = simpleName + num()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def num() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\'_A\'");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("@Active(typeof(Bprocessor))");
      _builder.newLine();
      _builder.append("annotation _B {}");
      _builder.newLine();
      _builder.append("class Bprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_B\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Cprocessor))");
      _builder.newLine();
      _builder.append("annotation _C {}");
      _builder.newLine();
      _builder.append("class Cprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_C\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/three.xtend", _builder.toString());
      return _mappedTo;
    }
  }.apply();

  @Test
  public void testDeterministicExecutionOrder_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration myClass = it.getTypeLookup().findClass("MyClass");
      Assert.assertEquals("field_A_B_C", IterableExtensions.head(myClass.getDeclaredFields()).getSimpleName());
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }

  @Test
  public void testDeterministicExecutionOrder_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import myannotation.*");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_C @_B @_A String field2");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration myClass = it.getTypeLookup().findClass("MyClass");
      Assert.assertEquals("field1_A_B_C", IterableExtensions.head(myClass.getDeclaredFields()).getSimpleName());
      Assert.assertEquals("field2_A_B_C", (((MutableFieldDeclaration[])Conversions.unwrapArray(myClass.getDeclaredFields(), MutableFieldDeclaration.class))[1]).getSimpleName());
    };
    this.assertProcessing(
      this.THREE_ANNOTATIONS, _mappedTo, _function);
  }

  public abstract void assertProcessing(final Pair<String, String> macroFile, final Pair<String, String> clientFile, final Procedure1<? super CompilationUnitImpl> expectations);

  public void assertGeneratedCode(final Pair<String, String> macroFile, final Pair<String, String> clientFile, final String... compiledClientFiles) {
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final Function1<String, String> _function_1 = (String it_1) -> {
        return LineDelimiters.toUnix(it_1);
      };
      final Set<String> clientFilesAsSet = IterableExtensions.<String>toSet(ListExtensions.<String, String>map(((List<String>)Conversions.doWrapArray(compiledClientFiles)), _function_1));
      Assert.assertEquals(clientFilesAsSet.size(), compiledClientFiles.length);
      final Resource resource = it.getXtendFile().eResource();
      final Iterable<EObject> jvmTypes = IterableExtensions.<EObject>tail(resource.getContents());
      final Consumer<EObject> _function_2 = (EObject it_1) -> {
        if ((it_1 instanceof JvmDeclaredType)) {
          final String generated = String.valueOf(this.generator.generateType(((JvmDeclaredType)it_1), this.generatorConfigProvider.get(it_1)));
          boolean _remove = clientFilesAsSet.remove(generated);
          boolean _not = (!_remove);
          if (_not) {
            String _join = IterableExtensions.join(clientFilesAsSet, "\n");
            String _plus = ((("Unexpected compiled code:\n" + generated) + "\nExpected :\n") + _join);
            Assert.assertEquals("", _plus);
          }
        } else {
          String _valueOf = String.valueOf(it_1);
          throw new IllegalArgumentException(_valueOf);
        }
      };
      jvmTypes.forEach(_function_2);
      boolean _isEmpty = clientFilesAsSet.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        String _join = IterableExtensions.join(clientFilesAsSet, "\n");
        String _plus = ("Missing compiled code. Expected :\n" + _join);
        Assert.fail(_plus);
      }
    };
    this.assertProcessing(macroFile, clientFile, _function);
  }

  @Test
  public void testFileSystemSupport_01() {
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/FileSystemSupportTest.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.ClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.AbstractClassProcessor\n\t\t\t\t\n\t\t\t\t@Active(FileSystemUsingProcessor)\n\t\t\t\tannotation FileSystemSupportTest { }\n\t\t\t\t\n\t\t\t\tclass FileSystemUsingProcessor extends AbstractClassProcessor {\n\t\n\t\t\t\t\toverride doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {\n\t\t\t\t\t\tval path = annotatedClass.compilationUnit.filePath\n\t\t\t\t\t\tannotatedClass.docComment = \'\'\'\n\t\t\t\t\t\t\tPath \'path.toString\' {\n\t\t\t\t\t\t\t\texists: path.exists\n\t\t\t\t\t\t\t\tisFolder: path.isFolder\n\t\t\t\t\t\t\t\tisFile: path.isFile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceFolder : path.sourceFolder\n\t\t\t\t\t\t\ttargetFolder : path.targetFolder\n\t\t\t\t\t\t\tprojectFolder: path.projectFolder\n\t\t\t\t\t\t\'\'\'\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@myannotation.FileSystemSupportTest");
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration declaredClass = it.getTypeLookup().findClass("myusercode.MyClass");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Path \'/userProject/src/myusercode/UserCode.xtend\' {");
      _builder_1.newLine();
      _builder_1.append("\t");
      _builder_1.append("exists: true");
      _builder_1.newLine();
      _builder_1.append("\t");
      _builder_1.append("isFolder: false");
      _builder_1.newLine();
      _builder_1.append("\t");
      _builder_1.append("isFile: true");
      _builder_1.newLine();
      _builder_1.append("}");
      _builder_1.newLine();
      _builder_1.append("sourceFolder : /userProject/src");
      _builder_1.newLine();
      _builder_1.append("targetFolder : /userProject/xtend-gen");
      _builder_1.newLine();
      _builder_1.append("projectFolder: /userProject");
      _builder_1.newLine();
      Assert.assertEquals(_builder_1.toString(), declaredClass.getDocComment());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testRemove() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import com.google.common.base.Preconditions");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableTypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(MyAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyAnnotationProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements,");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (annotatedTargetElement : annotatedTargetElements) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("remove(annotatedTargetElement, context)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def dispatch void remove(MutableNamedElement annotatedTargetElement, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val sourceElement = annotatedTargetElement.primarySourceElement");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement != null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a source element should not be null before removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement.primaryGeneratedJavaElement == annotatedTargetElement,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'expected: ");
    _builder.append("", "\t\t\t");
    _builder.append("annotatedTargetElement");
    _builder.append("", "\t\t\t");
    _builder.append(", but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement.primaryGeneratedJavaElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(annotatedTargetElement.primarySourceElement == null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a source element should be null after removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("annotatedTargetElement.primarySourceElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("Preconditions.checkState(sourceElement.primaryGeneratedJavaElement == null,");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'a target element should be null after removing, but: ");
    _builder.append("", "\t\t\t");
    _builder.append("sourceElement.primaryGeneratedJavaElement");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(false, \'");
    _builder.append("\'\'");
    _builder.append("", "\t\t\t");
    _builder.append("IllegalArgumentException");
    _builder.append("", "\t\t\t");
    _builder.append(" is expected\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("} catch (IllegalStateException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(e.message.startsWith(\"This element has already been removed: \"),");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("\'");
    _builder.append("\'\'Wrong error message: ");
    _builder.append("", "\t\t\t\t");
    _builder.append("e.message");
    _builder.append("", "\t\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def dispatch void remove(MutableTypeDeclaration annotatedTargetElement, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("annotatedTargetElement.remove");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(false, \'");
    _builder.append("\'\'");
    _builder.append("", "\t\t\t");
    _builder.append("UnsupportedOperationException");
    _builder.append("", "\t\t\t");
    _builder.append(" is expected\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("} catch (UnsupportedOperationException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Preconditions.checkState(e.message == \"The type cannot be removed.\", \'\'");
    _builder.append("\'Wrong error message: ");
    _builder.append("", "\t\t\t");
    _builder.append("e.message");
    _builder.append("", "\t\t\t");
    _builder.append("\'");
    _builder.append("\'\')");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/MyAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("import myannotation.MyAnnotation");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("class UserClass {");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String fieldToRemove");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new(String arg) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("new(@MyAnnotation Integer argToRemove) {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def methodToRemove() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static class NestedClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static interface NestedInteface {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static annotation NestedAnnotation {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("static enum NestedEnum {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("enum UserEnum {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("interface UserInterface {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def String methodToRemove();");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("annotation UserAnnotation {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@MyAnnotation");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String fieldToRemove");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      final MutableClassDeclaration clazz = it.getTypeLookup().findClass("myusercode.UserClass");
      Assert.assertNotNull(clazz);
      Assert.assertEquals(5, IterableExtensions.size(clazz.getDeclaredMembers()));
      final MutableConstructorDeclaration constructor = IterableExtensions.head(clazz.getDeclaredConstructors());
      Assert.assertNotNull(clazz);
      Assert.assertEquals(0, IterableExtensions.size(constructor.getParameters()));
      Assert.assertEquals(1, IterableExtensions.size(Iterables.<ClassDeclaration>filter(clazz.getDeclaredMembers(), ClassDeclaration.class)));
      Assert.assertEquals(1, IterableExtensions.size(Iterables.<InterfaceDeclaration>filter(clazz.getDeclaredMembers(), InterfaceDeclaration.class)));
      Assert.assertEquals(1, IterableExtensions.size(Iterables.<EnumerationTypeDeclaration>filter(clazz.getDeclaredMembers(), EnumerationTypeDeclaration.class)));
      Assert.assertEquals(1, IterableExtensions.size(Iterables.<AnnotationTypeDeclaration>filter(clazz.getDeclaredMembers(), AnnotationTypeDeclaration.class)));
      final MutableEnumerationTypeDeclaration enum_ = it.getTypeLookup().findEnumerationType("myusercode.UserEnum");
      Assert.assertNotNull(enum_);
      final MutableInterfaceDeclaration interface_ = it.getTypeLookup().findInterface("myusercode.UserInterface");
      Assert.assertNotNull(interface_);
      Assert.assertEquals(0, IterableExtensions.size(interface_.getDeclaredMembers()));
      final MutableAnnotationTypeDeclaration annotation = it.getTypeLookup().findAnnotationType("myusercode.UserAnnotation");
      Assert.assertNotNull(annotation);
      Assert.assertEquals(0, IterableExtensions.size(annotation.getDeclaredMembers()));
      Element _primarySourceElement = it.getTracability().getPrimarySourceElement(clazz);
      final MethodDeclaration removedMethod = ((ClassDeclaration) _primarySourceElement).findDeclaredMethod("methodToRemove");
      Expression _body = removedMethod.getBody();
      final XExpression expression = ((ExpressionImpl) _body).getDelegate();
      Assert.assertNull(this.logicalContainerProvider.getLogicalContainer(expression));
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  @Test
  public void testMoveExpressionToTypeParameterDeclarator() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Target(ElementType.TYPE)");
    _builder.newLine();
    _builder.append("@Active(SomeAnnotationProcessor)");
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class SomeAnnotationProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("static def copyMethod(MutableClassDeclaration clazz, MethodDeclaration method, extension TransformationContext context) {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val methodDeclaration = clazz.addMethod(method.simpleName) [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.abstract = method.abstract");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.docComment = method.docComment");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.visibility = method.visibility");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.synchronized = method.synchronized");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.deprecated = method.deprecated");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.static = method.static");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.exceptions = method.exceptions");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.varArgs = method.varArgs");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("it.strictFloatingPoint = method.strictFloatingPoint");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (t : method.typeParameters) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val result = methodDeclaration.addTypeParameter(t.simpleName, t.upperBounds)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("result.primarySourceElement = t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methodDeclaration.returnType = method.returnType");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (p : method.parameters) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("methodDeclaration.addParameter(p.simpleName, p.type)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return methodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (m : annotatedClass.declaredMethods) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val newMethod = annotatedClass.copyMethod(m, context)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("newMethod.simpleName = newMethod.simpleName + \"_copiedMethod\"");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("newMethod.body = m.body");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("m.body = \'\'");
    _builder.append("\'// new method\'\'");
    _builder.append("\'");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String, String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.SomeAnnotation");
    _builder_1.newLine();
    _builder_1.append("class SomeAnnotationTest {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def <T> void myMethod() {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("var T myObj = null;");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String, String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = (CompilationUnitImpl it) -> {
      this.validator.assertNoErrors(it.getXtendFile());
    };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }

  public void assertSameType(final TypeReference first, final TypeReference second) {
    boolean _notEquals = (!Objects.equals(first, second));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(first);
      _builder.append(" does not refer to the same type as ");
      _builder.append(second);
      Assert.fail(_builder.toString());
    }
  }
}
