/*******************************************************************************
* Copyright (c) 2008 itemis AG and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
language org.eclipse.xtext.Xtext

generate xtext "http://www.eclipse.org/2008/Xtext"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Grammar :
    (abstract?='abstract language' | 'language') idElements+=ID ('.' idElements+=ID)* ('extends' superGrammarIdElements+=ID ('.' superGrammarIdElements+=ID)*)?
	metamodelDeclarations+=AbstractMetamodelDeclaration* 
    (rules+=AbstractRule)+
;

AbstractRule : LexerRule | ParserRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;
	
// constraint: typeSelect(GeneratedMetamodel).size() == typeSelect(GeneratedMetamodel).alias.size()
// generated metamodels have to have different aliases
GeneratedMetamodel :
	'generate' name=ID ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

// referenced metamodels may share aliases with other referenced metamodels
// and with generated metamodels
ReferencedMetamodel :
	'import' ePackage=[ecore::EPackage|STRING] ('as' alias=ID)?;

LexerRule :
	('native'|'lexer') name=ID ('returns' type=TypeRef)? ':' 
		body=STRING ';'
;

ParserRule :
    name=ID ('returns' type=TypeRef)? ':' 
    	alternatives=Alternatives   
    ';'
;

TypeRef :
	(metamodel=[AbstractMetamodelDeclaration] '::')? type=[EClassifier]
;

Alternatives returns AbstractElement:
    Group ({Alternatives.groups+=current} '|' groups+=Group)*
;

Group returns AbstractElement:
    AbstractToken ( {current=Group.abstractTokens+=current} abstractTokens+=AbstractToken)*
;

AbstractToken returns AbstractElement:
	(Assignment | 
	 Action |
	 AbstractTerminal) (cardinality=('?'|'*'|'+'))?;

Assignment returns Assignment:
   feature=ID operator=('+='|'='|'?=') terminal=AbstractTerminal;

Action returns Action:
	'{' ('current' '=')? typeName=TypeRef '.' feature=ID operator=('='|'+=') 'current' '}';//TODO make assignment optional

AbstractTerminal returns AbstractElement: 
   Keyword | RuleCall | ParenthesizedElement | CrossReference
;

CrossReference :
	'[' type=TypeRef ('|' rule=[AbstractRule])? ']'
;

ParenthesizedElement returns AbstractElement:
   '(' Alternatives ')'
;

Keyword : 
   value=STRING 
;

RuleCall :
   rule=[AbstractRule];
