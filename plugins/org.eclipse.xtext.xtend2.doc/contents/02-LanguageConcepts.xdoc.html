<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Language Concepts</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="LanguageConcepts"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Language Concepts</h1>

<p>
On a first glance an Xtend2 file pretty much looks like a Java file. it starts with a package declaration followed by an import section, and after that comes the class definition.
That class in fact is directly translated to a Java class in the corresponding Java package.
Here is an example:

<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;com.acme<br /><br />import&nbsp;java.util.List<br /><br />class&nbsp;MyClass&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;first(List&lt;String&gt;&nbsp;elements)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>


<a name="packageDecl"></a>

<a name="packageDecl"></a>
<div class="section" title="Package Declaration">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Package Declaration
</h2>
</div>
</div>
</div>



<p>
Package declarations are like in Java, with the small difference, that an identifier can be escaped with a  <em>^</em> in case it conflicts with a keyword.
Also you don&apos;t terminate a package decalaration with a semicolon.
</p>




<a name="packageDecl-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
PackageDeclaration&nbsp;:&nbsp;&apos;package&apos;&nbsp;QualifiedName;<br />QualifiedName&nbsp;:&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID);<br />
</p>
</div>
</div>


</p>


</div>



<a name="packageDecl-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;org.eclipse.xtext<br />
</p>
</div>
</div>



<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;my.^public.^package<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="imports"></a>

<a name="imports"></a>
<div class="section" title="Imports">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Imports
</h2>
</div>
</div>
</div>



<p>
The ordinary imports of type names are equivalent to the imports known from Java. 
Again one can escape any names conflicting with keywords using the <em>^</em> and the import statemet is never
terminated with a semicolon.
</p>


<a name="importExtension"></a>

<a name="importExtension"></a>
<div class="section" title="Importing Extension Methods">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Importing Extension Methods
</h3>
</div>
</div>
</div>



<p>
In addition one can add the keyword <span class="inlinecode">extension</span>
 after the import (where the keyword <span class="inlinecode">static</span>
 occurs in Java), which makes any static methods 
from a certain type available as an 
<a href="02-LanguageConcepts.xdoc.html#extensionMethods">extension method</a>. The <span class="inlinecode">extension</span>
 keyword only works with qualified imports (i.e. non-wildcard imports).
If you only want to make some methods from the imported type available using the extension syntax, you can provide a list of function names.
You cannot further specify type arguments.
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
import&nbsp;extension&nbsp;java.util.Collections.(sort,&nbsp;shuffle);<br />
</p>
</div>
</div>


</p>

<p>
This will import four methods (<span class="inlinecode">sort(List&lt;T&gt;)</span>
, <span class="inlinecode">sort(List&lt;T&gt;,&nbsp;Comparator&lt;?&nbsp;super&nbsp;T&gt;)</span>
, <span class="inlinecode">shuffle(List&lt;?&gt;)</span>
, <span class="inlinecode">shuffle(List&lt;?&gt;,&nbsp;Random)</span>
) available as 
<a href="02-LanguageConcepts.xdoc.html#extensionMethods">extension methods</a>.
</p>


</div>



<a name="imports-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
ImportSection&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(Import|Injection)*;<br />Import&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;import&apos;&nbsp;&apos;extension&apos;?&nbsp;QualifiedName&nbsp;((&apos;.&apos;&apos;*&apos;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&apos;(&apos;ID&nbsp;(&apos;,&apos;&nbsp;ID)&apos;)&apos;)?;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="inject"></a>

<a name="inject"></a>
<div class="section" title="Dependency Injection">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Dependency Injection
</h2>
</div>
</div>
</div>



<p>
Xtend2 has built-in support for dependency injection, which means that declaring dependencies is a first class feature of Xtend2.
It is done as part of the import section and looks like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;MyService&nbsp;myService;<br />
</p>
</div>
</div>


</p>

<p>
This will translate to Java as a field as well a setter method annotated with @Inject: 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">private</span>&nbsp;MyService&nbsp;myService;<br /><br />@Inject<br /><span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;setMyService(MyService&nbsp;myService)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.myService&nbsp;=&nbsp;myService;<br />}<br />
</p>
</div>
</div>


</p>




<a name="inject-5"></a>
<div class="section" title="Name can be inferred">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Name can be inferred
</h3>
</div>
</div>
</div>



<p>
You could even leave the name out as by default it will be the lower case version of the simple name of the class.
That is the following inject declaration would be equvalent with the former.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;MyService;<br />
</p>
</div>
</div>


</p>


</div>



<a name="inject-6"></a>
<div class="section" title="Guice Keys">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Guice Keys
</h3>
</div>
</div>
</div>



<p>
Xtend2 uses Guice as the dependency injection container, which in turn uses types as keys. Those types can be generified, which
is why you can write the following in Xtend2.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;HashMap&lt;String,MyType&gt;&nbsp;myCache;<br />
</p>
</div>
</div>


</p>

<p>
Also Guice allows to use annotations to further distinct between different implementations of the same type. This is usually done by using
the <span class="inlinecode">com.google.inject.name.Named</span>
 annotation or a custom annotation which is itself annotated with <span class="inlinecode">com.google.inject.BindingAnnotation</span>
.
</p>

<p>
Xtend supports these two variants:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;@CustomAnnotation&nbsp;my.Service&nbsp;customService;&nbsp;<br />inject&nbsp;@"NamedThingy"&nbsp;my.Service&nbsp;namedService;<br />
</p>
</div>
</div>


</p>

<p>
Providers are declared like in plain Guice. That is you wrap your type into <span class="inlinecode">com.google.inject.Provider</span>
.
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;@CustomAnnotation&nbsp;Provider&lt;Service&gt;&nbsp;customServiceProvider;&nbsp;<br />
</p>
</div>
</div>


</p>


</div>



<a name="inject-7"></a>
<div class="section" title="Injected Extension Methods">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Injected Extension Methods
</h3>
</div>
</div>
</div>



<p>
The <span class="inlinecode">extension</span>
 keyword is also available for <span class="inlinecode">inject</span>
 which is much nicer than importing static methods, because you don&apos;t bind your code to 
actual implementation, since the implementation can be easily changed through the global dependency injection configuration (i.e. Guice modules).
</p>

<p>
Example:
</p>

<p>
Imagine you had something like IterableExtensions which adds some higher-order functions
to the java.util collection library (we will likely ship a library based on google guava).
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;IterableExtensions&nbsp;{<br />&nbsp;&nbsp;&nbsp;public&nbsp;&lt;T&gt;&nbsp;T&nbsp;find(Iterable&lt;T&gt;&nbsp;elements,&nbsp;Function&lt;T,Boolean&gt;&nbsp;func)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
You declare the dependency like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;extension&nbsp;my.common.IterableExtensions;<br />
</p>
</div>
</div>


</p>

<p>
and can then use it as if those functions were members of any <span class="inlinecode">java.lang.Iterable</span>
:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myIterable.find(e|e.name=="Foo")<br />
</p>
</div>
</div>


</p>

<p>
The nice thing with using injection as opposed to static methods is, that in case there is a bug in the extension or it is implemented inefficiently or you 
just need a different strategy, you can simply exchange the component with another implementation. You do this without modifying the library nor the client code. 
You&apos;ll only have to change the binding in your guice module. Also this gives you a general hook for any AOP-like thing you would want to do, 
or allows you to write against an SPI, where the concrete implementation can be provided by a third party.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
ImportSection&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(Import|Injection)*;<br />Import&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />Injection&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;inject&apos;&nbsp;&apos;extension&apos;?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;@&apos;STRING&nbsp;|&nbsp;&apos;@&apos;TypeReference)?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;TypeReference&nbsp;(&apos;(&apos;ID&nbsp;(&apos;,&apos;&nbsp;ID)*&apos;)&apos;)?;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="classDeclaration"></a>

<a name="classDeclaration"></a>
<div class="section" title="Class Declaration">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Class Declaration
</h2>
</div>
</div>
</div>



<p>
The class declaration reuses a lot of Java&apos;s syntax but still is a bit different in some aspects.
Firstly the default visibility of any class is <span class="inlinecode">public</span>
. It is possible to write it explicitly but if not specified it defaults to public.
Java&apos;s default "package private" visibility does not exist.
</p>

<p>
The <span class="inlinecode">abstract</span>
 as well as the <span class="inlinecode">final</span>
 modifiers are directly translated to Java, hence have the exact same meaning.
</p>




<a name="classDeclaration-3"></a>
<div class="section" title="Inheritance">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Inheritance
</h3>
</div>
</div>
</div>



<p>
Also inheritance is directly reused from Java. Xtend2 allows single inheritance of Java classes as well as implementing multiple Java interfaces.
</p>


</div>



<a name="classDeclaration-4"></a>
<div class="section" title="Generics">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Generics
</h3>
</div>
</div>
</div>



<p>
Full Java Generics with the exact same syntax and semantics are supported.
</p>


</div>



<a name="classDeclaration-5"></a>
<div class="section" title="Abstract Classes">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Abstract Classes
</h3>
</div>
</div>
</div>



<p>
A class is automatically <span class="inlinecode">abstract</span>
 if one of its functions is abstract. 
This is the case if the function&apos;s expression (body) is not defined. 
</p>


</div>



<a name="classDeclaration-6"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
ClassDeclaration&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(Visibility|&apos;abstract&apos;|&apos;final&apos;)*&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;class&apos;&nbsp;TypeParameters?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;extends&apos;&nbsp;QualifiedName)?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;implements&apos;&nbsp;QualifiedName&nbsp;(&apos;,&apos;&nbsp;QualifiedName)*)?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Members*<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;}&apos;<br />;<br />Visibility&nbsp;:&nbsp;&apos;public&apos;|&apos;protected&apos;|&apos;private&apos;;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="Functions"></a>

<a name="Functions"></a>
<div class="section" title="Functions">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Functions
</h2>
</div>
</div>
</div>



<p>
Xtend2 functions are declared within a class and are usually translated to a corresponding Java method with the exact same signature. 
The only exception is case methods, which compile to a single method. This is explained in the section about 
<a href="02-LanguageConcepts.xdoc.html#polymorphicDispatch">section polymorphicDispatch</a>. 
</p>

<p>
An example of a function declaration

<div class="literallayout">
<div class="incode">
<p class="code">
Boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br />
</p>
</div>
</div>


</p>




<a name="Functions-3"></a>
<div class="section" title="Visibility">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Visibility
</h3>
</div>
</div>
</div>



<p>
The default visibility of a function is <span class="inlinecode">public</span>
, which can also be declared explicitly. 
The two other available visibilities are <span class="inlinecode">protected</span>
 and <span class="inlinecode">private</span>
.
</p>


</div>



<a name="Functions-4"></a>
<div class="section" title="Overriding Functions">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Overriding Functions
</h3>
</div>
</div>
</div>



<p>
Like Java methods an Xtend2 function can be declared non overridable using the keyword <span class="inlinecode">final</span>
.
</p>

<p>
Also if a function overrides a method from the super class, the <span class="inlinecode">override</span>
 keyword is mandatory.
</p>

<p>
Example:

<div class="literallayout">
<div class="incode">
<p class="code">
final&nbsp;override&nbsp;Boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br />
</p>
</div>
</div>


</p>


</div>



<a name="Functions-5"></a>
<div class="section" title="Abstract Functions">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Abstract Functions
</h3>
</div>
</div>
</div>



<p>
A function is automatically considered <span class="inlinecode">abstract</span>
 if its expression (body) is not defined.
</p>

<p>
Example:

<div class="literallayout">
<div class="incode">
<p class="code">
Boolean&nbsp;myAbstractFunction(String&nbsp;s1,String&nbsp;s2);<br />
</p>
</div>
</div>


</p>

<p>
In such cases the class needs to be flagged <span class="inlinecode">abstract</span>
 otherwise the compiler will complain.
</p>


</div>

<a name="inferredReturnTypes"></a>

<a name="inferredReturnTypes"></a>
<div class="section" title="Inferred Return Types">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Inferred Return Types
</h3>
</div>
</div>
</div>



<p>
If the return type of a function can be inferred it does not need to be declared.
That is the function
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br />
</p>
</div>
</div>


</p>

<p>
could be declared like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br />
</p>
</div>
</div>


</p>

<p>
This doesn&apos;t work for abstract function declarations as well as if the 
return type of a function depends on a recursive call of the same function.
The compiler tells the user when it needs to be specified.
</p>


</div>



<a name="Functions-7"></a>
<div class="section" title="Generics">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Generics
</h3>
</div>
</div>
</div>



<p>
Full Java Generics with the exact same syntax and semantics are supported.
Raw types, i.e. parameterized types without type parameters are treated as if each type parameter were
a wild card.
</p>

<p>
That is <span class="inlinecode">List</span>
 is the same as  <span class="inlinecode">List&lt;?&gt;</span>

</p>


</div>

<a name="polymorphicDispatch"></a>

<a name="polymorphicDispatch"></a>
<div class="section" title="Polymorphic Method Overloading">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Polymorphic Method Overloading
</h3>
</div>
</div>
</div>



<p>
It is possible to overload methods like in Java, and the resolution is also like in Java based on the
static type of the arguments and only dynamic polymorphic on the receiver.
However Xtend2 supports the special notion of case methods, which makes such overloaded methods polymorphic
dispatched.
</p>

<p>
Such methods get the keyword <span class="inlinecode">case</span>
 and all methods with the same name and the same number of arguments
need either be marked with <span class="inlinecode">case</span>
 or not.
</p>

<p>
If they are marked as case methods, the compiler will infer one method with the most common argument
types which contains an if else cascade dispatching between the different case methods based on the actual
runtime types of the arguments. This has a lot of advantages and is a very convenient way 
to add functionality to heterogenous data structures especially with deeper type hierarchies (i.e. EMF models and other typed domain models).
It essentially eleminates the problem the visitor pattern is trying to solve.
</p>

<p>
This allows you to write a code generator by defining a function for all kinds of AST elements you want to process.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;MyCompiler&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;compile(CompilationUnit&nbsp;cu)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;cu.types.compile()&nbsp;...;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;compile(Interface&nbsp;interface)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;cu.members.compile()&nbsp;...;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;compile(Class&nbsp;cu)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;cu.members.compile()&nbsp;...;<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;compile(Field&nbsp;cu)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...;<br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />}<br />
</p>
</div>
</div>


</p>




<a name="polymorphicDispatch-6"></a>
<div class="section" title="How case methods are translated to Java">
<div class="titlepage">
<div>
<div>
<h4 class="title">
How case methods are translated to Java
</h4>
</div>
</div>
</div>



<p>
The polymorphic behavior of case methods shall be transparently work no matter you call such a function from Java, Xtend2 or any other JVM language.
Therefore the runtime dispatch is not done on the caller&apos;s side but on the declaration side. 
For each set of case methods where the name is equal and the number of arguments is equal, the most common denominator signature is taken 
or computed if there is no most common denominator. Only for that signature a Java method with the given
name is generated, all the case methods are generated to protected methods where the name is prefixed with an
underscore. 
</p>

<p>
Within the implementation of the dispatch method the correct case method is looked up at runtime using if else cascades.
This is done by sorting the methods from most specific to least specific and generating an if-else cascade for the code.
</p>

<p>
Example: The following functions

<div class="literallayout">
<div class="incode">
<p class="code">
foo(Number&nbsp;x)&nbsp;:&nbsp;&apos;it&apos;s&nbsp;a&nbsp;number&apos;;<br />foo(Integer&nbsp;x)&nbsp;:&nbsp;&apos;it&apos;s&nbsp;an&nbsp;int&apos;;<br />
</p>
</div>
</div>


</p>

<p>
compile to the following Java method:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Couldn&apos;t&nbsp;dispatch.&nbsp;Argument&nbsp;was&nbsp;Number&nbsp;x&nbsp;:"+x);<br />}&nbsp;<br /><br /><span class="keyword">protected</span>&nbsp;String&nbsp;_foo(Integer&nbsp;x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;"It&apos;s&nbsp;an&nbsp;int";<br />}<br /><br /><span class="keyword">protected</span>&nbsp;String&nbsp;_foo(Number&nbsp;x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;"It&apos;s&nbsp;a&nbsp;number";<br />}<br />
</p>
</div>
</div>


</p>

<p>
In case there is no single most general signature, one is computed and the
different overloaded methods are matched in the order they are declared within the class file.
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
foo(Number&nbsp;x,&nbsp;Integer&nbsp;y)&nbsp;:&nbsp;"it&apos;s&nbsp;some&nbsp;number&nbsp;and&nbsp;an&nbsp;int";<br />foo(Integer&nbsp;x,&nbsp;Number&nbsp;x)&nbsp;:&nbsp;"it&apos;s&nbsp;an&nbsp;int&nbsp;and&nbsp;a&nbsp;number";<br />
</p>
</div>
</div>


</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x,&nbsp;Number&nbsp;y)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;((x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(y&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x,(Integer)y);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;((x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(y&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x,(Number)y);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Couldn&apos;t&nbsp;handle&nbsp;Number&nbsp;x:"+x+",&nbsp;Number&nbsp;y:"+y);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
As you can see a null reference is never a match. If you want to fetch null you can declare a parameter using the type <span class="inlinecode">java.lang.Void</span>
.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
foo(Number&nbsp;x)&nbsp;:&nbsp;&apos;it&apos;s&nbsp;some&nbsp;number&apos;;<br />foo(Integer&nbsp;x)&nbsp;:&nbsp;&apos;it&apos;s&nbsp;an&nbsp;int&apos;;<br />foo(Void&nbsp;x)&nbsp;:&nbsp;throw&nbsp;new&nbsp;NullPointerException("x");<br />
</p>
</div>
</div>


</p>

<p>
Which compiles to the following Java code:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;==&nbsp;null)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Void)null);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Couldn&apos;t&nbsp;handle&nbsp;Number&nbsp;x:"+x+",&nbsp;Number&nbsp;y:"+y);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}&nbsp;<br />
</p>
</div>
</div>


</p>


</div>



<a name="polymorphicDispatch-7"></a>
<div class="section" title="Overloading Functions from Super Types">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Overloading Functions from Super Types
</h4>
</div>
</div>
</div>



<p>
Any methods from super types conforming to the compiled form of a case method are also included in the
dispatch. Conforming means they have the right number of arguments and start with an underscore.
</p>

<p>
Example:
</p>

<p>
Consider the following Java class :

<div class="literallayout">
<div class="incode">
<p class="code">
public&nbsp;abstract&nbsp;class&nbsp;AbstractLabelProvider&nbsp;{<br />&nbsp;&nbsp;&nbsp;protected&nbsp;String&nbsp;_label(Object&nbsp;o)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;some&nbsp;generic&nbsp;implementation<br />&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
and the following xtend class extends it like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;MyLabelProvider&nbsp;extends&nbsp;AbstractLabelProvider&nbsp;{<br />&nbsp;&nbsp;&nbsp;case&nbsp;label(Entity&nbsp;this)&nbsp;name<br />&nbsp;&nbsp;&nbsp;case&nbsp;label(Method&nbsp;this)&nbsp;name+"("+params.toString(",")+"):"+type<br />&nbsp;&nbsp;&nbsp;case&nbsp;label(Field&nbsp;this)&nbsp;name+type<br />}<br />
</p>
</div>
</div>


</p>

<p>
The resulting dispatch method in the generated Java class &apos;MyLabelProvider&apos; looks like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
public&nbsp;String&nbsp;label(Object&nbsp;o)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(o&nbsp;instanceof&nbsp;Field)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_label((Field)o);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(o&nbsp;instanceof&nbsp;Method){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_foo((Method)o);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(o&nbsp;instanceof&nbsp;Entity){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_foo((Entity)o);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(o&nbsp;instanceof&nbsp;Object){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_foo((Object)o);<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Couldn&apos;t&nbsp;handle&nbsp;Object&nbsp;o:"+o);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Functions-9"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>
Syntactically Xtend functions are much like Java methods, expect that there are no static methods, the return types are optional and 
of course the function body consists of one expression instead of a sequence of statements. 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
FunctionDef&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;public&apos;|&apos;protected&apos;|&apos;private&apos;|&apos;final&apos;|&apos;case&apos;|&apos;override&apos;)*&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;TypeParameters?&nbsp;TypeRef?&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;ID&apos;(&apos;(ParameterDeclaration&nbsp;(&apos;,&apos;&nbsp;ParameterDeclaration)*)?&apos;)&apos;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;throws&apos;&nbsp;TypeRef&nbsp;(&apos;,&apos;&nbsp;TypeRef)*)?<br />&nbsp;&nbsp;&nbsp;&nbsp;Expression<br />;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="Expressions"></a>

<a name="Expressions"></a>
<div class="section" title="Expressions (in addition Xbase)">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Expressions (in addition Xbase)
</h2>
</div>
</div>
</div>



<p>
Xtend2 adds some expressions to the basic set of expressions provided by Xbase.
</p>




<a name="Expressions-2"></a>
<div class="section" title="Rich Strings">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Rich Strings
</h3>
</div>
</div>
</div>



<p>
Of course there is the template expression, which is used to write readable string concatenation, which
is the main thing you do when writing a code generator. Xtend2 reuses the syntax known from the well
known and widely used Xpand template language (in fact Xtend2 is considered the successor to Xpand and
Xtend). Let&apos;s have a look at an example of how a typical function with template expressions look like:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
toClass(Entity&nbsp;this)&nbsp;:»<br />&nbsp;&nbsp;&nbsp;&nbsp;package&nbsp;«packageName»;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;«placeImports»<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;«name»&nbsp;«IF&nbsp;extendedType!=null»extends&nbsp;«extendedType»«ENDIF»{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«FOREACH&nbsp;members»<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«member.toMember»<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«ENDFOREACH»<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;«;<br />
</p>
</div>
</div>


</p>

<p>
If you are familiar with Xpand, you&apos;ll notice that it is exactly the same syntax. The difference is, that
the template syntax is actually an expression, which means it can occur everywhere where an expression is
expected. For instance in conjunction the powerful switch expression from Xbase:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
toMember(Member&nbsp;this)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;switch(this)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;:»private&nbsp;«type»&nbsp;«name»&nbsp;;«;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;case&nbsp;isAbstract&nbsp;:»&nbsp;abstract&nbsp;«...;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method:»&nbsp;.....&nbsp;«;<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />
</p>
</div>
</div>


</p>


<a name="RichStringIF"></a>

<a name="RichStringIF"></a>
<div class="section" title="Conditions in Rich Strings">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Conditions in Rich Strings
</h4>
</div>
</div>
</div>



<p>
There is a special <span class="inlinecode">IF</span>
 to be used within rich strings which is identical in syntax and meaning to the
old <span class="inlinecode">IF</span>
 from Xpand. Note that you could also use the if expression, but since it has not an explicit
terminal token, it is not as readable in that context.
</p>


</div>

<a name="RichStringFOREACH"></a>

<a name="RichStringFOREACH"></a>
<div class="section" title="Loops in Rich Strings">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Loops in Rich Strings
</h4>
</div>
</div>
</div>



<p>
Also the <span class="inlinecode">FOREACH</span>
 statement is available and can only be used in the context of a rich string.
It also supports the <span class="inlinecode">SEPARATOR</span>
 and <span class="inlinecode">ITERATOR</span>
 declaration from Xpand.
</p>

<p>

</p>

<p>

</p>


</div>

<a name="RichStringType"></a>

<a name="RichStringType"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Typing
</h4>
</div>
</div>
</div>



<p>
The rich string is translated to an efficient string concatenation and the return type of a rich string
is 
<em>java.lang.CharSequence</em>
 which allows much room for efficient implementation.
</p>


</div>

<a name="WhitespaceHandling"></a>

<a name="WhitespaceHandling"></a>
<div class="section" title="Whitespace Handling">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Whitespace Handling
</h4>
</div>
</div>
</div>



<p>
One of the key features of rich strings is the smart handling of whitespace in the template output. The
whitespace is not written into the output data structure as is but preprocessed. This allows for readable
templates as well as nicely formatted output. This can be achieved by applying three simple rules
when the rich string is evaluated.
</p>

<p>

<ol>

<li>

<p>

		An evaluated rich string as part of another string will be prefixed with the current indentation
		of the caller before it is inserted into the result.

</p>

</li>

<li>

<p>

		Indentation in the template that is relative to a control structure will not be propagated to
		the output string. A control structure is a <span class="inlinecode">FOREACH</span>
-loop or a condition (<span class="inlinecode">IF</span>
) as well
		as the opening and closing marks of the rich string itself.
		
		The indentation is considered to be relative to such a constrol structure if the previous line
		ends with a control structure followed by optional white space. The amount of whitespace is not
		taken into account but the delta to the other lines.

</p>

</li>

<li>

<p>

		Lines that do not contain any static text which is not whitespace but do contain control structures
		or invocations of other templates which evaluate to an empty string, will not appear in the output.

</p>

</li>

</ol>

</p>

<p>
The behavior is best described with a set of examples. The following table assumes a data structure of
nested nodes.
</p>

<p>

<table>
<tr>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;this)&nbsp;"""<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;«name»&nbsp;{}<br />&nbsp;&nbsp;&nbsp;&nbsp;"""<br />}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>



</td>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;NodeName{}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>



</td>
</tr>
</table>

</p>

<p>
The indentation before <span class="inlinecode">node&nbsp;«name»</span>
 will be skipped as it is relative to the opening
mark of the rich string and thereby not considered to be relevant for the output but only
for readability of the template itself.
</p>

<p>

<table>
<tr>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;this)&nbsp;"""<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;«name»&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«IF&nbsp;hasChildren»<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«children*.print»<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«ENDIF»<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;"""<br />}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>



</td>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;Parent{<br />&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;FirstChild&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;SecondChild&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;Leaf&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>



</td>
</tr>
</table>

</p>

<p>
As in the previous example, there is no indentation on the root level for the same reason.
The first nesting level has only one indentation level in the output. This is derived from
the indentation of the <span class="inlinecode">IF&nbsp;hasChildren</span>
 condition in the template which is nested in
the node. The additional nesting of the recursive invocation <span class="inlinecode">children*.print</span>
 is not
visible in the output as it is relative the the surrounding control structure. The line with
<span class="inlinecode">IF</span>
 and <span class="inlinecode">ENDIF</span>
 contain only control structures thus they are skipped in the output.
Note the additional indentation of the node <em>Leaf</em> which happens due to the first rule:
Indentation is propagated to called templates.

</p>


</div>

</div>

<a name="extensionMethods"></a>

<a name="extensionMethods"></a>
<div class="section" title="Extension Method Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Extension Method Syntax
</h3>
</div>
</div>
</div>



<p>
Static methods from imports and methods from injected objects where the declaration
is preceded with 
<a href="02-LanguageConcepts.xdoc.html#importExtension">the keyword <span class="inlinecode">extension</span>
</a> can be called using the member syntax.
This means that a method imported through a static import, like e.g. java.util.Collections.singleton(T) can be invoked using 
the member syntax.
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
"Foo".singleton<br />
</p>
</div>
</div>


</p>

<p>
is the same as
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
singleton("Foo")<br />
</p>
</div>
</div>


</p>

<p>
Note that extension methods never shadow a member of the current reference. That is if <span class="inlinecode">java.lang.String</span>
 has a field <span class="inlinecode">singleton</span>
, a method <span class="inlinecode">singleton()</span>
 or a method
<span class="inlinecode">getSingleton()</span>
, those members would be referenced. That is done at compile time, so the tooling is able to tell you what you actually reference.
</p>

<p>
Static functions as well as extensions in the previous version of Xtend make clients not only depend on a certain signature but on the implementation as 
it is not possible to exchange the implementation of a static function. That&apos;s where the <span class="inlinecode">extension</span>
 keyword in conjunction with dependency injection 
comes in. If you have annotated a dependency with the <span class="inlinecode">extension</span>
 keyword, its members become available for extension method syntax.
</p>

<p>
Example:
</p>

<p>
Imagine the following Java interface
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
interface&nbsp;MyExtensions&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getComputedProperty(SomeType&nbsp;type);<br />}<br />
</p>
</div>
</div>


</p>

<p>
With Java you would have to call this method on an instance of MyExtensions like so:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myExtensions.getComputedProperty(someType)<br />
</p>
</div>
</div>


</p>

<p>
In Xtend2 you can have the instance injected like in Java:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
inject&nbsp;extension&nbsp;MyExtensions;<br />
</p>
</div>
</div>


</p>

<p>
But instead of using the long expression known from Java (which would also work) you are able to use the extension method syntax:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
someType.computedProperty<br />
</p>
</div>
</div>


</p>

<p>
It will statically bind to the right method and even more important it doesn&apos;t bind to a specific implementation but just to the signature.
The implementation can be provided through dependency injection.
</p>


</div>

<a name="CreateExpression"></a>

<a name="CreateExpression"></a>
<div class="section" title="Create Expression">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Create Expression
</h3>
</div>
</div>
</div>



<p>
Xtend2 supports model to model transformations. The single most important problem a transformation language has to solve, is to
get rid of the need to transform a net of objects in two phases. This is unfortunately necessary because you would end up with endless recursion
if you write a mapping between objects but these objects are connected in a circular way, which is almost always the case.
</p>

<p>
Consider you want to transform the AST of the following Java interface to Java Class with an abstract method:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
interface&nbsp;Foo&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;Foo&nbsp;newFoo();<br />}<br />
</p>
</div>
</div>


</p>

<p>
Note how Foo contains a method and that method again refers to Foo. We have a circular dependency. Traditionally those problems are solved by doing the transformation
in multiple phases: First transform the tree hierarchy, to make sure that all declarations are in place. Then establish the cross references. 
The problem with this approach is that you have to split up you code. The transformation of a method needs to be split up in creating the object and 
setting the values and containing elements and a code section which establishes the cross reference. This complicates the code and harms readability.
</p>

<p>
In Xtend2 there is a so called create expression (similar to the create extension from previous Xtend). The example from above could be 
implemented like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
toAbstractClass(Interface&nbsp;intf)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;create&nbsp;new&nbsp;Class()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;intf.name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;=&nbsp;true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;methods.addAll(intf.methods.toAbstractMethod);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />;<br />toAbstractMethod(Method&nbsp;m)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;create&nbsp;new&nbsp;Method()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;m.name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;=&nbsp;true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnType&nbsp;=&nbsp;m.returnType.toAbstractClass;&nbsp;//&nbsp;recursive<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />;<br />
</p>
</div>
</div>


</p>

<p>
the create expression contains two expressions. The first expression right after the keyword is called the creator expression, the second expression is 
called the initializer. The execution semantics is that the result of the creator expression is cached and the key is comprised of all local variables and
the create expression itself. This means that whenever the same create expression with the exact same local variables (equality) is executed again the
expression will just return the cached value. After the value is cached it executes the initializer. 
The nice thing is, that you don&apos;t have to care about circular references since a call to the same create expression with the same arguments will return a reference to
the not yet fully initialized element. 
</p>


</div>

</div>

</body>
</html>
