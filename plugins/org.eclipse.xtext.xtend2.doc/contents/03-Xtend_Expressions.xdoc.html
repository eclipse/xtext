<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Expressions</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="Xtend_Expressions"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Expressions</h1>

<p>
The most important part of a function is of course its implementation, which in Xtend is either a single

<a href="04-Expressions.xdoc.html#Xbase_Expressions_Blocks">block expression</a> or a 
<a href="03-Xtend_Expressions.xdoc.html#Xtend_RichStrings">rich string expression</a>. 
</p>




<a name="Xtend_Expressions-2"></a>
<div class="section" title="Blocks">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Blocks
</h2>
</div>
</div>
</div>



<p>
The block expression allows to have imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. Empty blocks return <span class="inlinecode">null</span>
. 

<a href="04-Expressions.xdoc.html#Xbase_Expressions_VariableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as a block&apos;s last expression.
</p>

<p>
A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.
</p>




<a name="Xbase_Expressions_Blocks-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string" >"foo"</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;result<br />
}
</p>
</div>
</div>



<div class="literallayout">
<div class="incode">
<p class="code">
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;x&nbsp;=&nbsp;greeting();<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x.equals(<span class="string" >"Hello&nbsp;"</span>))&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x+<span class="string" >"World!"</span>;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_Blocks-4"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XBlockExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;{&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(XExpressionInsideBlock&nbsp;&apos;;&apos;?)*<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;}&apos;;
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-3"></a>
<div class="section" title="Literals">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Literals
</h2>
</div>
</div>
</div>



<p>
A literal denotes a fixed unchangeable value. Literals for string, integers, booleans,
null and Java types are supported.
</p>


<a name="Xbase_Expressions_StringLiterals"></a>

<a name="Xbase_Expressions_StringLiterals"></a>
<div class="section" title="String Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
String Literals
</h3>
</div>
</div>
</div>



<p>
A string literal as syntactically defined in 
<a href="02-Lexical%20Structure.xdoc.html#Xbase_Syntax_StringLiteral">section Xbase_Syntax_StringLiteral</a> is a valid expression and returns an instance of <span class="inlinecode">java.lang.String</span>
 of the given value.
</p>

<p>

<ul>

<li>

<p>
<span class="inlinecode">&apos;Hello&nbsp;World&nbsp;!&apos;</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">"Hello&nbsp;World&nbsp;!"</span>

</p>

</li>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
"Hello&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;World&nbsp;!"
</p>
</div>
</div>


</p>

</li>

</ul>

</p>


</div>

<a name="Xbase_Expressions_IntegerLiterals"></a>

<a name="Xbase_Expressions_IntegerLiterals"></a>
<div class="section" title="Integer Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Integer Literals
</h3>
</div>
</div>
</div>



<p>
An integer literal as defined in 
<a href="02-Lexical%20Structure.xdoc.html#Xbase_Syntax_IntegerLiteral">section Xbase_Syntax_IntegerLiteral</a> creates an <span class="inlinecode">int</span>
.
There is no signed int. If you put a minus operator in front of an int literal it is taken as a UnaryOperator
with one argument (the positive int literal).
</p>

<p>

<ul>

<li>

<p>
<span class="inlinecode">42</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">234254</span>

</p>

</li>

</ul>

</p>


</div>

<a name="Xbase_Expressions_BooleanLiteral"></a>

<a name="Xbase_Expressions_BooleanLiteral"></a>
<div class="section" title="Boolean Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Boolean Literals
</h3>
</div>
</div>
</div>



<p>
There are two boolean literals, <span class="inlinecode">true</span>
 and <span class="inlinecode">false</span>
 which correspond to their Java counterpart of type <em>boolean</em>. 
</p>

<p>

<ul>

<li>

<p>
<span class="inlinecode">true</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">false</span>

</p>

</li>

</ul>

</p>


</div>

<a name="Xbase_Expressions_NullLiteral"></a>

<a name="Xbase_Expressions_NullLiteral"></a>
<div class="section" title="Null Literal">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Null Literal
</h3>
</div>
</div>
</div>



<p>
The null pointer literal is, like in Java, <span class="inlinecode">null</span>
. 
It is a member of any reference type.
</p>

<p>

<ul>

<li>

<p>
<span class="inlinecode">null</span>

</p>

</li>

</ul>

</p>


</div>

<a name="Xbase_Expressions_TypeLiteral"></a>

<a name="Xbase_Expressions_TypeLiteral"></a>
<div class="section" title="Type Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Type Literals
</h3>
</div>
</div>
</div>



<p>
Type literals are specified using the keyword <em>typeof</em> :
</p>

<p>

<ul>

<li>

<p>
<span class="inlinecode">typeof(java.lang.String)</span>
 which yields java.lang.String.class
</p>

</li>

</ul>

</p>


</div>

</div>



<a name="Xtend_Expressions-4"></a>
<div class="section" title="Infix Operators / Operator Overloading">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Infix Operators / Operator Overloading
</h2>
</div>
</div>
</div>



<p>
There are a couple of common predefined infix operators. In contrast to Java, the operators are not fixed
to operations on certain types. Instead an operator to method mapping allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.
</p>

<p>

<table>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+=&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_add(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;||&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_or(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&amp;&amp;&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_and(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;==&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_equals(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;!=&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_notEquals(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_lessThan(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_greaterThan(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;=&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_lessEqualsThan(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;=&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_greaterEqualsThan(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&gt;&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_mappedTo(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;..&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_upTo(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_plus(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_minus(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;*&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_multiply(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;/&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_divide(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;%&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_modulo(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;**&nbsp;e2</span>

</td>
<td>
<span class="inlinecode">e1._operator_power(e2)</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">!&nbsp;e1</span>

</td>
<td>
<span class="inlinecode">e1._operator_not()</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">-&nbsp;e1</span>

</td>
<td>
<span class="inlinecode">e1._operator_minus()</span>

</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
<td>
<span class="inlinecode">&nbsp;</span>

</td>
</tr>
</table>

		
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The assignment operator <span class="inlinecode">+=</span>
 is right-to-left associative in the same way as the plain assignment
operator <span class="inlinecode">=</span>
 is. That is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 
</p>




<a name="Xbase_Expressions_Operators-3"></a>
<div class="section" title="Short-Circuit Boolean Operators">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Short-Circuit Boolean Operators
</h3>
</div>
</div>
</div>



<p>
If the operators <span class="inlinecode">||</span>
 and <span class="inlinecode">&amp;&amp;</span>
 are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand might not be evaluated at all in the following cases: 

<ol>

<li>

<p>
in the case of <span class="inlinecode">||</span>
 the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode">true</span>
.
</p>

</li>

<li>

<p>
in the case of <span class="inlinecode">&amp;&amp;</span>
 the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode">false</span>
.
</p>

</li>

</ol>

</p>


</div>



<a name="Xbase_Expressions_Operators-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">myList&nbsp;+=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">x&nbsp;&gt;&nbsp;23&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23)</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">!(x)</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

</ul>

</p>


</div>

<a name="Xbase_Expressions_PropertyAssignment"></a>

<a name="Xbase_Expressions_PropertyAssignment"></a>
<div class="section" title="Assignments">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Assignments
</h3>
</div>
</div>
</div>



<p>

<a href="04-Expressions.xdoc.html#Xbase_Expressions_VariableDeclaration">Local variables</a> can be reassigned using the <span class="inlinecode">=</span>
 operator. Also properties can be set using 
that operator:
Given the expression 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;"foo"
</p>
</div>
</div>


</p>

<p>
The compiler first looks up whether there is an accessible Java Field called <span class="inlinecode">myProperty</span>
 on the type of <span class="inlinecode">myObj</span>
. If there is one it translates to
the following Java expression :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;<span class="string" >"foo"</span>;
</p>
</div>
</div>


</p>

<p>
Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.
</p>

<p>
If there is no accessible field on the left operand&apos;s type, a method called <span class="inlinecode">setMyProperty(OneArg)</span>
 (JavaBeans
setter method) is looked up. It has to take one argument of the type (or a super type) of the right hand operand. The return value will be whatever the 
setter method returns (which usually is <span class="inlinecode">null</span>
). 
As a result the compiler translates to :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.setMyProperty(<span class="string" >"foo"</span>)
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-5"></a>
<div class="section" title="Feature Calls">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Feature Calls
</h2>
</div>
</div>
</div>



<p>
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, 
which are made available for the current expression&apos;s scope. 
</p>




<a name="Xbase_Expressions_FeatureCalls-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>
The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.

<div class="literallayout">
<div class="incode">
<p class="code">
FeatureCall&nbsp;:<br />
&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;|<br />
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;(&apos;.&apos;&nbsp;ID&nbsp;(&apos;(&apos;&nbsp;Expression&nbsp;(&apos;,&apos;&nbsp;Expression)*&nbsp;&apos;)&apos;)?)*
</p>
</div>
</div>


</p>


</div>

<a name="Xbase_Expressions_PropertyAccess"></a>

<a name="Xbase_Expressions_PropertyAccess"></a>
<div class="section" title="Property Access">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Property Access
</h3>
</div>
</div>
</div>



<p>
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as 
described in 
<a href="04-Expressions.xdoc.html#Xbase_Expressions_PropertyAssignment">section Xbase_Expressions_PropertyAssignment</a> applies. 
That is, for the following expression
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty
</p>
</div>
</div>


</p>

<p>
the compiler first looks for an accessible field in the type of <span class="inlinecode">myObj</span>
. If no such field exists it looks for a method called <span class="inlinecode">myProperty()</span>
 before it looks 
for the getter methods <span class="inlinecode">getMyProperty()</span>
. If none of these members can be found the expression is unbound and a compiliation error is thrown.
</p>


</div>

<a name="Xbase_Expressions_ImplicitThis"></a>

<a name="Xbase_Expressions_ImplicitThis"></a>
<div class="section" title="Implicit 'this' variable">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Implicit &apos;this&apos; variable
</h3>
</div>
</div>
</div>



<p>
If the current scope contains a variable named <span class="inlinecode">this</span>
, the compiler will make all its members available to the scope. 
That is if 

<div class="literallayout">
<div class="incode">
<p class="code">
this.myProperty
</p>
</div>
</div>


is a valid expression

<div class="literallayout">
<div class="incode">
<p class="code">
myProperty
</p>
</div>
</div>


is valid as well and is equivalent, as long as there is no local variable &apos;myProperty&apos; on the scope,
which would have higher precedence.
</p>


</div>

<a name="Xbase_Expressions_NullSafeFeatureCalls"></a>

<a name="Xbase_Expressions_NullSafeFeatureCalls"></a>
<div class="section" title="Null-Safe Feature Call">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Null-Safe Feature Call
</h3>
</div>
</div>
</div>



<p>
Checking for null references can make code very unreadable. In many situations it is ok for an expression to return null if a receiver was null.
Xbase supports the safe navigation operator <span class="inlinecode">?.</span>
 to make such code more readable.
</p>

<p>
Instead of writing 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
if&nbsp;(&nbsp;myRef&nbsp;!=&nbsp;null&nbsp;)&nbsp;myRef.doStuff()
</p>
</div>
</div>


</p>

<p>
one can write
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myRef?.doStuff()
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-6"></a>
<div class="section" title="Constructor Call">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Constructor Call
</h2>
</div>
</div>
</div>



<p>
Construction of objects is done by invoking Java constructors. The syntax is exactly as in Java.
</p>




<a name="Xbase_Expressions_ConstructorCall-2"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>


<div class="literallayout">
<div class="incode">
<p class="code">
new&nbsp;String()
</p>
</div>
</div>



</p>

</li>

<li>

<p>


<div class="literallayout">
<div class="incode">
<p class="code">
new&nbsp;java.util.ArrayList&lt;java.math.BigDecimal&gt;()
</p>
</div>
</div>



</p>

</li>

</ul>

</p>


</div>



<a name="Xbase_Expressions_ConstructorCall-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XConstructorCall:<br />
&nbsp;&nbsp;&apos;new&apos;&nbsp;QualifiedName&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&apos;&lt;&apos;&nbsp;JvmTypeArgument&nbsp;(&apos;,&apos;&nbsp;JvmTypeArgument)*&nbsp;&apos;&gt;&apos;)?&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&apos;(&apos;(XExpression&nbsp;(&apos;,&apos;&nbsp;XExpression)*)?&apos;)&apos;)?;
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-7"></a>
<div class="section" title="If Expression">
<div class="titlepage">
<div>
<div>
<h2 class="title">
If Expression
</h2>
</div>
</div>
</div>



<p>
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java&apos;s if statement it behaves  
like Java&apos;s ternary operator (<span class="inlinecode">predicate&nbsp;?&nbsp;thenPart&nbsp;:&nbsp;elsePart</span>
), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within expressions.
</p>




<a name="Xbase_Expressions_IfExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XIfExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;if&apos;&nbsp;&apos;(&apos;&nbsp;XExpression&nbsp;&apos;)&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br />
&nbsp;&nbsp;&nbsp;&nbsp;(&apos;else&apos;&nbsp;XExpression)?;
</p>
</div>
</div>


</p>

<p>
An expression <span class="inlinecode">if&nbsp;(p)&nbsp;e1&nbsp;else&nbsp;e2</span>
 results in either the value <span class="inlinecode">e1</span>
 or <span class="inlinecode">e2</span>
 depending on whether the predicate <span class="inlinecode">p</span>
 
evaluates to <span class="inlinecode">true</span>
 or <span class="inlinecode">false</span>
. The else part is optional which is a shorthand for <span class="inlinecode">else&nbsp;null</span>
.
That means 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
if&nbsp;(foo)&nbsp;x
</p>
</div>
</div>


</p>

<p>
is the a short hand for
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
if&nbsp;(foo)&nbsp;x&nbsp;else&nbsp;null
</p>
</div>
</div>


</p>


</div>

<a name="Xbase_Expressions_IfTypeInference"></a>

<a name="Xbase_Expressions_IfTypeInference"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The type of an if expression is calculated by the return types <span class="inlinecode">T1</span>
 and <span class="inlinecode">T2</span>
 of the two expression <span class="inlinecode">e1</span>
 and <span class="inlinecode">e2</span>
.
It uses the rules defined in 
<a href="03-Types.xdoc.html#Xbase_Types_CommonSuperType">section Xbase_Types_CommonSuperType</a>.
</p>


</div>



<a name="Xbase_Expressions_IfExpression-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;this&nbsp;else&nbsp;that</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;{&nbsp;this&nbsp;}&nbsp;else&nbsp;if&nbsp;(thatFoo)&nbsp;{&nbsp;that&nbsp;}&nbsp;else&nbsp;{&nbsp;other&nbsp;}</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;this</span>

</p>

</li>

</ul>

</p>


</div>

</div>



<a name="Xtend_Expressions-8"></a>
<div class="section" title="For Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
For Loop
</h2>
</div>
</div>
</div>



<p>
The for loop <span class="inlinecode">for&nbsp;(T1&nbsp;variable&nbsp;:&nbsp;iterableOfT1)&nbsp;expression</span>
 is used to execute a certain expression for each element of an
array of an instance of <span class="inlinecode">java.lang.Iterable</span>
.
The local <span class="inlinecode">variable</span>
 is final, hence canot be updated. 
</p>

<p>
The return type of a for loop is <span class="inlinecode">void</span>
.
The type of the local variable can be left out. In that case it is inferred from the type of the array
or <span class="inlinecode">java.lang.Iterable</span>
 returned by the iterable expression.
</p>

<p>

<ul>

<li>

<p>


<div class="literallayout">
<div class="incode">
<p class="code">
for&nbsp;(String&nbsp;s&nbsp;:&nbsp;myStrings)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s);<br />
}
</p>
</div>
</div>



</p>

</li>

<li>

<p>


<div class="literallayout">
<div class="incode">
<p class="code">
for&nbsp;(s&nbsp;:&nbsp;myStrings)<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s)
</p>
</div>
</div>



</p>

</li>

</ul>

</p>




<a name="Xbase_Expressions_ForLoop-4"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XForExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;for&apos;&nbsp;&apos;(&apos;&nbsp;JvmFormalParameter&nbsp;&apos;:&apos;&nbsp;XExpression&nbsp;&apos;)&apos;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br />
&nbsp;&nbsp;&nbsp;&nbsp;;
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-9"></a>
<div class="section" title="While Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
While Loop
</h2>
</div>
</div>
</div>



<p>
A while loop <span class="inlinecode">while&nbsp;(predicate)&nbsp;expression</span>
 is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode">false</span>
.
The return type of a while loop is <span class="inlinecode">void</span>
.
</p>




<a name="Xbase_Expressions_WhileExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XWhileExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;while&apos;&nbsp;&apos;(&apos;&nbsp;predicate=XExpression&nbsp;&apos;)&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression;
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_WhileExpression-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
while&nbsp;(true)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect("foo");<br />
}
</p>
</div>
</div>


</p>

</li>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
while&nbsp;(&nbsp;(&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;&nbsp;max&nbsp;)&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(&nbsp;"foo"&nbsp;)
</p>
</div>
</div>


</p>

</li>

</ul>

</p>


</div>

</div>



<a name="Xtend_Expressions-10"></a>
<div class="section" title="Do-While Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Do-While Loop
</h2>
</div>
</div>
</div>



<p>
A do-while loop <span class="inlinecode">do&nbsp;expression&nbsp;while&nbsp;(predicate)</span>
 is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode">false</span>
.
The difference to the 
<a href="04-Expressions.xdoc.html#Xbase_Expressions_WhileExpression">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is <span class="inlinecode">void</span>
.
</p>




<a name="Xbase_Expressions_DoWhileExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XDoWhileExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;do&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;while&apos;&nbsp;&apos;(&apos;&nbsp;predicate=XExpression&nbsp;&apos;)&apos;;
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_DoWhileExpression-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
do&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect("foo");<br />
}&nbsp;while&nbsp;(true)
</p>
</div>
</div>


</p>

</li>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
do&nbsp;doSideEffect("foo")&nbsp;while&nbsp;((i=i+1)&lt;max)
</p>
</div>
</div>


</p>

</li>

</ul>

</p>


</div>

</div>



<a name="Xtend_Expressions-11"></a>
<div class="section" title="Variable Declarations">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Variable Declarations
</h2>
</div>
</div>
</div>



<p>
Variable declarations are only allowed within 
<a href="04-Expressions.xdoc.html#Xbase_Expressions_Blocks">blocks</a>. They are visible in any subsequent expressions in
the block. Although overriding or shadowing variables from outer scopes is allowed, it is usually only
used to overload the variable name &apos;this&apos;, in order to subsequently access an object&apos;s features in an
unqualified manner.
</p>

<p>
A variable declaration starting with the keyword <span class="inlinecode">val</span>
 denotes a so called value, which is essentially a final (i.e. unsettable) variable. In rare cases, one
needs to update the value of a reference. In such situations the variable needs to be declared with the keyword <span class="inlinecode">var</span>
, which stands for &apos;variable&apos;.
</p>

<p>
A typical example for using <span class="inlinecode">var</span>
 is a counter in a loop. 

<div class="literallayout">
<div class="incode">
<p class="code">
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;max&nbsp;=&nbsp;100<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;0<br />
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&nbsp;&gt;&nbsp;max)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("Hi&nbsp;there!")<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+1<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}
</p>
</div>
</div>


</p>

<p>
Variables declared outside a closure using the <span class="inlinecode">var</span>
 keyword are not accessible from within a
closure.
</p>




<a name="Xbase_Expressions_VariableDeclaration-5"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XVariableDeclaration:<br />
&nbsp;&nbsp;&nbsp;&nbsp;(&apos;val&apos;&nbsp;|&nbsp;&apos;var&apos;)&nbsp;JvmTypeReference?&nbsp;ID&nbsp;&apos;=&apos;&nbsp;XExpression;
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_VariableDeclaration-6"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The return type of a variable declaration expression is always <span class="inlinecode">void</span>
. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:

<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;List&lt;String&gt;&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();
</p>
</div>
</div>


In such cases, the right hand expression&apos;s type must 
<a href="03-Types.xdoc.html#Xbase_Types_ConformanceRules">conform</a> to the type on the left hand side. 
</p>

<p>
Alternatively the type can be left out and will be inferred from the initialization expression:  

<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();&nbsp;//&nbsp;-&gt;&nbsp;type&nbsp;ArrayList&lt;String&gt;
</p>
</div>
</div>


</p>


</div>

</div>



<a name="Xtend_Expressions-12"></a>
<div class="section" title="Closures">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Closures
</h2>
</div>
</div>
</div>



<p>
A closure is a literal that defines an anonymous function. A closure also captures the current scope,
so that any final variables and parameters visible at construction time can be referred to in the closure&apos;s expression. 
</p>




<a name="Xbase_Expressions_Closures-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XClosure:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;[&apos;&nbsp;(&nbsp;JvmFormalParameter&nbsp;(&apos;,&apos;&nbsp;JvmFormalParameter)*&nbsp;)?&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;|&apos;&nbsp;XExpression&nbsp;&apos;]&apos;;
</p>
</div>
</div>


</p>

<p>
The surrounding square brackets are optional if the closure is the single argument of a method invocation.
That is you can write
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myList.find(e|e.name==null)
</p>
</div>
</div>


</p>

<p>
instead of
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myList.find([e|e.name==null])
</p>
</div>
</div>


</p>

<p>
But in all other cases the square brackets are mandatory:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
val&nbsp;func&nbsp;=&nbsp;[String&nbsp;s|&nbsp;s.length&gt;3]
</p>
</div>
</div>


</p>


</div>

<a name="Xbase_Expressions_ClosuresTypeInference"></a>

<a name="Xbase_Expressions_ClosuresTypeInference"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
Closures are expressions which produce function objects. The type is a 
<a href="03-Types.xdoc.html#Xbase_Types_FunctionTypes">function type</a>, consisting of the types of the 
parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the closure is used in a context where this is possible.
</p>

<p>
For instance, given the following Java method signature:

<div class="literallayout">
<div class="incode">
<p class="code">
public&nbsp;T&nbsp;&lt;T&gt;getFirst(List&lt;T&gt;&nbsp;list,&nbsp;Function0&lt;T,Boolean&gt;&nbsp;predicate)
</p>
</div>
</div>


</p>

<p>
the type of the parameter can be inferred. Which allows users to write:

<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;"Foo",&nbsp;"Bar"&nbsp;).findFirst(&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;"Bar"&nbsp;)
</p>
</div>
</div>


instead of 

<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;"Foo",&nbsp;"Bar"&nbsp;).findFirst(&nbsp;String&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;"Bar"&nbsp;)
</p>
</div>
</div>


</p>


</div>

<a name="Xbase_Expressions_FunctionMapping"></a>

<a name="Xbase_Expressions_FunctionMapping"></a>
<div class="section" title="Function Mapping">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Function Mapping
</h3>
</div>
</div>
</div>



<p>
An Xbase closure is a Java object of one of the <em>Function</em> interfaces shipped with the runtime library of Xbase. There is an interface 
for each number of parameters (current maximum is six parameters). The names of the interfaces are 

<ul>

<li>

<p>
<em>Function0&lt;ReturnType&gt;</em> for zero parameters, 
</p>

</li>

<li>

<p>
<em>Function1&lt;Param1Type, ReturnType&gt;</em> for one parameters, 
</p>

</li>

<li>

<p>
<em>Function2&lt;Param1Type, Param2Type, ReturnType&gt;</em> for two parameters, 
</p>

</li>

<li>

<p>
... 
</p>

</li>

<li>

<p>
<em>Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</em> for six parameters, 
</p>

</li>

</ul>

</p>

<p>
In order to allow seamless integration with existing Java libraries such as the JDK or Google Guava (formerly known as Google Collect) closures
are auto coerced to expected types if those types declare only one method (methods from java.lang.Object
don&apos;t count).
</p>

<p>
As a result given the method <span class="inlinecode">java.util.Collections.sort(List&lt;T&gt;,&nbsp;Comparator&lt;?&nbsp;super&nbsp;T&gt;)</span>
 is available
as an extension method, it can be invoked like this
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
newArrayList(&nbsp;&apos;aaa&apos;,&nbsp;&apos;bb&apos;,&nbsp;&apos;c&apos;&nbsp;).sort(<br />
&nbsp;&nbsp;&nbsp;&nbsp;e1,&nbsp;e2&nbsp;|&nbsp;if&nbsp;(&nbsp;e1.length&nbsp;&gt;&nbsp;e2.length&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(&nbsp;e1.length&nbsp;&lt;&nbsp;e2.length&nbsp;)&nbsp;{&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_Closures-5"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">[&nbsp;|&nbsp;"foo"&nbsp;]&nbsp;&nbsp;&nbsp;//&nbsp;closure&nbsp;without&nbsp;parameters</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.toUpperCase()&nbsp;]&nbsp;//&nbsp;explicit&nbsp;argument&nbsp;type</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">[&nbsp;a,b,a&nbsp;|&nbsp;a+b+c&nbsp;]&nbsp;//&nbsp;inferred&nbsp;argument&nbsp;types</span>

</p>

</li>

</ul>

</p>


</div>

</div>



<a name="Xtend_Expressions-13"></a>
<div class="section" title="Switch Expression">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Switch Expression
</h2>
</div>
</div>
</div>



<p>
The switch expression is a bit different from Java&apos;s. First, there is no fall through which means only one case is evaluated at most.
Second, the use of switch is not limited to certain values but can be used for any object reference instead.
 
For a switch expression 

<div class="literallayout">
<div class="incode">
<p class="code">
switch&nbsp;e&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;e1&nbsp;:&nbsp;er1<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;e2&nbsp;:&nbsp;er2<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;en&nbsp;:&nbsp;ern<br />
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;er<br />
}
</p>
</div>
</div>


</p>

<p>
the main expression <span class="inlinecode">e</span>
 is evaluated first and then each case sequentially. If the switch expression
contains a variable declaration using the syntax known from 
<a href="04-Expressions.xdoc.html#Xbase_Expressions_ForLoop">section Xbase_Expressions_ForLoop</a>, the value is bound to the given name.
Expressions of type <span class="inlinecode">java.lang.Boolean</span>
 or <span class="inlinecode">boolean</span>
 are not allowed in a switch expression.
</p>

<p>
The guard of each case clause is evaluated until the switch value equals the result of the case&apos;s guard expression or if the case&apos;s guard expression evaluates to <span class="inlinecode">true</span>
.
Then the right hand expression of the case evaluated and the result is returned.
</p>

<p>
If none of the guards matches the default expression is evaluated an returned. If no default expression
is specified the expression evaluates to <span class="inlinecode">null</span>
.
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
switch&nbsp;myString&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;myString.length&gt;5&nbsp;:&nbsp;&apos;a&nbsp;long&nbsp;string.&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&apos;foo&apos;&nbsp;:&nbsp;&apos;It&apos;s&nbsp;a&nbsp;foo.&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;&apos;It&apos;s&nbsp;a&nbsp;short&nbsp;non-foo&nbsp;string.&apos;<br />
}
</p>
</div>
</div>


</p>




<a name="Xbase_Expressions_SwitchExpression-7"></a>
<div class="section" title="Type guards">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Type guards
</h3>
</div>
</div>
</div>



<p>
In addition to the case guards one can add a so called <em>Type Guard</em> which is syntactically just a 
<a href="03-Types.xdoc.html#Xbase_Types_TypeReferences">type reference</a> preceding
the than optional case keyword. The compiler will use that type for the switch expression in subsequent expressions.
Example:

<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;Object&nbsp;x&nbsp;=&nbsp;...;<br />
switch&nbsp;x&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;case&nbsp;x.length()&gt;0&nbsp;:&nbsp;x.length()<br />
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;?&gt;&nbsp;:&nbsp;x.size()<br />
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;-1<br />
}
</p>
</div>
</div>


</p>

<p>
Only if the switch value passes a type guard, i.e. an instanceof operation returns <span class="inlinecode">true</span>
, the case&apos;s guard expression is executed using the same semantics explained in
previously. 
If the switch expression contains an explicit declaration of a local variable or the expression references a local variable,
the type guard acts like a cast, that is all references to the switch value will be of the type specified in the type guard.
</p>


</div>



<a name="Xbase_Expressions_SwitchExpression-8"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The return type of a switch expression is computed using the rules defined in 
<a href="03-Types.xdoc.html#Xbase_Types_CommonSuperType">section Xbase_Types_CommonSuperType</a>. The set of types from which the common super type is 
computed corresponds to the types of each case&apos;s result expression. In case a switch expression&apos;s type is
computed using the expected type from the context, it is sufficient to return the expected type if all case branches types conform to the expected type.
</p>


</div>



<a name="Xbase_Expressions_SwitchExpression-9"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

	switch foo {
		Entity : foo.superType.name
		Datatype : foo.name
		default : throw new IllegalStateException
	}

</p>

</li>

<li>

<p>

	switch x : foo.bar.complicated(&apos;hello&apos;,42) {
		case "hello42" : ...
		case x.length&lt;2 : ...
		default : ....
	}

</p>

</li>

</ul>

</p>


</div>



<a name="Xbase_Expressions_SwitchExpression-10"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XSwitchExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;switch&apos;&nbsp;(ID&nbsp;&apos;:&apos;)?&nbsp;XExpression&nbsp;&apos;{&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCasePart+<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&apos;default&apos;&nbsp;&apos;:&apos;&nbsp;XExpression))?<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;}&apos;;<br />
<br />
XCasePart:<br />
&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference?&nbsp;(&apos;case&apos;&nbsp;XExpression)?&nbsp;&apos;:&apos;&nbsp;XExpression&nbsp;);
</p>
</div>
</div>


}
</p>


</div>

</div>



<a name="Xtend_Expressions-14"></a>
<div class="section" title="Type Casts">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Type Casts
</h2>
</div>
</div>
</div>



<p>
Type cast behave like casts in Java, but have a slightly more readable syntax.
Type casts bind stronger than any other operator but weaker than feature calls.
</p>

<p>
The conformance rules for casts are defined in the <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.5">Java Language Specification</a>.
</p>




<a name="Xbase_Expressions_TypeCasts-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XCastedExpression:<br />
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;&apos;as&apos;&nbsp;JvmTypeReference;
</p>
</div>
</div>


</p>


</div>



<a name="Xbase_Expressions_TypeCasts-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;as&nbsp;MyType</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">(1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23))&nbsp;as&nbsp;BigInteger</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="Xtend_RichStrings"></a>

<a name="Xtend_RichStrings"></a>
<div class="section" title="Rich Strings">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Rich Strings
</h2>
</div>
</div>
</div>



<p>
Rich Strings allow for readable string concatenation, which is the main thing you do when writing a code generator. 
Let&apos;s have a look at an example of how a typical function with template expressions looks like:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
toClass(Entity&nbsp;this)&nbsp;&apos;&apos;&apos;<br />
&nbsp;&nbsp;package&nbsp;«packageName»;<br />
<br />
&nbsp;&nbsp;«placeImports»<br />
<br />
&nbsp;&nbsp;public&nbsp;class&nbsp;«name»&nbsp;«IF&nbsp;extendedType!=null»extends&nbsp;«extendedType»«ENDIF»&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;«FOREACH&nbsp;members»<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«member.toMember»<br />
&nbsp;&nbsp;&nbsp;&nbsp;«ENDFOREACH»<br />
&nbsp;&nbsp;}<br />
&apos;&apos;&apos;
</p>
</div>
</div>


</p>

<p>
If you are familiar with Xpand, you&apos;ll notice that it is exactly the same syntax. The difference is, that
the template syntax is actually an expression, which means it can occur everywhere where an expression is
expected. For instance in conjunction the powerful switch expression from Xbase:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
toMember(Member&nbsp;this)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;this&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;:&nbsp;&apos;&apos;&apos;private&nbsp;«type»&nbsp;«name»&nbsp;;&apos;&apos;&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;case&nbsp;isAbstract&nbsp;:&nbsp;&apos;&apos;&apos;&nbsp;abstract&nbsp;«...&apos;&apos;&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;:&nbsp;&apos;&apos;&apos;&nbsp;.....&nbsp;&apos;&apos;&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}
</p>
</div>
</div>


</p>


<a name="RichStringIF"></a>

<a name="RichStringIF"></a>
<div class="section" title="Conditions in Rich Strings">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Conditions in Rich Strings
</h3>
</div>
</div>
</div>



<p>
There is a special <span class="inlinecode">IF</span>
 to be used within rich strings which is identical in syntax and meaning to the
old <span class="inlinecode">IF</span>
 from Xpand. Note that you could also use the if expression, but since it has not an explicit
terminal token, it is not as readable in that context.
</p>


</div>

<a name="RichStringFOREACH"></a>

<a name="RichStringFOREACH"></a>
<div class="section" title="Loops in Rich Strings">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Loops in Rich Strings
</h3>
</div>
</div>
</div>



<p>
Also the <span class="inlinecode">FOREACH</span>
 statement is available and can only be used in the context of a rich string.
It also supports the <span class="inlinecode">SEPARATOR</span>
 and <span class="inlinecode">ITERATOR</span>
 declaration from Xpand.
</p>


</div>

<a name="RichStringType"></a>

<a name="RichStringType"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The rich string is translated to an efficient string concatenation and the return type of a rich string
is 
<em>java.lang.CharSequence</em>
 which allows room for efficient implementation.
</p>


</div>

<a name="WhitespaceHandling"></a>

<a name="WhitespaceHandling"></a>
<div class="section" title="Whitespace Handling">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Whitespace Handling
</h3>
</div>
</div>
</div>



<p>
One of the key features of rich strings is the smart handling of whitespace in the template output. The
whitespace is not written into the output data structure as is but preprocessed. This allows for readable
templates as well as nicely formatted output. This can be achieved by applying three simple rules
when the rich string is evaluated.
</p>

<p>

<ol>

<li>

<p>

		An evaluated rich string as part of another string will be prefixed with the current indentation
		of the caller before it is inserted into the result.

</p>

</li>

<li>

<p>

		Indentation in the template that is relative to a control structure will not be propagated to
		the output string. A control structure is a <span class="inlinecode">FOREACH</span>
-loop or a condition (<span class="inlinecode">IF</span>
) as well
		as the opening and closing marks of the rich string itself.
		
		The indentation is considered to be relative to such a constrol structure if the previous line
		ends with a control structure followed by optional white space. The amount of whitespace is not
		taken into account but the delta to the other lines.

</p>

</li>

<li>

<p>

		Lines that do not contain any static text which is not whitespace but do contain control structures
		or invocations of other templates which evaluate to an empty string, will not appear in the output.

</p>

</li>

</ol>

</p>

<p>
The behavior is best described with a set of examples. The following table assumes a data structure of
nested nodes.
</p>

<p>

<table>
<tr>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;this)&nbsp;&apos;&apos;&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;«name»&nbsp;{}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;&apos;&apos;<br />
}
</p>
</div>
</div>



</td>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;NodeName{}
</p>
</div>
</div>



</td>
</tr>
</table>

</p>

<p>
The indentation before <span class="inlinecode">node&nbsp;«name»</span>
 will be skipped as it is relative to the opening
mark of the rich string and thereby not considered to be relevant for the output but only
for readability of the template itself.
</p>

<p>

<table>
<tr>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;this)&nbsp;&apos;&apos;&apos;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;«name»&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«IF&nbsp;hasChildren»<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«children*.print»<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;«ENDIF»<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&apos;&apos;&apos;<br />
}
</p>
</div>
</div>



</td>
<td>


<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;Parent{<br />
&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;FirstChild&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;SecondChild&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;Leaf&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
}
</p>
</div>
</div>



</td>
</tr>
</table>

</p>

<p>
As in the previous example, there is no indentation on the root level for the same reason.
The first nesting level has only one indentation level in the output. This is derived from
the indentation of the <span class="inlinecode">IF&nbsp;hasChildren</span>
 condition in the template which is nested in
the node. The additional nesting of the recursive invocation <span class="inlinecode">children*.print</span>
 is not
visible in the output as it is relative the the surrounding control structure. The line with
<span class="inlinecode">IF</span>
 and <span class="inlinecode">ENDIF</span>
 contain only control structures thus they are skipped in the output.
Note the additional indentation of the node <em>Leaf</em> which happens due to the first rule:
Indentation is propagated to called templates.
</p>


</div>

</div>



<a name="Xtend_Expressions-16"></a>
<div class="section" title="Return Expression">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Return Expression
</h2>
</div>
</div>
</div>



<p>
Although an explicit return is often not necessary, it is supported.
In a closure for instance a return expression is always implied if the expression itself is not of type
<span class="inlinecode">void</span>
. Anyway you can make it explicit:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
listOfStrings.map(e|&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(e==null)&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"NULL"<br />
&nbsp;&nbsp;&nbsp;&nbsp;e.toUpperCase<br />
})
</p>
</div>
</div>


</p>


</div>



<a name="Xtend_Expressions-17"></a>
<div class="section" title="Throwing Exceptions">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Throwing Exceptions
</h2>
</div>
</div>
</div>



<p>
Like in Java it is possible to throw <span class="inlinecode">java.lang.Throwable</span>
. The syntax is exactly the same as in Java.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(myList.isEmpty)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("the&nbsp;list&nbsp;must&nbsp;not&nbsp;be&nbsp;empty")<br />
&nbsp;&nbsp;&nbsp;&nbsp;...<br />
}
</p>
</div>
</div>


</p>


</div>



<a name="Xtend_Expressions-18"></a>
<div class="section" title="Try, Catch, Finally">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Try, Catch, Finally
</h2>
</div>
</div>
</div>



<p>
The try-catch-finally expression is used to handle exceptional situations.
You are not forced to declare checked exceptions, if you don&apos;t catch checked exceptions they are rethrown
in a wrapping runtime exception. 
Other than that the syntax again is like the one known from Java.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
try&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException()<br />
}&nbsp;catch&nbsp;(NullPointerException&nbsp;e)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;handle&nbsp;e<br />
}&nbsp;finally&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;stuff<br />
}
</p>
</div>
</div>



</p>


</div>

</body>
</html>
