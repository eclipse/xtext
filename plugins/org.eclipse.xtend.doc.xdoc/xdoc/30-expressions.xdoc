chapter:Xtend_Expressions[Expressions]

Unlike Java in Xtend there are no statements. Instead, everything is an expression and has a return value. That
allows to compose your code in intersting ways. For example, you can have a
code[Xtend][try catch] expression on the right hand side of an assignment: 
code[Xtend][
  val data = try {
      fileContentsToString('data.txt')
    } catch (IOException e) {
    'dummy data'
    }
] 

If code[fileContentsToString()] throws an code[IOException], it is caught and the string code['dummy data'] is assigned to the value code[data].
 
Expressions can appear as ref:fields[initializers of fields], the body of constructors
or methods and as values in annotations. A method body can either be a ref:blocks[block expression] 
or a ref:templates[template expression].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:Xtend_Expressions_Literals[Literals]

A literal denotes a fixed unchangeable value. Literals for ref:stringLiterals[strings], ref:numberLiterals[numbers], ref:booleanLiteral[booleans],
code[Xtend][null] and ref:typeLiteral[Java types] are supported.

section2:stringLiterals[String Literals]

A string literal is of type code[java.lang.String] (just like in Java).
String literals are enclosed by a pair of single quotes or double quotes. We mostly use single quotes
because the signal-tonoise ration is a bit better, but generally you should use the terminals which are
least likely occure uin the actual string. Special characters can be quoted with a backslash or defined using
Java's unicode notation. Contrary to Java, strings can span multiple lines.

code[Xtend][
  'Hello World !'
  "Hello World !"
  'Hello "World" !'
  "Hello \"World\" !"
  '\u00a1Hola el mundo!'
  "Hello 
  
    World !"
]

section2:numberLiterals[Number Literals]

Xtend supports roughly the same number literals as Java with a few differences.   
First, there are no signed number literals. If you put a minus operator in front of an number 
literal it is taken as a ref:operators[UnaryOperator] with one argument (the positive number 
literal). Second, as in Java 7, you can separate digits using code[_] for better readability
of large numbers.
 
An integer literal creates an code[Xtend][int], a code[Xtend][long] (suffix code[L]) or a
codeRef[java.math.BigInteger] (suffix code[BI]). There are no octal numbers

code[Xtend][
  42
  1_234_567_890 
  0xbeef    // hexadecimal
  077       // decimal 77 (*NOT* octal)
  -1  // an expression consisting of the unary - operator and an integer literal  
  42L
  0xbeef#L // hexadecimal, mind the '#'
  0xbeef_beef_beef_beef_beef#BI // BigInteger
]

A floating-point literal creates a code[Xtend][double] (suffix code[D] or none), a code[Xtend][float] 
(suffix code[F]) or a codeRef[java.math.BigDecimal] (suffix code[BD]). If you use a code[.] you have to 
specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
literals.  
code[Xtend][
  42d     // double
  0.42e2  // implicit double
  0.42e2f // float
  4.2f    // float
  0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal
]


section2:booleanLiteral[Boolean Literals]

There are two boolean literals, code[Xtend][true] and code[Xtend][false] which correspond to their 
Java counterpart of type code[Xtend][boolean]. 


section2:nullLiteral[Null Literal]

The null pointer literal is code[Xtend][null]. It is a member of any reference type and
the only member of the type code[java.lang.Void], i.e. has the same semantics as in Java.


section2:typeLiteral[Type Literals]

Type literals are specified using the keyword code[Xtend][typeof] :
code[Xtend][
  typeof(java.lang.String) // yields java.lang.String.class
]


section:typeCasts[Type Casts]

A type cast behaves exactly like casts in Java, but have a slightly more readable syntax.
Type casts bind stronger than any other operator but weaker than feature calls.

The conformance rules for casts are defined in the 
link[http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5][Java Language Specification].
Here are some examples:
code[Xtend][
  something as MyClass
  42 as Integer
]

Although casts are supported you might want to use a ref:switchExpression[switch with a type guard] as a better and safer alternative.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:operators[Infix Operators and Operator Overloading]

There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
operators for any type just by implementing the corresponding method signature. As an example, the 
ref:library[Xtend runtime library] contains a class code[BigDecimalExtensions] that defines operators for 
code[BigDecimals] which allows the following code:
code[Xtend][
  val x = 2.71BD
  val y = 3.14BD
  val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)
]

The following defines the operators and the corresponding method signatures / expressions.

table[
  tr[td[code[e1 += e2]]       td[code[e1.operator_add(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 || e2]]       td[code[e1.operator_or(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 && e2]]       td[code[e1.operator_and(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 == e2]]       td[code[e1.operator_equals(e2)]]]
  tr[td[code[e1 != e2]]       td[code[e1.operator_notEquals(e2)]]]
  tr[td[]td[]]

  tr[td[code[e1 < e2]]        td[code[e1.operator_lessThan(e2)]]]
  tr[td[code[e1 > e2]]        td[code[e1.operator_greaterThan(e2)]]]
  tr[td[code[e1 <= e2]]       td[code[e1.operator_lessEqualsThan(e2)]]]
  tr[td[code[e1 >= e2]]       td[code[e1.operator_greaterEqualsThan(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 -> e2]]       td[code[e1.operator_mappedTo(e2)]]]
  tr[td[code[e1 .. e2]]       td[code[e1.operator_upTo(e2)]]]
  tr[td[code[e1 => e2]]       td[code[e1.operator_doubleArrow(e2)]]]
  tr[td[code[e1 << e2]]       td[code[e1.operator_doubleLessThan(e2)]]]
  tr[td[code[e1 >> e2]]       td[code[e1.operator_doubleGreaterThan(e2)]]]
  tr[td[code[e1 <<< e2]]      td[code[e1.operator_tripleLessThan(e2)]]]
  tr[td[code[e1 >>> e2]]      td[code[e1.operator_tripleGreaterThan(e2)]]]
  tr[td[code[e1 <> e2]]       td[code[e1.operator_diamond(e2)]]]
  tr[td[code[e1 ?: e2]]       td[code[e1.operator_elvis(e2)]]]
  tr[td[code[e1 <=> e2]]      td[code[e1.operator_spaceship(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 + e2]]        td[code[e1.operator_plus(e2)]]]
  tr[td[code[e1 - e2]]        td[code[e1.operator_minus(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[e1 * e2]]        td[code[e1.operator_multiply(e2)]]]
  tr[td[code[e1 / e2]]        td[code[e1.operator_divide(e2)]]]
  tr[td[code[e1 % e2]]        td[code[e1.operator_modulo(e2)]]]
  tr[td[code[e1 ** e2]]       td[code[e1.operator_power(e2)]]]
  tr[td[]td[]]
  
  tr[td[code[! e1]]           td[code[e1.operator_not()]]]
  tr[td[code[- e1]]           td[code[e1.operator_minus()]]]
]
    
The table above also defines the operator precedence in ascending order. The blank lines separate 
precedence levels. The assignment operator code[+=] is right-to-left associative in the same way 
as the plain assignment operator code[=] is. That is a = b = c is executed as a = (b = c), all
other operators are left-to-right associative. Parenthesis can be used to adjust the default 
precedence and associativity. 

section2[Short-Circuit Boolean Operators]

If the operators code[||] and code[&&] are bound to the library methods 
code[BooleanExtensions.operator_and(boolean l, boolean r)] resp. 
code[BooleanExtensions.operator_or(boolean l, boolean r)] the operation is evaluated in short circuit mode.
That means that the right hand operand might not be evaluated at all in the following cases: 
ol[
  item[in the case of code[||] the operand on the right hand side is not evaluated if the left 
    operand evaluates to code[Xtend][true].]
  item[in the case of code[&&] the operand on the right hand side is not evaluated if the left 
    operand evaluates to code[Xtend][false].]
]

Still you can overload these operators for your types or even override it for booleans, in which case
both operands are always evaluated and the defined method is invoked.

section2[Examples]

code[Xtend][
my.property = 23
myList += 23
x > 23 && y < 23
x && y || z
1 + 3 * 5 * (- 23)
!(x)
]


section2:assignments[Assignments]

ref:variableDeclaration[Local variables] can be reassigned using the code[=] operator. 

code[Xtend][
  var greeting = 'Hello'
  if (isInformal)
    greeting = 'Hi'
]

Of course, also non-final fields can be set using an assignment: 
code[Xtend][
  myObj.myField = 'foo'
]

section3:propertyAssignments[Setting Properties]

The lack of properties in Java leads to a lot of syntactic noise when working with data objects.
As Xtend is designed to integrate with existing Java APIs it respects the Java Beans convention,
hence you can call a setter using an assignment:

code[Java][
  myObj.myProperty = 'foo' // calls myObj.setMyProperty("foo")
]

The setter is only used if the field is not accessible from the given context. That's why the 
ref:propertyAnnotation[@Property annotation] would rename the local field to code[_myProperty].

In return type of an assignment corresponds to the return type of the mapped expression, i.e. if it's
translated to a simple Java assignment it yields the value of the right hand side, if it's translated
to a setter method it yields whatever the setter method returns.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:blocks[Blocks]

The block expression allows to have imperative code sequences. It consists of a sequence of 
expressions, and returns the value of the last expression. The return type of a block is also the 
type of the last expression. Empty blocks return code[null]. 
ref:variableDeclaration[Variable declarations] are only allowed within blocks and cannot be used as 
a block's last expression.

A block expression is surrounded by curly braces and contains at least one expression. It can 
optionally be terminated by a semicolon. 

Here are two examples:

code[Xtend][
  {
    doSideEffect("foo")
    result
  }
]
code[Xtend][
  {
    var x = greeting();
    if (x.equals("Hello ")) {
      x+"World!"; 
    } else {
      x;
    }
  }
]


section:variableDeclaration[Variable Declarations]

Variable declarations are only allowed within ref:blocks[blocks]. They are visible in any 
subsequent expressions in the block. 

A variable declaration starting with the keyword code[Xtend][val] denotes a so called value, which
is essentially a final (i.e. unsettable) variable. In some cases, one needs to update the value of 
a reference. In such situations the variable needs to be declared with the keyword code[Xtend][var], 
which stands for 'variable'.

A typical example for using code[Xtend][var] is a counter in a loop:
code[Xtend][
{
  val max = 100
  var i = 0
  while (i < max) {
    println("Hi there!")
    i = i + 1
  }
}
]

Shadowing variables from outer scopes is not allowed, the only exception being the 
ref:implicitVariables[implicit variable code[Xtend][it]].

Variables declared outside a lambda expression using the code[Xtend][var] keyword are not accessible from within a
lambda expressions.

section2[Typing]

The type of the variable itself can either be explicitly declared or be inferred from the right hand side
expression. Here is an example for an explicitly declared type:
code[Xtend][
  var List<String> msg = new ArrayList
]

In such cases, the type of the right hand expression must conform to the type 
of the expression on the left side. 

Alternatively the type can be left out and will be inferred from the initialization expression:  
code[Xtend][
  var msg = new ArrayList<String> // -> msg is of type ArrayList<String>  
]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:featureCalls[Field Access and Method Invocation]

As in Java, a simple name can refer to a local field, variable or parameter. In addition
it can point to a method with zero arguments, since the parenthesis are optional if no arguments are
passed. 

section2:propertyAccess[Property Access]

In addition if there is no field with the given name accessible and also no method with name and zero parameters
accessible, it binds to a corresponding Java-Bean getter method if available :

code[Xtend][
  myObj.myProperty // myObj.getMyProperty()  (.. in case myObj.myProperty is not visible.)
]

section2:implicitVariables[Implicit Variables e[this] and e[it]]

Like in Java an instance of the class is bound to code[Xtend][this]. Which allows for either qualifying
field access or method invocations like in :

code[Xtend][
  this.myField
]

or omit the receiver:

code[Xtend][
  myField
]

You can use the variable name code[Xtend][it] to get the same behavior for any variable or parameter:

code[Xtend][
  val it = new Person
  name = 'Horst' // translates to 'it.setName("Horst");'
]

Another speciality of the variable code[Xtend][it] is that it can be shadowed. This is especially useful
when used together with ref:lambdas[lambda expressions].

As code[Xtend][this] is bound to the surrounding object in Java, code[Xtend][it] can be used
in finer-grained constructs such as function parameters. That is why code[Xtend][it.myProperty] has 
higher precedence than code[Xtend][this.myProperty].

section2:staticAccess[Static Access]

For accessing a static field or method you have to use the double colon code[::] like in this example:

code[Xtend][
   MyClass::myField
   MyClass::myMethod('foo')
]

section2:nullSafeFeatureCalls[Null-Safe Feature Call]

Checking for code[Xtend][null] references can make code very unreadable. In many situations it is ok for an 
expression to return code[Xtend][null] if a receiver was code[Xtend][null]. Xtend supports the safe navigation 
operator code[?.] to make such code better readable.

Instead of writing 
code[Java][
  if (myRef != null) myRef.doStuff()
]

one can write
code[Xtend][
  myRef?.doStuff()
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:constructorCall[Constructor Call]

ConstructorCalls have the same syntax as in Java. The only difference is that empty parenthesis
are optional:
code[Xtend][
  new String() == new String
  new ArrayList<BigDecimal>() == new ArrayList<BigDecimal>
]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:lambdas[Lambda Expressions]

A lambda expression is basically a piece of code, which is wrapped in an object to pass it around. As
a Java developer it's best to think of a lambda expression as an anonymous class, i.e. 
when you write the following Java :

code[Java][
  // Java Code!
  final JTextField textField = new JTextField();
  textField.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
      textField.setText("Something happened!");
    }
  });
]

This kind of anonymous classes can be found in many libraries and have always been the poor-man's replacement
for lambda expressions in Java. 

Xtend not only supports lambda expressions, but offers an extremely dense syntax for it. That is the
code above can be written in Xtend like this:

code[Xtend][
  val textField = new JTextField
  textField.addActionListener(\[ ActionEvent e |
    textField.text = "Something happened!"
  \])
]

As you might have guessed, a lambda expression is surrounded by square brackets (borrowed from Smalltalk).
Also a lambda expression like a method declares parameters. The lambda above has one parameter called code[e] which is of
type code[ActionEvent]. You don't have to specify the type explicitly because it can be inferred from
the context:

code[Xtend][
  textField.addActionListener(\[ e |
    textField.text = "Something happened!"
  \])
]

Also as lambdas with one parameter are a common case, there is a special short hand for them,
which is to leave the declaration including the vertical bar out. The name of the single variable will be ref:implicitVariables[it]
in that case:

code[Xtend][
  textField.addActionListener(\[
    textField.text = "Something happened!"
  \])
]

A lambda expression with zero arguments is written like this (note the bar after the opening bracket):

code[Xtend][
  val Runnable runnable = \[|
    println("Hello I'm executed!")
  \]
]

When a method call's last parameter is a lambda it can be passed right after the parameters.
For instance if you want to sort some strings by their length, you could write :

code[Xtend][
  Collections::sort(someStrings) \[ a, b |
    a.length - b.length
  \]
]

which is just the same as writing

code[Xtend][
  Collections::sort(someStrings, \[ a, b |
    a.length - b.length
  \])
]

Since you can leave out empty parenthesis methods wich get a lambda as the single argument you can reduce
the code to write:

code[Xtend][
  textField.addActionListener\[
    textField.text = "Something happened!"
  \]
]

A lambda expression also captures the current scope, so that any final variables and parameters visible at construction time can be referred to 
in the closure's expression. That's exactly what we did with the variable code[textField].

section2:closureTypes[Typing]

Closures are expressions which produce e[Function] objects. The type of a lambda expression generally depends on the target
type, as seen in the previous examples. That is, the lambda expression can coerce to any interface which has declared only 
one method (in addition to the ones inherited from code[java.lang.Object]). This allows for using lambda expressions in many existing Java
APIs directly.

However, if you write a lambda expression without having any target type expectation, like in the following
assignment:

code[Xtend][
  val toUpperCaseFunction = \[String s | s.toUpperCase\] // inferred type is (String)=>String
]

The type will be one of the types found in codeRef[org.eclipse.xtext.xbase.lib.Functions]) or (codeRef[org.eclipse.xtext.xbase.lib.Procedures].
It's a procedure if the return type is code[void], otherwise it's a function.

Xtend supports a shorthand syntax for function types. Instead of writing code[Xtend][Function1<? super String,? extends String>]
which is what you'll find in the generated Java code, you can simply write code[(String)=>String].

Example:
code[Xtend][
  val (String)=>String stringToStringFunction = \[toUpperCase\]
  // or
  val Function1<? super String,? extends String> same = \[toUpperCase\]
  // or
  val stringToStringFunction2 = \[String s | s.toUpperCase\] // inferred type is (String)=>String
]

Checked exceptions that are thrown in the body of a closure but not declared in the implemented method of the target type are rethrown using the 
ref:declaredExceptions[sneaky-throw technique].
Of course you can always ref:Xtend_Expressions_TryCatch[catch and handle] them.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:ifExpression[If Expression]

An if expression is used to choose two different values based on a predicate.

An expression 
code[Xtend][
  if (p) e1 else e2
] 
results in either the value code[e1] or code[e2] 
depending on whether the predicate code[p] evaluates to code[Xtend][true] or code[Xtend][false]. 
The else part is optional which is a shorthand for code[Xtend][else null]. That means 

code[Xtend][
  if (foo) x 
]

is the a short hand for

code[Xtend][
  if (foo) x else null
]

The type of an if expression is the common super type of the return types code[T1] and code[T2] 
of the two expression code[e1] and code[e2]. 

While the code[Xtend][if]-expression has the syntax of Java's if statement it behaves more like Java's ternary operator 
(code[Java][predicate ? thenPart : elsePart]), because it is an expression and returns a value.
Consequently, you can use if expressions deeply nested within expressions:

code[Xtend][
  val name = if (firstName != null) firstName + ' ' + lastName else lastName
]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:switchExpression[Switch Expression]

The code[Xtend][switch] expression is very different from Java's switch statement. First, there is no fall through which means 
only one code[Xtend][case] is evaluated at most. Second, the use of code[Xtend][switch] is not limited 
to certain values but can be used for any object reference instead. code[Object.equals()] is used to
compare the value in the case with the one you are switching over.
 
Given the following example:
 
code[Xtend][
switch numberAsText {
  case 'zero' : 1
  case 'one' : 1
  case 'two' : 2
  ...
  case 'nine' : 9
  default : er
}
]

the main expression code[numberAsText] is evaluated first and then compared to each case sequentially.
If the case expression is of type code[Xtend][boolean], the case matches if the expression evaluates
to true. If it's not of type code[Xtend][boolean] it's compared to the value from the main expression using code[Object.equals(Object)].

If a case is a match, that is it evaluates to code[Xtend][true] or the result equals the one we are switching
over, the case expression after the colon is evaluated and is the result of the whole expression.

Another Example, with mixed code[Xtend][boolean] and code[Object.equals(Object)] cases:

code[Xtend][
  switch myString {
    case myString.length>5 : "a long string."
    case 'some' : "It's some string."
    default : "It's another short string."
  }
]

section2[Type guards]

In addition to the case guards one can add a so called e[Type Guard] which is syntactically just a
ref:types[type reference] preceding an optional case keyword. The cool thing is that the value is automatically down casted
in subsequent expressions. Example:

code[Xtend][
  def length(Object x) {
    switch x {
      String case x.length > 0 : x.length
      List<?> : x.size
      default : -1
    }
  }
]

Only if the switch value passes a type guard, i.e. an instanceof operation returns code[true], the 
case's guard expression is executed using the same semantics explained previously. If the switch 
expression contains an explicit declaration of a local variable or the expression references a local 
variable, the type guard acts like a cast, that is all references to the switch value will be of the 
type specified in the type guard.

Switches with type guards are a safe and much more readable alternative to instance of / casting orgies you might know from Java


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:forLoop[For Loop]

The for loop 
code[Xtend][
  for (T1 variable : arrayOrIterable) expression
] 
is used to execute a certain expression for each element of an array of an instance of 
code[java.lang.Iterable]. The local code[variable] is final, hence canot be updated. 

The return type of a for loop is code[Xtend][void]. The type of the local variable can be left out. 
In that case it is inferred from the type of the array or code[java.lang.Iterable] returned by the 
iterable expression.

code[Xtend][
  for (String s : myStrings) {
    doSideEffect(s)
  }
  
  for (s : myStrings)
    doSideEffect(s)
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:whileExpression[While Loop]

A while loop 
code[Xtend][
  while (predicate) expression
] 
is used to execute a certain expression unless the predicate is evaluated to code[Xtend][false]. 
The return type of a while loop is code[Xtend][void].

code[Xtend][
  while (true) {
    doSideEffect("foo")
  }
  
  while ((i=i+1) < max) 
    doSideEffect("foo")
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:doWhileExpression[Do-While Loop]

A do-while loop 
code[Xtend][
  do expression while (predicate)
] 
is used to execute a certain expression unless the predicate is evaluated to code[Xtend][false]. 
The difference to the ref:whileExpression[while loop] is that the execution starts by executing 
the block once before evaluating the predicate for the first time. The return type of a do-while 
loop is code[Xtend][void].

code[Xtend][
  do {
    doSideEffect("foo");
  } while (true)
  
  
  do doSideEffect("foo") while ((i=i+1)<max)
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:Xtend_Expressions_Return[Return Expression]

A method or lambda expression automatically returns the value of it's expression.
If it's a block expression that is the value of the last expression in it.
However, sometimes you want to return early or make it explicit, because you feel it 
improves readability.

The syntax is just like in Java:

code[Xtend][
  listOfStrings.map(e| {
    if (e==null) 
      return "NULL"
    e.toUpperCase
  }) 
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:Xtend_Expressions_Throw[Throwing Exceptions]

Like in Java it is possible to throw code[java.lang.Throwable]. The syntax is exactly the same as 
in Java.

code[Xtend][
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}   
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:Xtend_Expressions_TryCatch[Try, Catch, Finally]

The try-catch-finally expression is used to handle exceptional situations.
You are not forced to catch checked exceptions, if you do not catch checked exceptions they are 
rethrown in a wrapping runtime exception if not declared in the method's signature. 
Other than that the syntax again is like the one known from Java.

code[Xtend][
  try {
    throw new RuntimeException()
  } catch (NullPointerException e) {
    // handle e
  } finally {
    // do stuff
  }
]

For try-catch it's again beneficial that it is an expression, because you can write code like the following
and don't have to ely on non-final variables:

code[Xtend][
  val name = try {
      person.name
    } catch (NullPointerException e) {
      "no name"
    }
]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:templates[Template Expressions]

Templates allow for readable string concatenation. Templates are surrounded by triple single quotes (code[''']). 
A template expression can span multiple lines and expressions can be nested which are evaluated and their toString() representation is automatcially inserted at that opsition.

The terminals for interpolated expression are so called guillemets code[Xtend][«expression»]. They read nicely and are not often used
the text itself so you seldomly need to escape them. These conflicts are the reason why
template languages often use longer character sequences like e.g. code[<%= expression %>] in JSP. The downside is
that you'll use a proper encoding (Always use UTF-8 and you are good).

If you use the Eclipse plug-in which is recommended, the guillemets will be inserted automatically using
content assist. They are also bound to e[CTRL+SHIFT+<] and e[CTRL+SHIFT+] for code[«] and code[»] respectively.

On a mac they are bound to e[alt+q] (code[«]) and e[alt+Q] (code[»]).

Let us have a look at an example of how a typical method with template expressions looks like:

code[Xtend][
def someHTML(String content) '''
  <html>
    <body>
      «content»
    </body>
  </html>
'''
]

As you can see, template expressions can be used as the direct body of a method.
If an interpolation expression evaluates to code[Xtend][null] an empty string is added.

Template expressions can occur everywhere. 
Here's an example showing it in conjunction the powerful ref:switchExpression[switch expression]:

code[Xtend][
def toText(Node n) {
  switch n {
    Contents : n.text

    A : '''<a href="«n.href»">«n.applyContents»</a>'''

    default : '''
        <«n.tagName»>
          «n.applyContents»
        </«n.tagName»>
    '''
  }
}
]


section2:templateIF[Conditions in Templates]

There is a special code[Xtend][IF] to be used within templates:

code[Xtend][
def someHTML(Paragraph p) '''
  <html>
    <body>
      «IF p.headLine != null»
      	<h1>«p.headline»</h1>
      «ENDIF»
      <p>
        «p.text»
      </p>
    </body>
  </html>
'''
]


section2:templateFOREACH[Loops in Templates]

Also a code[Xtend][FOR] statement is available:

code[Xtend][
def someHTML(List<Paragraph> paragraphs) '''
  <html>
    <body>
      «FOR p : paragraphs»
        «IF p.headLine != null»
      	  <h1>«p.headline»</h1>
        «ENDIF»
        <p>
          «p.text»
        </p>
      «ENDFOR»
    </body>
  </html>
'''
]

The for statement also allows to specify what to prepend (code[Xtend][BEFORE]), put in-between (code[Xtend][SEPARATOR]), and what to
put at the end (code[Xtend][AFTER]) of all iterations. code[Xtend][BEFORE] and code[Xtend][AFTER]
are only executed if there is at least one iteration. (code[Xtend][SEPARATOR]) is only added between
iterations, that it is executed if there are more than one iterations.

Here's an example:

code[Xtend][
def someHTML(List<Paragraph> paragraphs) '''
  <html>
    <body>
      «FOR p : paragraphs BEFORE '<div>' SEPARATOR '</div><div' AFTER '</div>'»
        «IF p.headLine != null»
      	  <h1>«p.headline»</h1>
        «ENDIF»
        <p>
          «p.text»
        </p>
      «ENDFOR»
    </body>
  </html>
'''
]

section2:templateType[Typing]

The template expression is of type codeRef[java.lang.CharSequence] but autocoerces to codeRef[java.lang.String]
if that is the expected target type.


section2:WhitespaceHandling[White Space Handling]

One of the key features of templates is the smart handling of white space in the template output. 
The white space is not written into the output data structure as is but preprocessed. This allows 
for readable templates as well as nicely formatted output. This can be achieved by applying three 
simple rules when the template is evaluated.

ol[
  item[
    Indentation in the template that is relative to a control structure will not be propagated 
    to the output string. A control structure is a code[Xtend][FOR]-loop or a condition 
    (code[Xtend][IF]) as well as the opening and closing marks of the rich string itself.
    
    The indentation is considered to be relative to such a control structure if the previous 
    line ends with a control structure followed by optional white space. The amount of white 
    space is not taken into account but the delta to the other lines.
  ]
  item[
    Lines that do not contain any static text which is not white space but do contain control 
    structures or invocations of other templates which evaluate to an empty string, will not 
    appear in the output.
  ]    
  item[
    Any newlines in appended strings (no matter they are created with template expressions or not) will
	be prepended with the current indentation when inserted.
  ]
]

Although this algorithm sounds a bit complicated at first it behaves very intuitively. In addition the
syntax coloring in Eclipse communicates this behavior.

img[images/Xtend_template_coloring.png][Syntax Coloring For Templates In Eclipse][][]

The behavior is best described with a set of examples. The following table assumes a data structure 
of nested nodes.

table[
  tr[
    td[
      code[Xtend][
class Template {
  print(Node n) '''
    node «n.name» {}
  '''
}
      ]
    ]
    td[
      code[
        node NodeName {}
      ]
    ]
  ]
]

The indentation before code[node «n.name»] will be skipped as it is relative to the opening mark of
the rich string and thereby not considered to be relevant for the output but only for readability 
of the template itself.

table[
  tr[
    td[
      code[Xtend][
class Template {
  print(Node n) '''
    node «n.name» {
      «IF hasChildren»
        «n.children.map\[print\]»
      «ENDIF»
    }
  '''
}
      ]
    ]
    td[
      code[
node Parent{
  node FirstChild {
  }
  node SecondChild {
    node Leaf {
    }
  }
}
      ]
    ]
  ]
]

As in the previous example, there is no indentation on the root level for the same reason.
The first nesting level has only one indentation level in the output. This is derived from
the indentation of the code[Xtend][IF hasChildren] condition in the template which is nested in
the node. The additional nesting of the recursive invocation code[Xtend][children.map\[print\]] is not
visible in the output as it is relative the the surrounding control structure. The line with
code[Xtend][IF] and code[Xtend][ENDIF] contain only control structures thus they are skipped in 
the output. Note the additional indentation of the node e[Leaf] which happens due to the first rule:
Indentation is propagated to called templates.

