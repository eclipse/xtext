
h2(#processing_Xtext_models). Processing Xtext Models

p. Now that we know how to create a language we should talk about processing the parsed models somehow. 
There are typically two useful things one can do with
Xtext models: One is translating them to another programming language, i.e. writing a code generator, 
the other is loading them at runtime and use them
dynamically. We'll talk about code generation later. In this chapter we want to see how to interact with 
Xtext models programmatically. 

Text files parsed by Xtext are represented as object graphs in memory. We call these object graphs _Abstract Syntax Tree (AST)_, _semantic model_ or 
simply _model_ interchangeably. In Xtext models are implemented using the _Eclipse Modeling Framework (EMF)_, which can be seen as a very powerful version 
of JavaBeans. It not only provides the typical getter and setter methods for the different features of a model element but also comes with an long list of 
advanced concepts and semantics, which are extremely useful in the context of Xtext.

h3(#resource). Loading a _Resource_ 
  
EMF models can be persisted by the means of a so called _Resource_. Xtext languages implement the _Resource_ interface which is why you can use the EMF API to
load a model into memory (and also save them):

bc.. new DomainmodelStandaloneSetup().createInjectorAndDoEMFRegistration();

ResourceSet rs = new ResourceSetImpl();
Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), true);
EObject eobject = resource.getContents().get(0);
 
p. The first line initializes the language infrastructure to run in _standalone_ mode. That is EMF is designed to work in Eclipse and therefore makes use of 
Equinox extension points in order to register factories and the like. In a vanilla Java project there is no Equinox, hence we do the registration programmaticly.
The generated _MyLanguageStandaloneSetup_ class does just that. You don't have to do this kind of initialization when you run your plug-ins within Eclipse, since in that case 
the extension point declarations are used.

The other thing the _StandaloneSetup_ takes care of is creating a Guice _injector_. The use of Guice and Dependency Injection is explained "here":#dependencyInjection. 

Now that the language infrastructure is initialized and the different contributions to EMF are registered, we want to load a _Resource_. To do so we first create a 
_ResourceSet_, which as the name suggests represents a set of Resources. If one _Resource_ references another _Resource_, EMF will automatically load that other _Resource_
into the same _ResourceSet_ as soon as the cross-reference is resolved. Resolution of cross-references is done lazy, i.e. on first access.

The 4th line loads the _Resource_ using the resource set. We pass in a URI which points to the file in the file system. 
EMF's URI is a powerful concept. It supports a lot of different schemes to load resources from file system, web sites, jars, OSGi bundles or even 
from Java's classpath. And if that is not enough you can come up with your own schemes. Also a URI can not only point to a resource but also to any _EObject_ in a resource.
This is done by appending a so called _URI fragment_ to the URI. 

The second parameter denotes whether the resource should automatically be loaded if it wasn't already before. Alternatively we could have written

bc..  Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), false);
resource.load(null);

p. The load method optionally takes a map of properties, which allows to define a contract between a client and the specific implementation. In Xtext, for instance, we use 
the map to state whether cross-references should be eagerly resolved. In order to find out what properties are supported, it's usually best to look into 
the concrete implementations. That said, in most cases you don't need to pass any properties at all.

The last line 

bc.. EObject eobject = resource.getContents().get(0);

p. assigns the root element to a local variable.
Actually it is the first element from the contents list of a _Resource_, but in Xtext a _Resource_ always has just one root element.

h3(#programmatic_EMF). Working with EMF Models

p. We have previously talked about Ecore models, which effectively is an _EPackage_ containing a any number of _EClasses_ with _EAttributes_ and _EReferences_. 
Ecore defines additional concepts but they are not so important here. An _EObject_ is an instance of an _EClass_. For instance, the root element
of a domain model would be an instance of the EClass _DomainModel_, as defined in the grammar in the last chapter. EMF provides a reflection layer to work
with EObjects in a generic way. 

bc.. assertEquals("DomainModel", eobject.eClass().getName());
 
p. It is also possible to create new instances or get and set values using the reflection layer. That reflection layer is very helpful when creating generic 
libraries for EMF models, however if you know what kind of model you are working with it's much nicer to program against the generated Java classes. 
As we know that the root element is an instance of DomainModel we can just cast it to the Java interface generated by EMF:

bc.. DomainModel dm = (DomainModel) eobject;

p. The generated Java types provide getter and setter methods for each _EAttribute_ and _EReference_, so that you can easily navigate the model using Java:

bc.. EList<AbstractElement> elements = domainModel.getElements();
for (AbstractElement abstractElement : elements) {
  if (abstractElement instanceof Entity) {
    Entity entity = ((Entity)abstractElement);
    System.out.println("entity "
    	+ entity.getName()
    	+ " extends "
    	+ entity.getSuperType().getName());
  }
}

p. Note that you'll find a lot of convenience API in EMF's _EcoreUtil_ and Xtext's ${org.eclipse.xtext/src/org.eclipse.xtext.EcoreUtil2}. 
  
h3(#node_model). Working with the Parse Tree (aka Node Model)

p. In many situations the information from the _AST_ is sufficient, but in some situations you need additional syntactical information. In Xtext not only
an _AST_ is constructed while parsing but also a so called _parse tree_, which contains all the textual information chunked in so called tokens. The _parse tree_, also 
called _node model_, consists of two different kinds of nodes. 

_LeafNodes_ as the name suggests represent the leafs of the parse tree. Each leaf node represents one 
token. If you go through all leaf nodes of a parse tree and concatenate all the tokens to one string, you'll end up with the whole textual representation 
of the model, including all hidden tokens such as whitespace and comments. The following code does exactly that:

bc.. CompositeNode node = NodeUtil.getNode(domainModel);
Iterable<AbstractNode> contents = NodeUtil.getAllContents(node);
StringBuffer text = new StringBuffer();
for (AbstractNode abstractNode : contents) {
  if (abstractNode instanceof LeafNode)
    text.append(((LeafNode)abstractNode).getText());
}
System.out.println(text);

p. In addition to the text _LeafNodes_ also hold information about the line, the offset and the length of that token.

The other node type is called _CompositeNode_ and is created for almost each grammar element. A composite node can contain other composite nodes and leaf nodes.
The super type of both node types is _AbstractNode_. One can find a couple of convenience methods in ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.NodeUtil} and ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.ParseTreeUtil}.

h3(#working_with_grammar_model). Working with the Grammar

p. Also the grammar is represented as an EMF model and can be used in Java. In fact each node of the _node model_ references
the element from the grammar which was responsible for parsing or lexing that node:

bc.. DomainModel domainModel = (DomainModel) eObject;
CompositeNode node = NodeUtil.getNode(domainModel);
ParserRule parserRule = (ParserRule) node.getGrammarElement();
assertEquals("DomainModel", parserRule.getName());

h3. Working with Live Models

p. In a running Xtext Workbench, there are a number of components which access the semantic model of an open editor, i.e. the parser, the linker, the validator, the outline, the index builder etc. While some of these components are executed by the display thread, others like the parser or the indexer use different concurrent threads to not deteriorate the editing experience. If you for example want to have a consistent outline of your model, it is essential to keep other threads from modifying the model while the outline component reads it.

p. Many of the prominent locations where users can hook in their own code in Xtext are already called from within a thread safe context, e.g. the API for "quick fixes":#quickfixes. Consequently, the following usually applies only if you add additional functionality on top of Xtext, e.g. custom UI actions.

p. Each ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.XtextEditor} uses an ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.IXtextDocument} to store its model. To avoid synchronization trouble, neither of them provides direct access to the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource} storing the semantic model. Instead, the _IXtextDocument_ has two methods _readOnly()_ and _modify()_. Both take an argument of type ${org.eclipse.xtext.util/src/org.eclipse.xtext.util.concurrent.IUnitOfWork}_(==&lt;T&gt;==, IXtextResource)_ which defines a method _==&lt;T&gt;== exec(IXtextResource)_ that contains what you want to do with the model and allows to deliver a result of arbitrary type.

So here is an example of safely reading a model:

bc.. IXtextDocument myDocument = ...;
String rootElementName =  myDocument.readOnly(
  new IUnitOfWork(){
    public String exec(IXtextResource resource) {
      MyType type = (MyType)resource.getContents().get(0);
      return myType.getName();
    }
  });

p. Direct write-access on the document is usually only performed inside the framework. If you want to change a document by means of its semantic model, you should rather use an ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IDocumentEditor} which uses the _modify()_ method internally but takes care of synchronizing the "node model":#node_model, too:

bc.. @Inject
private IDocumentEditor documentEditor;

public void setRootName(IXtextDocument myDocument,
                        final String newName) {
 documentEditor.process(
    new IUnitOfWork.Void() {
       public void process(IXtextResource resource) {
          MyType type = (MyType)resource.getContents().get(0);
          myType.setName(newName);
       }
    }, myDocument);
}

h3. Summary

p. Let's summarize what we have learned: An Xtext model is loaded by an EMF Resource. The main model is represented as an instance of so called _EClasses_ which are themselves
declared within Ecore models. A _parse tree_ is created as well, which effectively acts as a tracing model between the text, the _AST_ and the grammar. The following
diagram illustrates the four different kinds of models.

!{width:50%}images/xtext_data_structures.png!

 