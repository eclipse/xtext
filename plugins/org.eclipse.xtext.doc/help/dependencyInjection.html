<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Dependency Injection in Xtext with Google Guice</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="configuration.html" title="Configuration">
<link rel="prev" href="configuration.html" title="Configuration">
<link rel="next" href="RuntimeConcepts.html" title="Runtime Concepts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Dependency Injection in Xtext with Google Guice</h1>
<p>All Xtext components are assembled by means of Dependency Injection (DI). This means basically that whenever some code is in need for functionality (or state) 
				from another component, one just declares the dependency rather then stating how to resolve it, i.e. obtaining that component.</p>
<p>For instance when some code wants to use a scope provider, it just declares a field (or method or constructor) and 
				adds the @Inject annotation: </p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyLanguageLinker&nbsp;extends&nbsp;Linker&nbsp;{<br>

<br>
&nbsp;&nbsp;@Inject<br>
&nbsp;&nbsp;private&nbsp;IScopeProvider&nbsp;scopeProvider;<br>

<br>
}<br>
&nbsp;<br>

</code>
</p>
</div>
<p>It is not the duty of the code to care about where the 
				<span class="emphasis"><em>IScopeProvider</em></span> comes from or how it is created. When above&rsquo;s
				class is instantiated, Guice sees that it requires an instance of IScopeProvider and assigns it to the specified field or method parameter.
				This of course only works, if the object itself is created by Guice. In Xtext almost every instance is created that way 
				and therefore the whole dependency net is controlled and configured by the means of Google Guice.
			</p>
<p>Guice of course needs to know how to instantiate real objects for declared dependencies. This is done in so called 
				<span class="emphasis"><em>Modules</em></span>.
				A 
				<span class="emphasis"><em>Module</em></span> defines a set of mappings from types to either existing instances, instance providers or concrete
				classes. Modules are implemented in Java. Here&rsquo;s an example:
			</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyDslRuntimeModule&nbsp;extends&nbsp;AbstractMyDslRuntimeModule&nbsp;{<br>
	@Override<br>
	public&nbsp;void&nbsp;configure(Binder&nbsp;binder)&nbsp;{<br>
		super.configure(binder);<br>
		binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);<br>
	}<br>
}<br>

<br>

</code>
</p>
</div>
<p>With plain Guice modules one implements a method called configure and gets a so called 
				<span class="emphasis"><em>Binder</em></span> passed in.
				That binder provides a fluent API to define the mentioned mappings. This was just a very brief and simplified description.
				We highly recommend to have a look at 
				<a class="ulink" href="http://code.google.com/p/google-guice/" target="_new">the website Google Guice</a> to learn more.  
			</p>
<div class="section" title="Xtext&rsquo;s module API">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="guicemodules"></a>Xtext&rsquo;s module API</h3>
</div>
</div>
</div>
<p>Xtext comes with a slightly enhanced module API. For your language you get two different modules: One for the runtime bundle
					which is used when executing your language infrastructure outside of Eclipse such as on the build server. The other is
					located in the UI bundle and adds or overrides bindings when Xtext is used within an Eclipse environment. </p>
<p>The enhancement we added to Guice&rsquo;s Module API is that we provide an abstract base class, which reflectively looks for certain 
					methods in order to find declared bindings. The most common kind of method is :</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;Class&lt;?&nbsp;extends&nbsp;IScopeProvider&gt;&nbsp;bindIScopeProvider()&nbsp;{<br>
	return&nbsp;MyConcreteScopeProvider.class;<br>
}<br>

<br>

</code>
</p>
</div>
<p>which would do the same as the code snippet above. It simply declares a binding from 
					<span class="emphasis"><em>IScopeProvider</em></span> to 
					<span class="emphasis"><em>MyConcreteScopeProvider</em></span>.
					That binding will make Guice instantiate and inject a new instance of 
					<span class="emphasis"><em>MyConcreteScopeProvider</em></span> whenever a dependency 
					to 
					<span class="emphasis"><em>IScopeProvider</em></span> is declared.
				</p>
<p>Having a method per binding allows to deactivate individual bindings by overriding the corresponding methods and either change 
					the binding by returning a different target type or removing that binding completely by returning null.</p>
<p>There are two additional kinds of binding-methods supported. The first one allows to configure a provider. A 
					<span class="emphasis"><em>Provider</em></span> is
					an interface with just one method : 
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;interface&nbsp;Provider&lt;T&gt;&nbsp;{<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Provides&nbsp;an&nbsp;instance&nbsp;of&nbsp;{@code&nbsp;T}.&nbsp;Must&nbsp;never&nbsp;return&nbsp;{@code&nbsp;null}.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;T&nbsp;get();<br>
}<br>

<br>

</code>
</p>
</div>
<p>This one can be used if you need a hook whenever an instance of a certain type is created. For instance if you want to 
					provide lazy access to a singleton or you need to do some computation each time an instance is created (i.e. factory). If you want 
					to point to a provider rather than to a concrete class you can use the following binding method.</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;Class&lt;?&nbsp;extends&nbsp;Provider&lt;IScopeProvider&gt;&gt;&nbsp;provideIScopeProvider()&nbsp;{<br>
	return&nbsp;MyConcreteScopeProviderFactory.class;<br>
}<br>

<br>

</code>
</p>
</div>
<p>
					
<span class="italic">(Please forgive us the overuse of the term</span> provider. 
					<span class="italic">The IScopeProvider is not a Guice</span> provider 
					<span class="italic">.)</span>
				
</p>
<p>That binding tells Guice to instantiate 
					<span class="emphasis"><em>MyConcreteScopeProviderFactory</em></span> and invoke get() in order to obtain an instance of 

					<span class="emphasis"><em>IScopeProvider</em></span> 
					for clients having declared a dependency to that type. Both mentioned methods are allowed to return an instance instead of a type. This
					may be useful if some global state should be shared in the application:
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;Provider&lt;IScopeProvider&gt;&nbsp;provideIScopeProvider()&nbsp;{<br>
	return&nbsp;new&nbsp;MyConcreteScopeProviderFactory();<br>
}<br>

<br>

</code>
</p>
</div>
<p>or</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;IScopeProvider&nbsp;bindIScopeProvider()&nbsp;{<br>
	return&nbsp;new&nbsp;MyConcreteScopeProvider();<br>
}<br>

<br>

</code>
</p>
</div>
<p>respectively.</p>
<p>The last binding method provided by Xtext allows to do anything you can do with Guice&rsquo;s binding API, since it allows you to 
					use it directly. If your method&rsquo;s name starts with the name &lsquo;configure&rsquo;, has a return type 
					<span class="emphasis"><em>void</em></span> and accepts one argument of 
					type 
					<span class="emphasis"><em>Binder</em></span>
				
</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;void&nbsp;configureIScopeProvider(Binder&nbsp;binder)&nbsp;{<br>
	binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);<br>
}&nbsp;<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Obtaining an Injector">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ObtaininganInjector"></a>Obtaining an 
					<span class="emphasis"><em>Injector</em></span>
				
</h3>
</div>
</div>
</div>
<p>In every application wired up with Guice there is usually one point where you initialize a so called 
					<span class="emphasis"><em>Injector</em></span> using the 
					modules declared and after that using that injector to create the root instance of the whole application. In plain Java environments
					this is something that&rsquo;s done in the main method. It could look like this:
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>
	Injector&nbsp;injector&nbsp;=&nbsp;Guice.createInjector(new&nbsp;MyDslRuntimeModule());<br>
	MyApplication&nbsp;application&nbsp;=&nbsp;injector.getInstance(MyApplication.class);<br>
	application.run();<br>
}<br>

<br>

</code>
</p>
</div>
<p>Xtext uses EMF which makes use of a couple of global registries, which have to be configured on startup. Because we
					of course want to leverage Guice also for all factories, etc. that we put into those registries, we have introduced a so called

					<span class="emphasis"><em>ISetup</em></span> which provides a method called 
					<span class="emphasis"><em>Injector createInjectorAndDoEMFRegistration()</em></span>. So instead of using the plain Guice
					code shown above you rather use the 
					<span class="emphasis"><em>ISetup</em></span> class generated for your language, which, as the method name suggests, creates
					an 
					<span class="emphasis"><em>Injector</em></span> and uses it to initialize a couple of EMF objects and register them in the corresponding registries.
				</p>
<div class="literallayout">
<p>
<code class="code">Injector&nbsp;injector&nbsp;=&nbsp;new&nbsp;MyStandaloneSetup().createInjectorAndDoEMFRegistration();&nbsp;<br>

</code>
</p>
</div>
<p>These are the basic ideas around Guice and the small extension Xtext provides on top. For more information we 
					strongly encourage you to read through the documentation on 
					<a class="ulink" href="http://code.google.com/p/google-guice/" target="_new">the website of Google Guice</a>.
				</p>
</div>
</body>
</html>
