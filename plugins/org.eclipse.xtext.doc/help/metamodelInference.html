<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Ecore model inference</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="grammarLanguage.html" title="The Grammar Language">
<link rel="prev" href="syntax.html" title="The Syntax">
<link rel="next" href="grammarImport.html" title="Importing existing Ecore models">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Ecore model inference</h1>
<p>The Ecore model (or meta model) of a textual language describes the structure of its abstract syntax trees (AST). </p>
<p>Xtext uses Ecore&rsquo;s 
				<span class="emphasis"><em>EPackages</em></span> to define Ecore models. Ecore models are declared to be either inferred (generated) from the grammar or imported. 
				By using the 
				<span class="emphasis"><em>generate</em></span> directive, one tells Xtext to derive an 
				<span class="emphasis"><em>EPackage</em></span> from the grammar. 
			</p>
<div class="section" title="Type and Package Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TypeandPackageGeneration"></a>Type and Package Generation</h3>
</div>
</div>
</div>
<p>Xtext creates</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EPackage</em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>for each generate-package declaration. After the directive 
									<span class="emphasis"><em>generate</em></span> a list of parameters follows. The 
									<span class="emphasis"><em>name</em></span> of the 
									<span class="emphasis"><em>EPackage</em></span> will be set to the first parameter, its 
									<span class="emphasis"><em>nsURI</em></span> to the second parameter. An optional alias as the third parameter allows to distinguish generated 
									<span class="emphasis"><em>EPackages</em></span> later. Only one generated package declaration per alias is allowed.
								</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EClass</em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name as the rule itself is assumed. You can specify more than one rule that return the same type but only one 
									<span class="emphasis"><em>EClass</em></span> will be generated.
								</p>
</li>
<li class="listitem">
<p>for each type defined in an action or a cross reference.</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EEnum</em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>for each return type of an enum rule.</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EDataType</em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>for each return type of a terminal rule or a data type rule.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>All 
					<span class="emphasis"><em>EClasses</em></span>, 
					<span class="emphasis"><em>EEnums</em></span>, and 
					<span class="emphasis"><em>EDataTypes</em></span> are added to the 
					<span class="emphasis"><em>EPackage</em></span> referred to by the alias provided in the type reference they were created from.
				</p>
</div>
<div class="section" title="Feature and Type Hierarchy Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="FeatureandTypeHierarchyGeneration"></a>Feature and Type Hierarchy Generation</h3>
</div>
</div>
</div>
<p>While walking through the grammar, the algorithm keeps track of a set of the currently possible return types to add features to. </p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Entering a parser rule the set contains only the return type of the rule. </p>
</li>
<li class="listitem">
<p>Entering a group in an alternative the set is reset to the same state it was in when entering the first group of this alternative. </p>
</li>
<li class="listitem">
<p>Leaving an alternative the set contains the union of all types at the end of each of its groups.</p>
</li>
<li class="listitem">
<p>After an optional element, the set is reset to the same state it was before entering it. </p>
</li>
<li class="listitem">
<p>After a mandatory (non-optional) rule call or mandatory action the set contains only the return type of the called rule or action. </p>
</li>
<li class="listitem">
<p>An optional rule call does not modify the set.</p>
</li>
<li class="listitem">
<p>A rule call is optional, if its cardinality is '
							<span class="emphasis"><em>?</em></span>' or '
							<span class="emphasis"><em>*</em></span>'.
						</p>
</li>
</ul>
</div>
<p>While iterating the parser rules Xtext creates</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EAttribute</em></span> in each current return type
						</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>of type 
									<span class="emphasis"><em>EBoolean</em></span> for each feature assignment using the '
									<span class="emphasis"><em>?=</em></span>' operator. No further 
									<span class="emphasis"><em>EReferences</em></span> or 
									<span class="emphasis"><em>EAttributes</em></span> will be generated from this assignment.
								</p>
</li>
<li class="listitem">
<p>for each assignment with the '
									<span class="emphasis"><em>=</em></span>' or '
									<span class="emphasis"><em>+=</em></span>' operator calling a terminal rule. Its type will be the return type of the called rule.
								</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>an 
							<span class="emphasis"><em>EReference</em></span> in each current return type
						</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>for each assignment with the '
									<span class="emphasis"><em>=</em></span>' or '
									<span class="emphasis"><em>+=</em></span>' operator in a parser rule calling a parser rule. The 
									<span class="emphasis"><em>EReference</em></span>'s type will be the return type of the called parser rule.
								</p>
</li>
<li class="listitem">
<p>for each assigned action. The reference&rsquo;s type will be set to the return type of the current calling rule. </p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>Each 
					<span class="emphasis"><em>EAttribute</em></span> or 
					<span class="emphasis"><em>EReference</em></span> takes its name from the assignment or action that caused it. Multiplicities will be 0...1 for assignments with the '
					<span class="emphasis"><em>=</em></span>' operator and 0...* for assignments with the '
					<span class="emphasis"><em>+=</em></span>' operator. 
				</p>
<p>Furthermore, each type that is added to the currently possible return types automatically extends the current return type of the parser rule. You can specify additional common super types by means of &ldquo;artificial&rdquo; parser rules, that are never called, e.g.</p>
<div class="literallayout">
<p>
<code class="code">CommonSuperType:<br>
&nbsp;&nbsp;SubTypeA&nbsp;|&nbsp;SubTypeB&nbsp;|&nbsp;SubTypeC;<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Enum Literal Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="EnumLiteralGeneration"></a>Enum Literal Generation</h3>
</div>
</div>
</div>
<p>For each alternative defined in an enum rule, the transformer creates an enum literal, when another literal with the same name cannot be found. The 
					<span class="emphasis"><em>literal</em></span> property of the generated enum literal is set to the right hand side of the declaration. If it is omitted, you will get an enum literal with equal 
					<span class="emphasis"><em>name</em></span> and 
					<span class="emphasis"><em>literal</em></span> attributes.
				</p>
<div class="literallayout">
<p>
<code class="code">enum&nbsp;MyGeneratedEnum:<br>
&nbsp;&nbsp;NAME&nbsp;=&nbsp;'literal'&nbsp;|&nbsp;EQUAL_NAME_AND_LITERAL;<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Feature Normalization">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="FeatureNormalization"></a>Feature Normalization</h3>
</div>
</div>
</div>
<p>In the next step the generator examines all generated 
					<span class="emphasis"><em>EClasses</em></span> and lifts up similar features to super types if there is more than one subtype and the feature is defined in every subtypes. This does even work for multiple super types.
				</p>
</div>
<div class="section" title="Customized Post Processing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="customPostProcessing"></a>Customized Post Processing</h3>
</div>
</div>
</div>
<p>As a last step, the generator invokes the post processor for every generated Ecore model. The post processor expects an Xtend file with name 
					<span class="emphasis"><em>PostProcessor.ext</em></span> (if the name of the grammar file is 
					<span class="emphasis"><em>MyDsl.xtext</em></span>) in the same folder as the grammar file. Further, for a successful invocation, the Xtend file must declare an extension with signature 
					<span class="emphasis"><em>process(xtext::GeneratedMetamodel)</em></span>. E.g.
				</p>
<div class="literallayout">
<p>
<code class="code">process(xtext::GeneratedMetamodel&nbsp;this)&nbsp;:<br>
&nbsp;&nbsp;process(ePackage)<br>
;<br>
&nbsp;<br>
process(ecore::EPackage&nbsp;this)&nbsp;:<br>
&nbsp;&nbsp;...&nbsp;do&nbsp;something<br>
;<br>

<br>

</code>
</p>
</div>
<p>The invoked extension can then augment the generated Ecore model in place. Some typical use cases are to:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>set default values for attributes,</p>
</li>
<li class="listitem">
<p>add container references as opposites of existing containment references, or</p>
</li>
<li class="listitem">
<p>add operations with implementation using a body annotation.</p>
</li>
</ul>
</div>
<p>Great care must be taken to not modify the Ecore model in a way preventing the Xtext parser from working correctly (e.g. removing or renaming model elements).</p>
</div>
<div class="section" title="Error Conditions">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ErrorConditions"></a>Error Conditions</h3>
</div>
</div>
</div>
<p>The following conditions cause an error</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>An 
							<span class="emphasis"><em>EAttribute</em></span> or 
							<span class="emphasis"><em>EReference</em></span> has two different types or different cardinality.
						</p>
</li>
<li class="listitem">
<p>There is an 
							<span class="emphasis"><em>EAttribute</em></span> and an 
							<span class="emphasis"><em>EReference</em></span> with the same name in the same 
							<span class="emphasis"><em>EClass</em></span>.
						</p>
</li>
<li class="listitem">
<p>There is a cycle in the type hierarchy.</p>
</li>
<li class="listitem">
<p>An new 
							<span class="emphasis"><em>EAttribute</em></span>, 
							<span class="emphasis"><em>EReference</em></span> or super type is added to an imported type.
						</p>
</li>
<li class="listitem">
<p>An 
							<span class="emphasis"><em>EClass</em></span> is added to an imported 
							<span class="emphasis"><em>EPackage</em></span>.
						</p>
</li>
<li class="listitem">
<p>An undeclared alias is used. </p>
</li>
<li class="listitem">
<p>An imported Ecore model cannot be loaded.</p>
</li>
</ul>
</div>
</div>
</body>
</html>
