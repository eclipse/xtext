chapter:xbase[Leveraging Xbase Expressions In Your DSLs]

Xbase is an expression language that can be embedded in Xtext languages. Its syntax is close to Java,
but it additionally offers type inferrence, closures, a rich switch statement and a lot more. For details
on the Xbase langugae itself, please consult the Xbase documentation and the Xbase tutorial. Xbase ships 
with an interpreter and a compiler to Java code. Thus, it is easy to add executable behavior to your DSLs.
As Xbase integrates tightly with Java, there is usually no additional code needed to run your DSL as
part of a Java application. 


section[Configuring a language for Xbase]

The following section describes how to enable Xbase expressions and references to Java types in your own DSL.
We will refer to the domainmodel example all through this section.


section2[Setup Plug-in Dependencies]

Your language plug-ins have to have a dependency to the appropriate Xbase plug-in. Add e[org.eclipse.xtext.xbase] 
to your runtime plug-in and e[org.eclipse.xbase.ui] to the UI plug-in. Into the bargain,
Xbase uses the common types model to define its types, so it is likely you need dependencies to 
e[org.eclipse.xtext.common.types] and e[org.eclipse.xtext.common.types.ui]. To use Xtend-based components,
you will furthermore need e[org.eclipse.xtext.xtend2.lib] on the classpath of the runtime plug-in. 


section2[Making Your Grammar Refer To Xbase]

To leverage Xbase, your DSL's grammar must inherit from the Xbase grammar. You have to change the e[with]
clause of our grammar to 

code[Xtext][
grammar <myLangugaeName> with org.eclipse.xtext.xbase.Xbase
]

The Xbase grammar inherits from e[org.eclipse.xtext.xbase.Xtype], a language that defines a concrete 
syntax for type references. Xtype inherits from the default e[org.eclipse.xtext.common.Terminals] 
language. So if your language is not based on the common terminals, your terminal rules might need 
special treatment.

If you want to refer to codeRef[org.eclipse.emf.ecore.EClassifier][EClassifiers] from the Xbase model, you need
to import it first. The same holds for the common types model:

code[Xtext][
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
]

Now identify the location in your grammar, where you want references to Java types and Xbase expression to appear
and call the appropriate rules of the super grammar. Have a look at the domainmodel example: An e[Entity]
can refer to a Java e[superType], so we call the rule e[JvmTypeReference] in the declaration:

code[Xtext][
Entity:
	'entity' name=ValidID ('extends' superType=JvmTypeReference)? '{'
	...
]  

An e[Operation]'s parameters are e[JvmFormalParamters], its return type refers to a Java type and its e[body] is
an e[XBlockExpression], so its parser rule reads as

code[Xtext][
Operation:
	visibility=Visibility? 'op' name=ValidID '(' 
	(params+=JvmFormalParameter (',' params+=JvmFormalParameter)*)? ')' 
	':' type=JvmTypeReference 
		body=XBlockExpression;
]

If you're unsure which entry point to choose for your expressions, consider the root e[XExpression].
e[JvmTypeReference] offers the full Java syntax to refer to generic types.  


section2[Generating Your Language With Xbase Support]

You have to register the EMF genmodels of Xbase and common types to the codeRef[org.eclipse.emf.mwe.utils.StandaloneSetup]
of your MWE2 workflow

code[MWE2][
bean = StandaloneSetup {
	...
	registerGenModelFile = 
		"platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel"
	registerGenModelFile = 
		"platform:/resource/org.eclipse.xtext.common.types/model/JavaVMTypes.genmodel"
]

Also make sure you have the codeRef[org.eclipse.xtext.generator.types.TypesGeneratorFragment] and the
codeRef[org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment] in place

code[MWE2][
	fragment = types.TypesGeneratorFragment {}
	fragment = xbase.XbaseGeneratorFragment {}
]

Several MWE generator fragments have additional properties for the ref:jvmModelInferrence[JVM model inferrence]:
table[
	tr[
		td[codeRef[org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment]]
		td[e[useInferredJvmModel]]
		td[Generate a codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer] stub and hooks for an inferred JVM model]
	]
	tr[
		td[codeRef[org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment]]
		td[e[generateXtendInferrer]]
		td[Generate the codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer] stub in Xtend instead of Java]
	]
	tr[
		td[codeRef[org.eclipse.xtext.ui.generator.refactoring.RefactorElementNameFragment]]
		td[e[useJdtRefactoring]]
		td[Always trigger JDT refactoring and register element rename refactoring as a participant thereof]
	]
]

To avoid running out of memory when regenerating, you increase the maximum heap size and the permanent generation
space in the run configuration of your workflow. We recommend at least 

code[-Xmx512m -XX:MaxPermSize=128m] 

in the e[VM Arguments] section of the e[Arguments] tab. If you are experiencing ambiguity warnings from Antlr,
the ref:antlr_errors[usual countermeasures] apply.


section[Integrating Into the Typesystem]

Xbase is statically typed. To integrate your DSL concepts into its typesystem, we offer a couple of hooks
which will be described in the following. 


section2:jvmModelInferrence[Inferring a JVM Model]

In many cases, you will want your DSLs concepts to be usable as Java elements. E.g. an e[Entity] will
become a Java class and should be usable as such. In the domain model example, you can write  

code[DomainExample][
entity Employee extends Person {
...

entity Person {
	friends: List<Person>
...
]

i.e. use entities instead of Java types or even mix Java types as codeRef[java.util.List] with entities such as e[Person].
One way to achieve this is to let your concepts inherit from a corresponding JVM type, e.g. let e[Entity]
inherit from codeRef[org.eclipse.xtext.common.types.JvmGenericType]. This usually results in a lot of 
accidentally inherited properties in your domain model. In Xbase there is an alternative: You can define how
to derive a JVM model from your model and link against this e[inferred JVM model]. 

The main component for the inferred JVM model is the codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer].
It has a single method that gets a model element passed in and returns a list of 
codeRef[org.eclipse.xtext.common.types.JvmGenericType][JvmGenericTypes]. As Xbase cannot guess how you
would like to map your concepts to JVM elements, you have to implement this component yourself. This
usually boils down to use an injected codeRef[org.eclipse.xtext.common.types.TypesFactory] to create
a hierarchy of JVM elements, initialize that with values from the input model, and eventually use an injected
codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator] to associate the model elements with the
JVM elements. As this kind of transformation can be elegantly implemented using polymorphic dispatch
functions and extension methods, it is a good choice to write the 
codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer] in Xtend.

In the domain model example, we call a recursive polymorphic dispatch function e[transform] to traverse
the containment hierarchy of the source model and generate JVM elements on the way. We transform each
e[Entity] to a codeRef[org.eclipse.xtext.common.types.JvmGenericType] that holds a 
codeRef[org.eclipse.xtext.common.types.JvmOperation] for each e[Operation] and a 
codeRef[org.eclipse.xtext.common.types.JvmField] plus access methods for each e[Property]. Whenever
we have to copy a subtree, e.g. for setting the supertype of the codeRef[org.eclipse.xtext.common.types.JvmGenericType],
we use codeRef[org.eclipse.xtext.EcoreUtil2]e[.cloneWithProxies()] to avoid eager resolution of referenced
types. 

The framework will automatically switch between the JVM element or the DSL element when needed, e.g. when 
following hyperlinks. The component allowing to navigate between the source model and the JVM model is
called codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations].  

section2[Populating Scopes]

If you're not familiar with Xtext's concept of scopes yet, it would be a good idea to ref:scoping[learn about
scopes] before you go on reading this section. 

The codeRef[org.eclipse.xtext.xbase.scoping.XbaseScopeProvider] already builds a complex hierarchy of
scopes that is necessary to link your expressions. There are a few points you may want to customize.
 
Xbase expressions usually refer to some local context that contains some variables. Suggestively, you
should be able to refer to the e[Entity] itself from within its operations as e[this], as Xbase offers
syntactic sugar to access the features of the element bound to the variable e[this]. The 
codeRef[org.eclipse.xtext.xbase.scoping.XbaseScopeProvider] offers a template method e[createLocalVarScope]
to populate this scope of local variables. Have a look at the following implementation (in Xtend) from
the domain model example:

code[Xtend2][
class DomainmodelScopeProvider extends XbaseScopeProvider {

	@Inject extension IJvmModelAssociations associations
	
	override IScope createLocalVarScope(IScope parent, 
			LocalVariableScopeContext scopeContext) {
		switch context: scopeContext.context {
			Entity : {
				val jvmType = getJvmType(context)
				if(jvmType != null)
					return new SimpleScope(parent, 
						Collections::singleton(
						EObjectDescription::^create(
							XbaseScopeProvider::THIS, jvmType)))
			}
			Operation : {
				val descriptions = context.params.map(
					e | e.createIEObjectDescription())
				return MapBasedScope::createScope(
					super.createLocalVarScope(parent, scopeContext), 
						descriptions);	
			}
		}
		return super.createLocalVarScope(parent, scopeContext)
	}
	...
] 

It binds the variable e[this] within an e[Entity] to the ref:jvmModelInferrence[inferred JVM type] of the
e[Entity]. Additionally, the e[Parameters] of an e[Operation] are available as local variables inside the 
operation body. This way, the Xbase typesystem knows the types of these variables and can put their methods
and fields on the scope.

If you want the inferred model to be cross-referrable from other resources, you have do make sure
it is indexed. Make sure your codeRef[org.eclipse.xtext.naming.IQualifiedNameProvider] returns a qualified
name for these elements, e.g.

code[Java][
	public class DomainmodelQualifiedNameProvider 
		extends DefaultDeclarativeQualifiedNameProvider {

	@Inject
	private IQualifiedNameConverter converter;
	
	QualifiedName qualifiedName(JvmGenericType type) {
		return converter.toQualifiedName(type.getQualifiedName());
	}
}
]

and that your codeRef[org.eclipse.xtext.resource.IResourceDescription$Manager] creates descriptions these elements
(see ref:resourcedescriptions[section on resource descriptions] for details).

section2[TypeProvider]

Xbase is statically typed. To make static analysis work, the framework has to compare expected types with
the actual types returned by an expression. For example, the condition of an codeRef[org.eclipse.xtext.xbase.XIfExpression]
is expected to be a boolean, so any expression used as condition should conform to the boolean type.
The component the defines these types is the codeRef[org.eclipse.xtext.xbase.typing.ITypeProvider]. It
has several responsibilities

table[
	tr[td[getType()]td[returns the type of an expression]]
	tr[td[getExpectedType()]td[returns the expected type of an expression]]
	tr[td[getTypeForIdentifiable()]td[returns the expected type of an element that is referenced]]
	tr[td[getCommonReturnType()]td[returns the common supertype of all types used in return expression
	inside this expression]]
	tr[td[getThrownExceptions()]td[returns the types of all declared exceptions thrown inside this expression]]
]

An additional flag e[rawType] signals a raw type without resolved type parameters is enough. This is
needed to avoid cycles in the type inferrence while linking.
 
The codeRef[org.eclipse.xtext.xbase.typing.XbaseTypeProvider] implements polymorphic dispatch methods
for the first three of these. In the domain model example, we expect the return type of the body of an e[Operation]
to conform to the declared return type. We can do so by specializing the default 
codeRef[org.eclipse.xtext.xbase.typing.XbaseTypeProvider] as

code[Java][
@Singleton
public class DomainmodelTypeProvider extends XbaseTypeProvider {

	protected JvmTypeReference _expectedType(Operation operation, 
			EReference reference, int index, boolean rawType) {
		if(reference == DomainmodelPackage.Literals.OPERATION__BODY) {
			return operation.getType();
		}				
		return null; 
	}
}
]

and of course binding this new implementation in the languge's module. 


section[Generating Java Code using the Xbase Compiler]

The codeRef[org.eclipse.xtext.xbase.compiler.XbaseCompiler] compiles Xbase expressions to Java code.
You will now learn how to integrate it in the code generator of your DSL. 

Two components are responsible for managing the state of the compilation: The codeRef[org.eclipse.xtext.xbase.compiler.ImportManager]
and an codeRef[org.eclipse.xtext.xbase.compiler.IAppendable].

The codeRef[org.eclipse.xtext.xbase.compiler.ImportManager] serializes references to Java types and 
collects namespaces to import on the way. You should use a new instance for each generated Java file, 
use it when generating the code into a string and finally query
the gathered imports to create the import section of the file. 

The following snippet shows how the import manager is used in the domain model example:

code[Xtend2][
class DomainmodelGenerator implements IGenerator {
	
	@Inject DomainmodelCompiler domainmodelCompiler
	
	override void doGenerate(Resource resource, 
	                         IFileSystemAccess fsa) {
		for(entity: resource.allContentsIterable
		                    .filter(typeof(Entity))) {
			fsa.generateFile(entity.fileName, entity.compile)
		}
	}
	
	def compile(Entity e) ''' 
		«val importManager = new ImportManager(true)»
		«/* first evaluate the body in order to collect the used types
			for the import section */
		val body = body(e, importManager)»
		«IF !(e.packageName.isNullOrEmpty)»
			package «e.packageName»;
			
		«ENDIF»
		«FOR i:importManager.imports»
			import «i»;
		«ENDFOR»
		
		«body»
	'''
		
...

	def dispatch feature(Operation o, ImportManager importManager) '''
		public «o.type.shortName(importManager)» «o.name»(«
			o.parameterList(importManager)») {
			«domainmodelCompiler.compile(o, importManager)» 
		}
	'''
] 

An codeRef[org.eclipse.xtext.xbase.compiler.IAppendable] keeps track of the indentation, of local variables, 
and of the generated code. Use an codeRef[org.eclipse.xtext.xbase.compiler.StringBuilderBasedAppendable]
to generate the code of an XbaseExpression into a codeRef[java.lang.StringBuilder]. Here is how the 
codeRef[org.eclipse.xtext.xbase.compiler.IAppendable] is initialized and the 
codeRef[org.eclipse.xtext.xbase.compiler.XbaseCompiler] is called in the domain model example

code[Java][
public class DomainmodelCompiler extends XbaseCompiler {

	@Inject
	private IJvmModelAssociations associations;

	public String compile(Operation operation, 
	                      ImportManager importManager) {
		StringBuilderBasedAppendable appendable = 
			new StringBuilderBasedAppendable(importManager);
		registerThis(operation, appendable);
		for(JvmFormalParameter param: operation.getParams()) {
			appendable.declareVariable(param, param.getName());
		}
		return compile(operation.getBody(), 
		               appendable, 
		               operation.getType()).toString();
	}

	protected void registerThis(Operation operation, 
	                            StringBuilderBasedAppendable appendable) 
	{
		Set<EObject> elements = associations.getJvmElements(operation);
		JvmOperation jvmOp = (JvmOperation) elements.iterator().next();
		appendable.declareVariable(jvmOp.getDeclaringType(), "this");
	}
] 


section[Adding Default Extensions and Literal Functions]







 

