h1(#Overview). Overview

h2. What is Xtext?

No matter if you want to create a small textual domain-specific language (DSL) or you want to implement 
a full-blown general purpose programming language. 
With Xtext you can create your very own languages in a snap. Also if you already have an existing 
language but it lacks decent tool support, you can use Xtext to create 
a sophisticated Eclipse-based development environment providing editing experience known from modern 
Java IDEs in a surprisingly short amount of time. We call Xtext a language development framework.  

h2. How Does It Work?

Xtext provides you with a set of domain-specific languages and modern APIs to describe the different 
aspects of your programming language. 
Based on that information it gives you a full implementation of that language running on the JVM. 
The compiler components of your language are independent of Eclipse or OSGi and can be used in any Java environment.
They include such things as the parser, the type-safe abstract syntax tree (AST), the serializer and 
code formatter, the scoping framework and the linking, compiler checks and static analysis aka validation 
and last but not least a code generator or interpreter. These runtime components integrate with and 
are based on the Eclipse Modeling Framework (EMF), which effectively allows you to 
use Xtext together with other EMF frameworks like for instance the Graphical Modeling Project GMF.

In addition to this nice runtime architecture, you will get a full blown Eclipse-IDE specifically tailored 
for your language. It already provides great default functionality for 
all aspects and again comes with DSLs and APIs that allow to configure or change the most common things 
very easily. And if that's not flexible enough there is Guice to replace the default behaviour with
your own implementations.

h2. Xtext is Highly Configurable

Xtext uses the lightweight dependency injection (DI) framework Google Guice to wire up the whole language 
as well as the IDE infrastructure. A central, external module is used to configure the DI container. 
As already mentioned, Xtext comes with decent default implementations and DSLs and APIs for the aspect that 
are common sweet spots for customization. But if you need something completely different, 
Google Guice gives you the power to exchange every little class in a non-invasive way.

h2. Who Uses Xtext?

Xtext is used in many different industries. It is used in the field of mobile devices, automotive development, 
embedded systems or Java enterprise software projects and game development. 
People use Xtext-based languages to drive code generators that target Java, C, C++, C#, Objective C, Python, or Ruby code. 
Although the language infrastructure itself runs on the JVM, you can compile Xtext languages to any 
existing platform.
Xtext-based languages are developed for well known Open-Source projects such as Maven, Eclipse B3, 
the Eclipse Webtools platform or Google's Protocol Buffers and the framework is also widely used in research projects.  

h2. Who is Behind Xtext?

Xtext is a professional Open-Source project. We, the main developers and the project lead, work for 
itemis, 
which is a well known consulting company specialized on model-based development.
Therefore we are able to work almost full-time on the project. Xtext is an Eclipse.org project. 
Besides many other advantages this means that you don't have to fear any IP issues, because the Eclipse Foundation 
has their own lawyers who take care that no intellectual property is violated. 

You may ask: Where does the money for Open-Source development come from? Well, we provide professional 
services around Xtext. Be it training or on-site consulting, be it development of prototypes or 
implementation of full-blown IDEs for programming languages. We do not only know the framework very well 
but we are also experts in programming and domain-specific language design. Don't hesitate to get in 
contact with us ("www.itemis.com":http://xtext.itemis.com).

h2(#DSL). What is a Domain-Specific Language

A _Domain-Specific Language (DSL)_ is a small programming language, which focuses on a particular domain.
Such a domain can be more or less anything. The idea is that its concepts and notation is as close as possible to
what you have in mind when you think about a solution in that domain. Of course we are talking about problems which can
be solved or processed by computers somehow.

The opposite of a DSL is a so called _GPL_, a _General Purpose Language_ such as Java or any other common programming language.
With a GPL you can solve every computer problem, but it might not always be the best way to solve it.

Imagine you want to remove the core from an apple. You could of course use a Swiss army knife to cut it out, 
and this is reasonable if you have to do it just once or twice. But if you need to do that on a regular 
basis it might be more efficient to use an apple corer.

There are a couple of well-known examples of DSLs. For instance SQL is actually a DSL which focuses on 
querying relational databases. Other DSLs are regular expressions or even languages provided by tools 
like MathLab. Also most XML languages are actually domain-specific languages. The whole purpose of XML is 
to allow for easy creation of new languages. Unfortunately, XML uses a fixed concrete syntax, which is 
very verbose and yet not adapted to be read by humans. Into the bargain, a generic syntax for everything is a compromise.

Xtext is a sophisticated framework that helps to implement your very own DSL with appropriate IDE support. 
There is no such limitation as with XML, you are free to define your concrete syntax as you like. It may 
be as concise and suggestive as possible being a best match for your particular domain. The hard task of 
reading your model, working with it and writing it back to your syntax is greatly simplified by Xtext.



h1(#getting-started). Getting Started

In this mini-tutorial we will implement a small domain-specific language and a 
corresponding Eclipse IDE integration with Xtext. Later, we will create a code generator 
that is capable of reading the models you create with the DSL editor and process them, i.e. 
generate some Java code from it.

h2(#getting-started-xtext). Creating a DSL  

"Download and install the latest version of Xtext":http://www.eclipse.org/Xtext/download/ and 
set up a fresh workspace. We want to develop a small language used to define domain models.
It is a stripped-down version of our _Domain-Model Example_ which is shipped with Xtext 
and can be materialized into your workspace using the example wizard. The following sample 
of a domain model should give you an idea about the language.

bc.. datatype String
datatype Bool

entity Session {
  title: String
  isTutorial : Bool
}

entity Conference {
  name : String
  attendees : Person*
  speakers : Speaker*
}

entity Person {
  name : String
}

entity Speaker extends Person {
  sessions : Session*
}

h3. Create an Xtext Project

In order to get started we first need to create some Eclipse projects. Use the Xtext wizard to do so:

  _File -> New -> Project...  -> Xtext -> Xtext project_

Choose a meaningful project name, language name and file extension, e.g.

| *Main project name:*   |  org.eclipse.xtext.example.domainmodel  |
| *Language name:*     |  org.eclipse.xtext.example.Domainmodel  |
| *DSL-File extension:* |  dmodel  |

Keep "Create generator project" checked, as we will also create a code generator in a second step.
If you want to materialize the full blown Domainmodel example that ships with Xtext, it is
strongly recommend to use another language name and file extension for this tutorial.

Click on _Finish_ to create the projects. 

!images/getting-started-wizard.png!

h3. Project Layout

In the Package Explorer you can see three new projects. In 
_org.eclipse.xtext.example.domainmodel_ the grammar is defined and all runtime 
aspects, such as linking, scoping and validation are developed. The IDE-aspects 
such as the editor, any views, and incremental project builder go into 
_org.eclipse.xtext.example.domainmodel.ui_. Both projects consist of generated 
classes derived from the grammar and manual code such as the grammar itself and 
further classes to differentiate and adapt from the default behavior. Although
Xtext makes use of code generation, most of the code is actually written as 
libraries, which are referenced by the means of OSGi using the Manifest.MF. 

!images/getting-started-project-layout.png!

It is good to be clear and unambiguous whether the code is generated or is to 
be manipulated by the developer. Thus, the generated code should be held 
separately from the manually written code. We follow this pattern by having a 
folder _src/_ and a folder _src-gen/_ in each project. Keep in mind not to 
make changes in the _src-gen/_ folder. They will be overwritten by the generator 
without any further warning.

A third project, _org.eclipse.xtext.example.domainmodel.generator_ will later 
contain an Xpand code generator that leverages the model created with the DSL 
editor. This is fully optional and it is also optional to use Xpand. In fact 
you can use any programming language running on the JVM to implement a code 
generator for your Xtext models. Also it is of course perfectly ok, to have no 
code generator at all but use the models dynamically at runtime. We call these 
kind of model processors _interpreters_.

h3. Build Your Own Grammar

p. *_Please note_*: If you encounter strange errors while copying and pasting
a snippet from this document to your Eclipse editor, your documentation
viewer most likely has inserted characters different from {space} into your 
clipboard. Reenter the "whitespace" or type the text by hand to be sure everything
works fine. 

p. The wizard will automatically open the example grammar file 
_Domainmodel.xtext_ from the first project in the editor. A grammar has two 
purposes: First, it is used to describe the concrete syntax of your language. 
Second, it contains information about how the parser shall create a model during 
parsing.

The first line of the grammar is the grammar declaration:

bc.. grammar org.eclipse.xtext.example.Domainmodel 
  with org.eclipse.xtext.common.Terminals

p. In Xtext each grammar has a unique name, which like public Java classes 
needs to reflect the location of the file within the Java classpath. In our 
case the grammar file is located in 
_/org/eclipse/xtext/example/Domainmodel.xtext_ therefore the name of the 
grammar is _org.eclipse.xtext.example.Domainmodel_. The second part of that 
statement (_with org.eclipse.xtext.common.Terminals_) states, that this grammar 
reuses and overrides rules from the specified grammar. The 
_org.eclipse.xtext.common.Terminals_ is a library grammar shipped with Xtext 
and predefines the most common terminal rules, such as _ID_, _STRING_ and _INT_. 
It also introduces single-line and multi-line comments as well as rules for 
whitespace, which may occur everywhere by default. You can open that grammar in the 
editor to have a look at these rules. It turns out that these set of rules are often 
the same and often used, so that most Xtext languages extend this grammar. 
However, it is just a library, so you won't use it if it doesn't fit your needs. 
Also you can use the grammar inheritance mechanism for your own grammar libraries, 
of course.
 
The next statement declares an EMF Ecore package, aka _EPackage_, to be derived from the grammar:

bc.. generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"

p. Ecore _EPackages_ are effectively a set of classes (in EMF they are called 
_EClass_) which are used to represent the in-memory-model of a text file. Instead
of _model_ we also sometimes refer to it as _semantic model_ or _Abstract Syntax 
Tree (AST)_. Note, that in the case of Xtext it's actually a graph rather than a 
tree, since it also contains crosslinks. But as the term AST is so commonly 
used and well known we are ignoring this minor detail. 
 
In order to tell the parser which _EClasses_ to use when creating the AST, we 
need to make them available by either importing existing Ecore packages or like 
in our example let Xtext derive a package from the grammar. An _EPackage_ has a 
mandatory name and namespace URI (short: _nsURI_), so we have to declare these two values 
in that statement. 

That's all for the prelude, now we have to define the parser rules which 
effectively define a bi-directional mapping from text to a constructed AST. 
It is bi-directional because Xtext not only derives a parser from the grammar but also 
a serializer. Anyway, we will mostly talk about parsing in this chapter.

Ignore and delete the parser rules generated by the wizard and start by 
declaring an entry rule for our language. The entry rule for the parser will be 
called _DomainModel_. Xtext is fine with any name, it just picks the first rule 
in a grammar and interprets it as the entry rule.

As a _DomainModel_ consists of one or more _Entity_ entries, this rule delegates 
to another rule named _Entity_, which will be defined later on. As we can have an 
arbitrary number of entities within a model, the cardinality is '_*_'. There are 
four different cardinalities available.

| (no operator) |  exactly one  |
| _?_     |  zero or one  |
| _*_     |  zero or more|
| _+_     |  one or more  |

Each rule ends with a semicolon. So our first rule reads for now as

bc.. DomainModel :
  Entity*; 

p. An Xtext grammar does not only describe rules for the parser but also the 
structure of the resulting AST. Usually, each parser rule will create a new object 
in that tree. The type of that element can be specified after the rule name using 
the keyword _returns_. If the type's name is the same as the rule's name, it can 
be omitted as in our case. Which effectively means that

bc.. DomainModel returns DomainModel: ...

p. is the same as

bc.. DomainModel : ...

p. In order to connect the different objects together, we have to assign the 
elements returned by called rules to some feature of the current rule's object. 
This is done by using so called assignments. 

bc.. DomainModel :
  (elements+=Entity)*;

p. The assignment with the '_+=_' operator adds every object returned by the 
_Entity_ rule to the _elements_ referenced of the AST type _Model_. If you use '_+=_' 
as opposed to '_=_' the feature needs to be a list - the upperBound has to be -1. In addition to the 
two mentioned assignment operators there is a third one '_?=_' which is called boolean 
assignment and which sets a certain feature to true, if the part on the right hand 
side was parsed successfully. Here's the list of available assignment operators:

|| _feature=..._   | corresponds to _setFeature(...)_  ||
|| _list+=..._  | corresponds to _getList().add(...)_||
|| _condition?=..._  | corresponds to _setCondition(true)_||

p. The next rule on our list is the rule _Entity_. Looking at our target syntax, 
each entity begins with the keyword _'entity'_ followed by the entity's name and an 
opening curly brace (we will handle the _extends_ clause in a second step). Then, 
an entity defines a number of features and ends with a closing curly brace. The 
rule looks like this:

bc.. Entity :
  'entity' name=ID '{'
    (features+=Feature)*
  '}';
  
p. Keywords are simply declared as string literals within the rules. The name 
uses the _ID_ rule from the mixed-in grammar _org.eclipse.xtext.common.Terminals_. 
The _ID_ rule is a so called terminal rule which always returns simple data types, 
such as _String_, _Date_, or _Integer_. Actually any Java class can be a simple 
EMF _EDataType_. The _ID_ rule recognizes alphanumeric words similar to identifiers 
in Java and returns the value as a _String_. You can navigate to its declaration 
using _F3_. As mentioned before the assignment operator '_=_' denotes a single
valued feature.

We want to allow inheritance for entities and therefore now add an optional 
'_extends_' part.

bc.. Entity :
  'entity' name=ID ('extends' superType=[Entity])? '{'
    (features+=Feature)*
  '}';

p. The question mark marks an element or as in this case an entire group of elements as optional.
The other new thing is the right hand side of of the assignment _superType=[Entity]_.
This is a cross-reference literal and states, that a cross-reference to an elsewhere 
declared _Entity_ should be established. So in this case _Entity_ does not point to 
the corresponding rule but to the _EClass_. As both are named equally this might 
cause a little confusion at first. The full syntax for a cross-reference is 
_[TypeName|RuleCall]_ where _RuleCall_ defaults to _ID_. This means that 
_('extends' superType=[Entity|ID])?_ would work equally well. The parser only parses 
the name of the cross-referenced element using the _ID_ rule and stores it 
internally. Later on the linker establishes the cross-reference using the name, the 
defined cross-reference's type (_Entity_ in this case) and the defined scoping rules. 
Scoping is not covered in this tutorial since the domain model DSL works with 
the default scoping semantics. By default a namespace-based scoping is applied, which 
means that all entities living in the same namespace are possible candidates for a 
cross-reference. We talk a bit about this later on in this chapter when we introduce 
namespaces.

p. In our introductory example model we had not only defined entities but also two 
data types. So the _DomainModel_ rule needs to be able to parse data types as well. 
As both entities and data types will be referenced from the yet to be defined _Feature_ 
rule, we should introduce a common super type for them.

bc.. DomainModel :
  (elements+=Type)*;

Type:
  DataType | Entity;
  
DataType:
  'datatype' name=ID;
 
p. A _DomainModel_ now consists of types where a _Type_ can either be a _DataType_ or 
an _Entity_. Our rule _Type_ will just delegate to either of them, using the '_|_' 
alternatives operator. Now that we have a common super type for _Entity_ and _DataType_ 
we are able to refer to both types of elements with a single cross-reference.

Next up we need to define the syntax of _Feature_, which shouldn't be surprising to 
you, as we do not use any new concepts here.

bc.. Feature:
  name=ID ':' type=TypeRef;

p. In many target platforms there is a difference between the notion of a simple 
attribute and a reference. In relational databases, for instance, a table contains 
the values of attributes directly, but references are "modeled" by the means of 
foreign keys. In object-relational persistence technologies such as JPA or Hibernate 
references can have additional life-cycle semantics, which define what to do with 
referenced objects in certain circumstances. Therefore you typically make a distinction 
between the two concepts, as we do in the _Domain Model Example_ you can create using 
the wizard. However, in this small scenario we do not need a separation therefore we 
stick with one single concept for features.

p. As the type reference has an additional property for the multiplicity (many or one), 
we make it a separate model element and parser rule _TypeRef_. The presence of the 
postfix '*' in an input file should set the boolean flag to 'true' that indicates a multi-value
type reference in the AST model. 
This is the purpose of the assignment operator '_?=_'. The parser rule looks like this:

bc.. TypeRef :
  referenced=[Type] (multi?='*')?;

p. Again we have specified a cross-reference, which this time not only allows to 
reference entities but all instances of type. So far this only includes data type and entities, but 
you may want to introduce additional concepts in a future version, like for instance a 
Value Object as proposed in Eric Evan's great book _Domain Driven Design_.
  
p. In the end your grammar editor should look like this:

bc.. grammar org.eclipse.xtext.example.Domainmodel 
  with org.eclipse.xtext.common.Terminals
  
generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"  

DomainModel :
  (elements+=Type)*;
  
Type:
  DataType | Entity;
  
DataType:
  'datatype' name=ID;
 
Entity:
  'entity' name=ID ('extends' superType=[Entity])? '{'
    (features+=Feature)*
  '}';
 
Feature:
  name=ID ':' type=TypeRef;
  
TypeRef:
  referenced=[Type] (multi?='*')?;
  
h3. Generate Language Artifacts

Now that we have the grammar in place and defined we need to run the generator that will derive the
various language components. 
To do so locate the file _GenerateDomainmodel.mwe2_ file next to the grammar 
file in the package explorer view. From its context menu, choose

  _Run As -> MWE2 Workflow_.
  
That will trigger the Xtext language generator. It generates the parser and 
serializer and some additional infrastructure code. You will see its logging 
messages in the Console View. 

h3. Run the Generated IDE Plug-in

If the code generation succeeded, we are now able to test the IDE integration. 
Right-click on the Xtext project and choose
 
  _Run As -> Eclipse Application_.
  
This will spawn a new Eclipse workbench with your projects as plug-ins installed. 
In the new workbench, create a new project 
(_File -> New -> Project...  -> General -> Project_) and therein a new file 
with the file extension you chose in the beginning (_*.dmodel_). This will open
the generated entity editor. Try it a bit and discover the default 
functionality for code completion (_CTRL SPACE_ even for cross-references), 
syntax highlighting, syntactic validation, linking errors, outline, find
references etc.

!{width:50%}images/getting-started-editor.png!

h3. Adding a Namespace Concept

At the current stage, our language puts all types into the same scope. As 
cross-references are specified by means of names, this can easily yield collisions 
as the model size increases. Avoiding such name clashes is why most programming 
languages invent concepts like namespaces or modules. We will now introduce the 
concept of a _Package_, which effectively is a namespace. 

Our languages's definition of a _Package_ is as follows: A package has a name and 
contains other named elements and namespace-imports. A named element is either another 
_Package_ or a _Type_. Within a package, elements must have unique names. The 
_fully qualified name_ (FQN) of a named element consists of the FQN of its package, 
a separator '_._' and its own simple name. Elements refer to each other using their 
_qualified names_ which may be relative to their common namespaces or absolute. By means 
of import statements, these names can be further abbreviated. 

That might sound a bit complicated at first but the good thing is that Xtext 
comes with exactly such a default semantic for namespaces, which feels very 
natural in practice. Although all aspects of this semantic are adaptable, we 
will stick to the defaults within this tutorial.

Before we extend the grammar, let's have a look how an example model would
look like when using the newly introduced concepts:

bc.. package my.types {
  datatype String
  datatype Boolean
}

package my.entities {
  
  import my.types.*
  
  entity Session {
    title: String
    isTutorial : Boolean
  }

  entity Conference {
    name : String
    attendees : Person*
    speakers : Speaker*
  }

  entity Person {
    name : String
  }

  entity Speaker extends Person {
    sessions : Session*
  }
}

p. Let's start to modify our grammar now. First we introduce the rule _AbstractElement_:

bc.. AbstractElement:
  PackageDeclaration | Type;

p.  _DomainModel_ should now call _AbstractElement_ instead of _Type_:  
  
bc.. DomainModel:
  (elements+=AbstractElement)*;

p. To allow qualified names, we need a new rule _QualifiedName_. This rule 
returns a string. But we do not want this to be a _terminal rule_, as terminal 
rules have special semantics (they are used context-less in the lexer, which 
often causes problems). Instead we want it to be a parser rule, but one which
doesn't return an instance of an _EClass_ from the referenced _EPackage_ but 
just a plain String. Such rules are called _data type rules_, because they return 
instances of _EDataType_ as opposed to instances of _EClass_. String is the most 
often used _EDataType_ in this context and is therefore the default return 
type for data type rules. The rule looks like this:

bc.. QualifiedName:
  ID ('.' ID)*;

p. Note, that Xtext automatically figures out that the rule is a _data type rule_ 
rather then a normal parser rule, because it doesn't contain any assignments 
and all rule calls go to either other _data type rules_ or _terminal rules_. 
For a _data type rule_ the parser simply concatenates the consumed text and returns 
it as a string. The transformation to a user defined data type is done by so 
called "ValueConverters":#valueconverter. But as we use strings we don't need to care about 
_ValueConverters_ here.

Next up we need to define the syntax of _PackageDeclarations_, which makes use of 
the _QualifiedName_ rule but doesn't make use of anything we haven't yet talked about.

bc.. PackageDeclaration:
  'package' name=QualifiedName '{'
    (elements+=AbstractElement)*
  '}';
  
p. Having qualified names at hand, we want to specify cross-references that 
way, too. As mentioned by default, Xtext assumes the rule _ID_ as the syntax 
for cross-references, which has been fully sufficient so far. But now we want 
to allow fully qualified names as well, so we explicitly specify the syntax rule 
after a delimiter '_|_':

fn.. Note, that the '_|_' has nothing to do with the previously introduced 
alternative operator. In the context of a cross-reference it is simply a delimiter.  

bc.. Entity:
  'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'
    (features+=Feature)*
  '}';

p. and

bc.. TypeRef:
  referenced=[Type|QualifiedName] (multi?='*')?;

p. As the last step, we introduce imports. An _Import_ is an instance of 
_AbstractElement_, too, so that it can occur as a child of _DomainModel_ as 
well as of _PackageDeclaration_.

bc.. AbstractElement:
  PackageDeclaration | Type | Import;

p. An imported namespace is not just a qualified name but it also allows an 
optional wildcard character '_*_' at the end, so that multiple names can be 
imported with one statement. That requires a new data type rule which we 
name _QualifiedNameWithWildCard_:

bc.. QualifiedNameWithWildCard:
  QualifiedName '.*'?;

p. The declaration of the _Import_ rule should look familiar by now:

bc.. Import:
  'import' importedNamespace=QualifiedNameWithWildCard;

p. The default scoping implementation is based on naming conventions. First 
everything which has a name is referenceable. By default something has a name 
if it has a property _'name'_. If such an _EAttribute_ is available, the default 
implementation computes a qualified name by asking the container for its name 
and concatenates the two names separated by a dot. The computation of qualified
names can be arbitrarily changed by implementing an _IQualifedNameProvider_. 
The other naming convention is that if some element has an EAttribute 
'importedNamespace' that value is used as a namespace import and is automatically 
prefixed to any simple names used within that namespace. Also the asterisk '_*_' 
is used as a wildcard by default.

That's all for the grammar. It should now read as 

bc.. grammar org.eclipse.xtext.example.Domainmodel 
   with org.eclipse.xtext.common.Terminals

generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"

DomainModel:
  (elements+=AbstractElement)*;

AbstractElement:
  PackageDeclaration | Type | Import;
  
Import:
  'import' importedNamespace=QualifiedNameWithWildCard;

PackageDeclaration:
  'package' name=QualifiedName '{'
    (elements+=AbstractElement)*
  '}';

Type:
  Entity | DataType;

DataType:
  'datatype' name=ID;

Entity:
  'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'
    (features+=Feature)*
  '}';

Feature:
  name=ID ':' type=TypeRef;

TypeRef:
  referenced=[Type|QualifiedName] (multi?='*')?;

QualifiedName:
  ID ('.' ID)*;
  
QualifiedNameWithWildCard:
  QualifiedName '.*'?;

p. Now you should regenerate the language infrastructure as described in the 
previous section, and give the editor a try. You can even split up your model 
into smaller parts and have cross-references across file boundaries, as long 
as the referenced models are on the classpath.

h2(#processing_Xtext_models). Processing Xtext Models

p. Now that we know how to create a language we should talk about processing the parsed models somehow. 
There are typically two useful things one can do with
Xtext models: One is translating them to another programming language, i.e. writing a code generator, 
the other is loading them at runtime and use them
dynamically. We'll talk about code generation later. In this chapter we want to see how to interact with 
Xtext models programmatically. 

Text files parsed by Xtext are represented as object graphs in memory. We call these object graphs _Abstract Syntax Tree (AST)_, _semantic model_ or 
simply _model_ interchangeably. In Xtext models are implemented using the _Eclipse Modeling Framework (EMF)_, which can be seen as a very powerful version 
of JavaBeans. It not only provides the typical getter and setter methods for the different features of a model element but also comes with an long list of 
advanced concepts and semantics, which are extremely useful in the context of Xtext.

h3(#resource). Loading a _Resource_ 
  
EMF models can be persisted by the means of a so called _Resource_. Xtext languages implement the _Resource_ interface which is why you can use the EMF API to
load a model into memory (and also save them):

bc.. new DomainmodelStandaloneSetup().createInjectorAndDoEMFRegistration();

ResourceSet rs = new ResourceSetImpl();
Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), true);
EObject eobject = resource.getContents().get(0);
 
p. The first line initializes the language infrastructure to run in _standalone_ mode. That is EMF is designed to work in Eclipse and therefore makes use of 
Equinox extension points in order to register factories and the like. In a vanilla Java project there is no Equinox, hence we do the registration programmaticly.
The generated _MyLanguageStandaloneSetup_ class does just that. You don't have to do this kind of initialization when you run your plug-ins within Eclipse, since in that case 
the extension point declarations are used.

The other thing the _StandaloneSetup_ takes care of is creating a Guice _injector_. The use of Guice and Dependency Injection is explained "here":#dependencyInjection. 

Now that the language infrastructure is initialized and the different contributions to EMF are registered, we want to load a _Resource_. To do so we first create a 
_ResourceSet_, which as the name suggests represents a set of Resources. If one _Resource_ references another _Resource_, EMF will automatically load that other _Resource_
into the same _ResourceSet_ as soon as the cross-reference is resolved. Resolution of cross-references is done lazy, i.e. on first access.

The 4th line loads the _Resource_ using the resource set. We pass in a URI which points to the file in the file system. 
EMF's URI is a powerful concept. It supports a lot of different schemes to load resources from file system, web sites, jars, OSGi bundles or even 
from Java's classpath. And if that is not enough you can come up with your own schemes. Also a URI can not only point to a resource but also to any _EObject_ in a resource.
This is done by appending a so called _URI fragment_ to the URI. 

The second parameter denotes whether the resource should automatically be loaded if it wasn't already before. Alternatively we could have written

bc..  Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), false);
resource.load(null);

p. The load method optionally takes a map of properties, which allows to define a contract between a client and the specific implementation. In Xtext, for instance, we use 
the map to state whether cross-references should be eagerly resolved. In order to find out what properties are supported, it's usually best to look into 
the concrete implementations. That said, in most cases you don't need to pass any properties at all.

The last line 

bc.. EObject eobject = resource.getContents().get(0);

p. assigns the root element to a local variable.
Actually it is the first element from the contents list of a _Resource_, but in Xtext a _Resource_ always has just one root element.

h3(#programmatic_EMF). Working with EMF Models

p. We have previously talked about Ecore models, which effectively is an _EPackage_ containing a any number of _EClasses_ with _EAttributes_ and _EReferences_. 
Ecore defines additional concepts but they are not so important here. An _EObject_ is an instance of an _EClass_. For instance, the root element
of a domain model would be an instance of the EClass _DomainModel_, as defined in the grammar in the last chapter. EMF provides a reflection layer to work
with EObjects in a generic way. 

bc.. assertEquals("DomainModel", eobject.eClass().getName());
 
p. It is also possible to create new instances or get and set values using the reflection layer. That reflection layer is very helpful when creating generic 
libraries for EMF models, however if you know what kind of model you are working with it's much nicer to program against the generated Java classes. 
As we know that the root element is an instance of DomainModel we can just cast it to the Java interface generated by EMF:

bc.. DomainModel domainModel = (DomainModel) eobject;

p. The generated Java types provide getter and setter methods for each _EAttribute_ and _EReference_, so that you can easily navigate the model using Java:

bc.. EList<AbstractElement> elements = domainModel.getElements();
for (AbstractElement abstractElement : elements) {
  if (abstractElement instanceof Entity) {
    Entity entity = ((Entity)abstractElement);
    System.out.println("entity "
    	+ entity.getName()
    	+ " extends "
    	+ entity.getSuperType().getName());
  } else if (abstractElement instanceof PackageDeclaration) {
  	PackageDeclaration pkgDecl = (PackageDeclaration) abstractElement;
  	System.out.println("package "
    	+ pkgDecl.getName());
  }
}

p. Note that you'll find a lot of convenience API in EMF's _EcoreUtil_ and Xtext's ${org.eclipse.xtext/src/org.eclipse.xtext.EcoreUtil2}. 

h3(#node_model). Working with the Parse Tree (aka Node Model)

p. In many situations the information from the _AST_ is sufficient, but in some situations you need additional syntactical information. In Xtext not only
an _AST_ is constructed while parsing but also a so called _parse tree_, which contains all the textual information chunked in so called tokens. The _parse tree_, also 
called _node model_, consists of two different kinds of nodes. 

_LeafNodes_ as the name suggests represent the leafs of the parse tree. Each leaf node represents one 
token. If you go through all leaf nodes of a parse tree and concatenate all the tokens to one string, you'll end up with the whole textual representation 
of the model, including all hidden tokens such as whitespace and comments. The following code does exactly that:

bc.. CompositeNode node = NodeUtil.getNode(domainModel);
Iterable<AbstractNode> contents = NodeUtil.getAllContents(node);
StringBuffer text = new StringBuffer();
for (AbstractNode abstractNode : contents) {
  if (abstractNode instanceof LeafNode)
    text.append(((LeafNode)abstractNode).getText());
}
System.out.println(text);

p. In addition to the text _LeafNodes_ also hold information about the line, the offset and the length of that token.

The other node type is called _CompositeNode_ and is created for almost each grammar element. A composite node can contain other composite nodes and leaf nodes.
The super type of both node types is _AbstractNode_. One can find a couple of convenience methods in ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.NodeUtil} and ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.ParseTreeUtil}.

h3(#working_with_grammar_model). Working with the Grammar

p. Also the grammar is represented as an EMF model and can be used in Java. In fact each node of the _node model_ references
the element from the grammar which was responsible for parsing or lexing that node:

bc.. DomainModel domainModel = (DomainModel) eObject;
CompositeNode node = NodeUtil.getNode(domainModel);
ParserRule parserRule = (ParserRule) node.getGrammarElement();
assertEquals("DomainModel", parserRule.getName());

h3. Working with Live Models

p. In a running Xtext Workbench, there are a number of components which access the semantic model of an open editor, i.e. the parser, the linker, the validator, the outline, the index builder etc. While some of these components are executed by the display thread, others like the parser or the indexer use different concurrent threads to not deteriorate the editing experience. If you for example want to have a consistent outline of your model, it is essential to keep other threads from modifying the model while the outline component reads it.

p. Many of the prominent locations where users can hook in their own code in Xtext are already called from within a thread safe context, e.g. the API for "quick fixes":#quickfixes. Consequently, the following usually applies only if you add additional functionality on top of Xtext, e.g. custom UI actions.

p. Each ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.XtextEditor} uses an ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.IXtextDocument} to store its model. To avoid synchronization trouble, neither of them provides direct access to the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource} storing the semantic model. Instead, the _IXtextDocument_ has two methods _readOnly()_ and _modify()_. Both take an argument of type ${org.eclipse.xtext.util/src/org.eclipse.xtext.util.concurrent.IUnitOfWork}_(==&lt;T&gt;==, IXtextResource)_ which defines a method _==&lt;T&gt;== exec(IXtextResource)_ that contains what you want to do with the model and allows to deliver a result of arbitrary type.

So here is an example of safely reading a model:

bc.. IXtextDocument myDocument = ...;
String rootElementName =  myDocument.readOnly(
  new IUnitOfWork(){
    public String exec(IXtextResource resource) {
      MyType type = (MyType)resource.getContents().get(0);
      return myType.getName();
    }
  });

p. Direct write-access on the document is usually only performed inside the framework. If you want to change a document by means of its semantic model, you should rather use an ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IDocumentEditor} which uses the _modify()_ method internally but takes care of synchronizing the "node model":#node_model, too:

bc.. @Inject
private IDocumentEditor documentEditor;

public void setRootName(IXtextDocument myDocument,
                        final String newName) {
 documentEditor.process(
    new IUnitOfWork.Void() {
       public void process(IXtextResource resource) {
          MyType type = (MyType)resource.getContents().get(0);
          myType.setName(newName);
       }
    }, myDocument);
}

h3. Summary

p. Let's summarize what we have learned: An Xtext model is loaded by an EMF Resource. The main model is represented as an instance of so called _EClasses_ which are themselves
declared within Ecore models. A _parse tree_ is created as well, which effectively acts as a tracing model between the text, the _AST_ and the grammar. The following
diagram illustrates the four different kinds of models.

!{width:50%}images/xtext_data_structures.png!

 

h2(#getting-started-xpand). Writing a Code Generator

In the previous section we've seen how to process Xtext files in general (e.g. with Java). 
If you need late binding, loading models dynamically and interpreting them is a good idea. 
If you do not need late binding, code generation is a viable option which is widely used to make models executable. 

You could of course use Java to do the code generation, but unfortunately Java doesn't support this task very well.
Therefore we use a language specialized on code generation: M2T Xpand.

h3. Xpand and MWE2

Xpand is also part of Eclipse and ships with its own documentation, so we don't need to explain all the details here, but
rather want to point you to the existing documentation. Instead this chapter is about providing some information about how to
use Xtext and Xpand together. 
 
The other technology we are going to use here is the "Modeling Workflow Engine 2":#MWE2. It is used to describe the generation workflow,
that is how and which models should be loaded, how they should be validated post-processed and where and how code generation should take place.

This section is based on the "Getting Started":#getting-started-xtext section and uses the code generator project which is created by Xtext's project wizard.

h3. The Empty Generator Project

Previously when we created the projects to develop the domain model language, we had checked the option _Create a generator project_ in the wizard, which as 
a result created a third project for us in the workspace. If you've followed along you should have a project called 
'org.eclipse.xtext.example.domainmodel.generator' in your workspace. It should look like shown in the following screenshot:

!{width:50%}images/generator-project.png!

h3. Replacing the Example Model File (1)

The four files shown in the image above are very simple stubs generated for the 'Hello World'-language the wizard creates as a starting point. 
We'll have to adapt them to match the domain model language we have developed in the "getting started section":#getting-started-xtext. The first 
thing we should do is open up the example model file (1) and replace its contents with an instance of the domain model language. To do so 
copy and paste the following into the editor:

bc.. package java.lang {
  datatype String
  datatype Boolean
}

package my.entities {
  
  import java.lang.*
  
  entity Session {
    title: String
    isTutorial : Boolean
  }

  entity Conference {
    name : String
    attendees : Person*
    speakers : Speaker*
  }

  entity Person {
    name : String
  }

  entity Speaker extends Person {
    sessions : Session*
  }
} 

h3. The Modeling Workflow Engine File (2) 

As mentioned MWE2 is used to define and configure the generation process. Actually, it is much more general and can be useful for a lot of other things as well.
Let's have a look at the MWE2 file as generated by the wizard:

bc.. module workflow.DomainmodelGenerator

import org.eclipse.emf.mwe.utils.*

var targetDir = "src-gen"
var fileEncoding = "ISO-8859-1"
var modelPath = "src/model"

Workflow {

	component = org.eclipse.xtext.mwe.Reader {
		// lookup all resources on the classpath
		// useJavaClassPath = true

		// or define search scope explicitly
		path = modelPath

		// this class will be generated by the xtext generator 
		register = org.eclipse.xtext.example.DomainmodelStandaloneSetup {}
		load = {
			slot = "greetings"
			type = "Greeting"
		}
	}

	component = org.eclipse.xpand2.Generator {
		expand = "templates::Template::main FOREACH greetings"
		outlet = {
			path = targetDir
		}
		fileEncoding = fileEncoding
	}
}

p. The first line just declares a name for this workflow file. Any qualified Java identifier is allowed, but it should 
match the file name of the MWE2 file (and in future versions we might make this mandatory). It is followed by an _import_ statement.
MWE2 references Java classes and to make that convenient, you can specify imports after the module declaration. Next up we 
see a couple of _vars_ are declared. Such _vars_ can be overridden when invoking a workflow file. 

The important part is the _Workflow_ part. There we declare an instance of _org.eclipse.emf.mwe.utils.Workflow_ and add two instances to the _component_
property. The first one is a _Reader_ which is used to initialize Xtext languages, read in Xtext files, and fetch specific elements from those models in order to
make them available to following workflow components (such as the declared _Generator_). 

Xtext language initialization is done by specifying any number of ${org.eclipse.xtext/src/org.eclipse.xtext.ISetup} implementations. In our case the generated _DomainModelStandaloneSetup_ is
registered, which makes sure that the infrastructure of your domain model language is set up properly. If you have multiple languages just add additional assignments for each language.

You have to tell the _Reader_ which paths to scan for model files. In this particular case we just specified one path. Another convenient option is to reuse the Java classpath, as suggested in the comments.

The _load_ section specifies which elements to fetch from the loaded resources. In this case we state that we want all elements of type _Greeting_.
Note that this is completely file agnostic, it will provide you with all elements from all files the _Reader_ could find on the specified paths.
The slot name is the name by which other workflow components can access the stored elements.

The second workflow component is an instance of _org.eclipse.xpand2.Generator_, which is the MWE2 facade to the Xpand template language. 
The Xpand generator needs to know which template to invoke for which models. Qualified names in Xpand are separated by a double colon _'::'_. That
is the name _'templates::Template::main'_ points to the definition _main_ in the file _templates/Template.xpt_ on the Java classpath. The second part
_FOREACH greetings_ references the _greetings_ slot which has previously been populated by the reader component.

An _Outlet_ describes where to put the generated sources. In Xpand there is a file-statement which refers to outlets. If you only have one outlet 
you don't have to give it a name, but you need to declare where the root folder for that outlet can be found in the file system. I.e. you specifiy where the generated code should go.
Oulets allow you to specify a couple of other things as well. As MWE2 just instantiates Java objects, you can go to the Java code of _org.eclipse.xpand2.output.Outlet_
 in order to find out (see the adder and setter methods). 
about the different options.

Now that we understood the most important things in the workflow we have to adapt it to match our domain model language. We only have to change the type
which is used to fetch and filter the elements in the load section. We want to generate code for entities, therefore we change it to Entity. We should change the slot's 
name, too:

bc.. module workflow.DomainmodelGenerator

import org.eclipse.emf.mwe.utils.*

var targetDir = "src-gen"
var fileEncoding = "ISO-8859-1"
var modelPath = "src/model"

Workflow {

	component = org.eclipse.xtext.mwe.Reader {
		// lookup all resources on the classpath
		// useJavaClassPath = true

		// or define search scope explicitly
		path = modelPath

		// this class will be generated by the xtext generator 
		register = org.eclipse.xtext.example.DomainmodelStandaloneSetup {}
		load = {
			slot = "entities" //changed to entities
			type = "Entity"   //changed to Entity
		}
	}

	component = org.eclipse.xpand2.Generator {
		expand = "templates::Template::main FOREACH entities" //changed to entities
		outlet = {
			path = targetDir
		}
		fileEncoding = fileEncoding
	}
}

h3. Using Xpand (3) and Xtend (4) for Code Generation

The MWE2 file invokes an Xpand definition called _main_ located in _templates/Template.xpt_. 
Please open that file and replace its contents with the following Xpand code:

bc.. «IMPORT org::eclipse::xtext::example::domainmodel»
«EXTENSION templates::Extensions»

«DEFINE main FOR Entity-»
«FILE qualifiedName().replaceAll("\\.","/")+".java"-»
package «packageName()»;

public class «name» «IF superType != null» extends «superType.name»«ENDIF»{
{
  «EXPAND property FOREACH features»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE property FOR Feature»
  private «type.referenced.qualifiedName()» «name»;
  
  public void set«name.toFirstUpper()»(
       «type.referenced.qualifiedName()» «name») {
    this.«name» = «name»;
  } 
  public «type.referenced.qualifiedName()» get«name.toFirstUpper()»() {
    return «name»;
  } 
«ENDDEFINE»

p. You might get a couple of error markers, because the Xpand file references another file (_Extensions.ext_ (4)) which has not yet been updated. 
Let's ignore this for a moment and have a look at the general structure of an Xpand template file. In the first line we import the namespace (i.e. Java package)
of the generated AST classes, that is Entity and Feature, we want to refer to in the generator. Next up the previously mentioned Xtend file is imported. An Xtend file defines 
functions which can be used in Xpand. 

The rest of the file contains two so called definitions. A definition in Xpand is similar to a function in that it can be called, it has a name and it is defined
for one or more arguments. The general syntax is as follows:

bc..  «DEFINE name(ArgType1 arg1, ArgType2 arg2) FOR MainArgType»

p. Where _MainArgType_ is bound to the variable name _this_ which can like in Java be omitted when referring to.

The first definition _main_ is defined for _Entity_ and is the one invoked from the previously discussed MWE2 file (2). 
The first thing the definition does is opening a file using the _qualifiedName()_ of the given _Entity_. 
The function _qualifiedName()_ should be declared in the referenced Xtend file (4). To do so open that file and replace its
current contents by the following snippet:

bc.. import org::eclipse::xtext::example::domainmodel;

packageName(Type this) :
	qualifiedName(eContainer());
	
packageName(Void this) : null;
	
String qualifiedName(Object this) : null;
	
String qualifiedName(Type this) : 
	packageName()==null? name : packageName()+"."+name;
	
String qualifiedName(PackageDeclaration this) :
	if qualifiedName(eContainer())==null 
		then name
		else qualifiedName(eContainer())+'.'+name;
	
p. It defines the _qualifiedName()_ function not only for _Entity_ but also generally for types. Note how it computes the qualified name by calling
_qualifiedName()_ recursively on its _eContainer()_. Both Xpand and Xtend are based on the same expression language, which is statically typed and 
allows for very convenient navigation over object graphs and collections.

Back to the Xpand file (3) we see some static text which goes directly into the opened file. The _EXPAND_ statement calls the other definition defined in this file.
It will effectively generate a Java field and two accessor-methods for each _Feature_. 

You'll now able able to run the generator by opening the context menu on the _*.mwe2_ file (2) and choose _Run As->MWE2 Workflow_.
For more information on Xpand and Xtend see the corresponding language documentation (available through Eclipse Help). MWE2 is explained in detail 
in "a later section":#MWE2. 

h1(#grammarLanguage). The Grammar Language

The "grammar language":http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext?root=Modeling_Project&view=markup 
is the corner stone of Xtext. It is a domain-specific language, carefully designed for the description of textual languages.
The main idea is to describe the concrete syntax and how it is mapped to an in-memory model created during parsing. 

h2. A First Example

To get an idea of how it works we'll start by implementing a "simple example":http://martinfowler.com/dslwip/Intro.html 
introduced by Martin Fowler. It's mainly about describing state machines used as the (un)lock mechanism of secret compartments.
People who have secret compartments control their access in a very old-school way, e.g. by opening the door first and 
turning on the light afterwards. Then the secret compartment, for instance a panel, opens up. One of those state machines 
could look like this:

bc.. events
  doorClosed  D1CL
  drawOpened  D2OP
  lightOn     L1ON
  doorOpened  D1OP
  panelClosed PNCL
end
 
resetEvents
  doorOpened
end
 
commands
  unlockPanel PNUL
  lockPanel   PNLK
  lockDoor    D1LK
  unlockDoor  D1UL
end
 
state idle
  actions {unlockDoor lockPanel}
  doorClosed => active
end
 
state active
  drawOpened => waitingForLight
  lightOn    => waitingForDraw
end
 
state waitingForLight
  lightOn => unlockedPanel
end
 
state waitingForDraw
  drawOpened => unlockedPanel
end
 
state unlockedPanel
  actions {unlockPanel lockDoor}
  panelClosed => idle
end

p. So, we have a bunch of declared events, commands, and states. Within states there are references to declared actions,
which should be executed when entering such a state. Also there are transitions consisting of a reference to an event and 
a state. Please read "Martin's description":http://martinfowler.com/dslwip/Intro.html if you want to read the whole story.

In order to implment this little language with Xtext, you need to write the following grammar:

bc..  grammar my.pack.SecretCompartments 
   with org.eclipse.xtext.common.Terminals

generate secretcompartment "http://www.eclipse.org/secretcompartment"
 
Statemachine :
  'events'
     (events+=Event)+
  'end'
  ('resetEvents'
     (resetEvents+=[Event])+
  'end')?
  'commands'
     (commands+=Command)+
  'end'
  (states+=State)+;
 
Event :
  name=ID code=ID;
 
Command :
  name=ID code=ID;
 
State :
  'state' name=ID
     ('actions' '{' (actions+=[Command])+ '}')?
     (transitions+=Transition)*
  'end';
 
Transition :
  event=[Event] '=>' state=[State];
  
p. Martin uses this example throughout his book "Domain-Specific Languages" to implement external and internal DSLs using
different technologies. Note, that none of his implmentations is nearly as readable and concise as the description in
Xtext's grammar language above. That is of course because the grammar language is designed to do just that, i.e. it is 
specific to the domain of language descriptions.

h2(#syntax). The Syntax
  
p. In the following the different concepts and syntactical constructs of the grammar language are explained. 

h3. Language Declaration

The first line in every grammar ... 

bc. grammar my.pack.SecretCompartments with org.eclipse.xtext.common.Terminals

declares the name of the grammar. Xtext leverages Java's classpath mechanism. This means that the name 
can be any valid Java qualifier. The file name needs to correspond to the grammar name and have the file 
extension '_.xtext_'. This means that the name has to be _SecretCompartments.xtext_ and must be placed 
in a package _my.pack_ somewhere on your project's classpath.

The first line is also used to declare any used language (for mechanism details see "Grammar Mixins":#grammarMixins).

h3(#package_declarations). EPackage Declarations

Xtext parsers create in-memory object graphs while parsing text. Such object-graphs are 
instances of EMF Ecore models. An Ecore model basically consists of an _EPackage_ containing _EClasses_, 
_EDataTypes_ and _EEnums_ (See the "section on EMF":#model_metamodel for more details).
Xtext can infer Ecore models from a grammar (see "Ecore model inference":#metamodelInference) but it is also 
possible to reuse existing Ecore models. You can even mix this and use multiple existing Ecore models and 
infer some others from one grammar. 

h4. EPackage Generation

The easiest way to get started is to let Xtext infer the Ecore model from your grammar. This is what is done in the 
secret compartment example. To do so just state:

bc. generate secretcompartment 'http://www.eclipse.org/secretcompartment'

That statement means: generate an _EPackage_ with the _name_ "secretcompartment" and the _nsURI_ "http://www.eclipse.org/secretcompartment". 
Actually these are the properties that are required to create an _EPackage_.
Xtext will then add _EClasses_ with properties (_EAttributes_ and _EReferences_) for the different rules, as described in
"Ecore model inference":#metamodelInference. 

h4. EPackage Import

If you already have an existing _EPackage_, you can import it using either a namespace URI or a resource URI. 
An "URI":http://www.ietf.org/rfc/rfc2396.txt (Uniform Resource Identifier) provides a simple and extensible 
means for identifying an abstract or physical resource. For all the niftx details about EMF URIs 
please see its "documentation":http://help.eclipse.org/help32/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/common/util/URI.html.

h5. Using Resource URIs to Import Existing EPackages

In order to import an existing Ecore model, you'll have to have the *.ecore file describing the _EPackage_ you want to 
use somewhere in your workspace. In order to refer to that file you make use of the platform:/resource scheme.
Platform URIs are a special EMF concept, which allow to reference elements in the workspace 
independent of the location of the workspace. 

An import statement referring to an Ecore file by a _platform:/resource/_-URI looks like this: 

bc. import 'platform:/resource/my.project/src/my/pack/SecretCompartments.ecore'

If you want to mix generated and imported Ecore models you'll have to configure the generator fragment 
in your MWE file responsible for generating the Ecore classes 
(${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment}) 
with resource URIs that point to the "generator models":#emf_codegen of the referenced Ecore models.

The *.genmodel provides all kind of generator configuration used by EMF's code generator. Xtext will automatically create
a *.genmodel for generated ecore models, but if such a model references an existing imported Ecore model, the code generator 
needs to know how that code was generated in order to generate valid references in Java for the new Ecore model. 

Example:

bc.. fragment = org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment {
  genModels =
    "platform:/resource/my.project/src/my/pack/SecretCompartments.genmodel"
}

h5. Using Classpath URIs to Import Existing EPackages

We like to leverage Java's classpath mechanism, because besides that it is well understood and designed it allows us to
package libraries as jars. If you want to reference an *.ecore file which is contained in a jar, you can make use of the 
classpath scheme we've introduced. For instance if you want to reference Java elements, you can use the JvmType Ecore model 
which is shipped as part of Xtext. 

Example:

bc. import 'classpath:/model/JvmTypes.ecore' as types

p. As with platform resource URIs you'll also have to tell the generator where the corresponding *.genmodel can be found:

bc.. fragment = org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment {
  genModels =
    "classpath:/model/JvmTypes.genmodel"
}

p. See the section on "Referring Java Types":#jvmtypes for a full explanation of this useful feature.

h5. Using Namespace URIs to Import Existing EPackages

You can also use nsURI in order to import existing _EPackage_. Note that this is generally not
preferrable, because you'll have to have the corresponding EPackage installed in the workbench.
There's mainly just one exception, that is Ecore itself. So if you refer to Ecore it is best
to use its nsURI :

bc. import "http://www.eclipse.org/emf/2002/Ecore" as ecore

h4. Ecore Model Aliases for EPackages

If you want to use multiple _EPackages_ you need to specify aliases in the following way:

bc.. generate secretcompartment 'http://www.eclipse.org/secretcompartment'
import 'http://www.eclipse.org/anotherPackage' as another

p. When referring to a type somewhere in the grammar you need to qualify the reference using that 
alias (example _another::CoolType_). We'll see later where such type references occur.

It is also supported to put multiple _EPackage_ imports into one alias. This is no problem as 
long as there are not any two _EClassifiers_ with the same name. In such cases none of them can be referenced. 
It is even possible to _import_ multiple and _generate_ one Ecore model and all of them are declared for 
the same alias. If you do so, for a reference to an _EClassifier_ first the imported _EPackages_ are 
scanned before it is assumed that a type needs to by generated into the to-be-generated package. 

Note, that using this feature is not recommended, because it might cause problems, which are hard to track down.
For instance, a reference to _classA_ would as well be linked to a newly created _EClass_, because the 
corresponding type in _http://www.eclipse.org/packContainingClassA_ is spelled with a capital letter.

h3. Rules

Basically parsing can be separated in the following phases. 
# lexing
# parsing
# linking
# validation

h4. Terminal Rules

In the first stage called _lexing_, a sequence of characters (the text input) is transformed into a sequence of so 
called tokens. In this context, a token is sort of a strongly typed part of the input sequence. It consists of one 
or more characters and was matched by a particular terminal rule or keyword and therefore represents an atomic symbol.
Terminal rules are also referred to as _token rules_ or _lexer rules_. There is an informal naming convention that 
names of terminal rules are all upper-case.

In the secret compartments example there are no explicitly defined terminal rules, since it only uses the _ID_ rule 
which is inherited from the grammar _org.eclipse.xtext.common.Terminals_ (cf. "Grammar Mixins":#grammarMixins).
Therein the _ID_ rule is defined as follows:

bc.. terminal ID : 
  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 
    
p. It says that a token _ID_ starts with an optional _'^'_ character (caret), followed by a letter _('a'..'z'|'A'..'Z')_ 
or underscore ('_') followed by any number of letters, underscores and numbers _('0'..'9')_. 

The caret is used to escape an identifier for cases where there are conflicts with keywords. It is removed 
by the _ID_ rule's "ValueConverter":#valueconverter. 

This is the formal definition of terminal rules:

bc.. TerminalRule :
  'terminal' name=ID ('returns' type=TypeRef)? ':' 
    alternatives=TerminalAlternatives ';'
;

p. Note, that _the order of terminal rules is crucial for your grammar_, as they may hide each other. 
This is especially important for newly introduced rules in connection with mixed rules from used grammars. 

If you for instance want to add a rule to allow fully qualified names in addition to simple IDs, you should 
implement it as a "data type rule":#datatypeRules, instead of adding another terminal rule.

h5. Return Types

A terminal rule returns a value, which is a string (type _ecore::EString_) by default.
However, if you want to have a different type you can specify it. For instance, the rule _INT_ is defined as:

bc.. terminal INT returns ecore::EInt : 
  ('0'..'9')+;

p. This means that the terminal rule _INT_ returns instances of _ecore::EInt_. It is possible to define any 
kind of data type here, which just needs to be an instance of _ecore::EDataType_. In order to tell the parser 
how to convert the parsed string to a value of the declared data type, you need to provide your own 
implementation of ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.IValueConverterService} (cf. 
"value converters":#valueconverter). The value converter is also the point where you can remove things 
like quotes from string literals or the caret ('^') from identifiers. Its implementation needs to be registered 
as a service (cf. "Service Framework":#dependencyInjection).

h4. Extended Backus-Naur Form Expressions

Token rules are described using "Extended Backus-Naur Form"-like (EBNF) expressions. The different expressions 
are described in the following. The one thing all of these expressions have in common is the cardinality operator.
There are four different possible cardinalities
# exactly one (the default, no operator)
# one or none (operator _?_)
# any (zero or more, operator _*_)
# one or more (operator _+_)

h5(#Keywords). Keywords / Characters

Keywords are a kind of token rule literals. 
The _ID_ rule in _org.eclipse.xtext.common.Terminals_ for instance starts with a keyword:

bc. terminal ID : '^'? .... ;

The question mark sets the cardinality to "none or one" (i.e. optional) like explained above.

Note that a keyword can have any length and contain arbitrary characters. 

The following standard Java notations for special characters are allowed: _\n_, _\r_,
 _\t_, _\b_, and _\f_. We currently don't support quoted unicode character notation, as _\u123_.

h5. Character Ranges

A character range can be declared using the '..' operator.

Example:

bc. terminal INT returns ecore::EInt: ('0'..'9')+;

In this case an _INT_ is comprised of one or more (note the _+_ operator) characters 
between (and including) _'0'_ and _'9'_.

h5. Wildcard

If you want to allow any character you can simple write the wildcard operator '_._' (dot):
Example:

bc. FOO : 'f' . 'o';

The rule above would allow expressions like 'foo', 'f0o' or even 'f\no'.

h5. Until Token

With the until token it is possible to state that everything should be consumed until a certain token occurs.
The multi-line comment is implemented this way:

bc. terminal ML_COMMENT	: '/*' -> '*/';

This is the rule for Java-style comments that begin with '_/*_' and end with '_*/_'.

h5. Negated Token

All the tokens explained above can be inverted using a preceding exclamation mark:

bc. terminal BETWEEN_HASHES	: '#' (!'#')* '#';

h5. Rule Calls

Rules can refer to other rules. This is done by writing the name of the rule to be called.
We refer to this as rule calls. Rule calls in terminal rules can only point to terminal rules.

Example:

bc. terminal DOUBLE : INT '.' INT;

h5(#Alternatives). Alternatives 

Using alternatives one can state multiple different alternatives.
For instance, the whitespace rule uses alternatives like this:

bc. terminal WS : (' '|'\t'|'\r'|'\n')+;

That is a WS can be made of one or more whitespace characters (including ' ', '_\t_', '_\r_', '_\n_').

h5. Groups

Finally, if you put tokens one after another, the whole sequence is referred to as a group.
Example:

bc. terminal ASCII : '0x' ('0'..'7') ('0'..'9'|'A'..'F');

That is the 2-digit hexadecimal code of ASCII characters.

h3(#parser_rules). Parser Rules

The parser reads a sequence of terminals and walks through the parser rules. Hence a parser rule - 
contrary to a terminal rule - does not produce a single terminal token but a tree of non-terminal 
and terminal tokens. They lead to a so called "parse tree":#node_model (in Xtext it is also referred 
as node model). Furthermore, parser rules are handled as kind of a building plan for the creation of 
the _EObjects_ that form the semantic model (the linked abstract syntax graph or AST). Due to this 
fact, parser rules are even called production rules. The different constructs like actions and 
assignments are used to derive types and initialize the semantic objects accordingly. 

h4. Extended Backus-Naur Form Expressions

Not all the expressions that are available in terminal rules can be used in parser rules. Character 
ranges, wildcards, the until token and the negation are only available for terminal rules. 

The elements that are available in parser rules as well as in terminal rules are
# groups, 
# "alternatives":#Alternatives, 
# "keywords":#Keywords and 
# rule calls.

In addition to these elements, there are some expressions used to direct how the AST 
is constructed, which are listed and explained in the following.

h5(#assignments). Assignments 

Assignments are used to assign the parsed information to a feature of the current object. 
The type of the current object, its _EClass_, is specified by the return type of the parser 
rule. If it is not explicitly stated it is implied that the type's name equals the rule's name. 
The type of the feature is inferred from the right hand side of the assignment.

Example:

bc.. State :
  'state' name=ID
    ('actions' '{' (actions+=[Command])+ '}')?
    (transitions+=Transition)*
  'end'
;

p. The syntactic declaration for states in the state machine example starts with a keyword _state_ followed by an assignment:

bc. name=ID

The left hand side refers to a feature '_name_' of the current object (which has the _EClass_ '_State_' in this case). 
The right hand side can be a rule call, a keyword, a cross-reference (explained later) or even an 
alternative comprised by the former. The type of the feature needs to be compatible with the type of the
 expression on the right. As _ID_ returns an _EString_ in this case, the feature '_name_' needs to be 
 of type _EString_ as well.

*Assignment Operators*

There are three different assignment operators, each with different semantics.

# The simple equal sign '_=_' is the straight forward assignment, and used for features which take only one element.
# The '_+=_' sign (the add operator) expects a multi-valued feature and adds the value on the right hand to that feature, which is a list feature.
# The '_?=_' sign (boolean assignment operator) expects a feature of type _EBoolean_ and sets it to true if the right hand side was consumed independently from the concrete value of the right hand side.

The used assignment operator does not effect the cardinality of the expected symbols on the right hand side. 

h5. Cross-References 

A unique feature of Xtext is the ability to declare crosslinks in the grammar. In traditional compiler 
construction the crosslinks are not established during parsing but in a later linking phase. This is the 
same in Xtext, but we allow to specify crosslink information in the grammar. This information is used by the linker.
The syntax for crosslinks is:

bc.. CrossReference :
  '[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']'
;

p. For example, the transition is made up of two cross-references, pointing to an event and a state:

bc.. Transition :
  event=[Event] '=>' state=[State]
;

p. It is important to understand that the text between the square brackets does not refer to another rule, but to a type!
This is sometimes confusing, because one usually uses the same name for the rules and the returned types.
That is if we had named the type for events differently like in the following the cross-reference needs 
to be adapted as well:

bc.. Transition :
  event=[MyEvent] '=>' state=[State]
;
 
Event returns MyEvent : ....;

p. Looking at the syntax definition of cross-references, there is an optional part starting with a vertical 
bar (pipe) followed by _CrossReferenceableTerminal_. This is the part describing the concrete text, from 
which the crosslink later should be established. If the terminal is omitted, it is expected to be _ID_.

You may even use alternatives as the referencable terminal. This way, either an _ID_ or a _STRING_ may be 
used as the referencable terminal, as it is possible in many SQL dialects.

bc. TableRef: table=[Table|(ID|STRING)];

Have a look at the "linking section":#linking in order to understand how linking is done.

h5(#unordered_groups). Unordered Groups

The elements of an unordered group can occur in any order but each element must appear once. Unordered 
groups are separated with '_&_', e.g.

bc.. Modifier: 
	static?='static'? & final?='final'? & visibility=Visibility;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';
	
p. allows

bc.. public static final
static protected 
final private static
public

p. but not

bc.. static final static // ERROR: static appears twice
public static final private // ERROR: visibility appears twice
final // ERROR: visibility is missing

p. Note that if you want an element of an unordered group to appear once or not at all, 
you have to choose a cardinality of '_?_'. In the example, the visibility is mandatory, 
while '_static_' or '_final_' are optional. Elements with a cardinality of '_*_' or '_+_'
have to appear continuously without interruption, i.e.

bc.. Rule:
	values+=INT* & name=ID;

p. will parse

bc.. 0 8 15 x
x 0 8 15 

p. but not 

bc.. 0 x 8 15 // wrong, as values cannot be interrupted.

h5. Simple Actions 

By default the object to be returned by a parser rule is created lazily on the first assignment. Then the type of the _EObject_ to be created is determined from the specified return type or the rule name if no explicit return type is specified.
With Actions however, the creation of returned _EObject_ can be made explicit. Xtext supports two kinds of Actions:
# simple actions, and
# assigned actions.

If at some point you want to enforce the creation of a specific type you can use alternatives or simple actions.
In the following example _TypeB_ must be a subtype of _TypeA_. An expression _A ident_ should create an instance of 
_TypeA_, whereas _B ident_ should instantiate _TypeB_.

Example with alternatives:

bc.. MyRule returns TypeA :
  "A" name=ID |
  MyOtherRule
; 
 
MyOtherRule returns TypeB :
  "B" name = ID
;

p. Example with simple actions:  

bc.. MyRule returns TypeA :
  "A" name=ID |
  "B" {TypeB} name=ID
; 

p. Generally speaking, the instance is created as soon as the parser hits the first assignment. However, actions 
allow to explicitly instantiate any _EObject_. The notation _{TypeB}_ will create an instance of TypeB and assign 
it to the result of the parser rule. This allows parser rules without any assignment and object creation without 
the need to introduce unnecessary rules.

h5. Unassigned Rule Calls 

We previously explained, that the _EObject_ to be returned is created lazily when the first assignment occurs or 
when a simple action is evaluated. There is another way one can set the _EObject_ to be returned, which we call 
an "unassigned rule call".

Unassigned rule calls (the name suggests it) are rule calls to other parser rules, which are not used within an 
assignment. If there is no feature the returned value shall be assigned to, the value is assigned to the 
"to-be-returned" result of the calling rule.

With unassigned rule calls one can, for instance, create rules which just dispatch between several other rules:

bc.. AbstractToken :
  TokenA |
  TokenB |
  TokenC
;

p. As _AbstractToken_ could possibly return an instance of _TokenA_, _TokenB_ or _TokenC_ its type must by a 
super type of these types. It is now for instance as well possible to further change the state of the AST 
element by assigning additional things.

Example:

bc.. AbstractToken :
  ( TokenA |
    TokenB |
    TokenC ) (cardinality=('?'|'+'|'*'))?
;

p. This way the _cardinality_ is optional (last question mark) and can be represented 
by a question mark, a plus, or an asterisk. It will be assigned to either an 
_EObject_ of type _TokenA_,  _TokenB_, or _TokenC_ which are all subtypes of 
_AbstractToken_. The rule in this example will never create an instance of _AbstractToken_ directly 
as long as the preceeding _TokenX_ rule call returns an element. 

h5(#grammarActions). Assigned Actions 

LL-parsing has some significant advantages over LR algorithms. The most important ones for Xtext are, that the generated code is much simpler to understand and debug and that it is easier to recover from errors. Especially ANTLR has a very nice generic error recovery mechanism. This allows to construct an AST even if there are syntactic errors in the text. You wouldn't get any of the nice IDE features as soon as there is one little error, if we hadn't error recovery.

However, LL also has some drawbacks. The most important one is that it does not allow left recursive grammars.
For instance, the following is not allowed in LL-based grammars, because _Expression '+' Expression_ is left recursive:

bc.. Expression :
  Expression '+' Expression |
  '(' Expression ')' |
  INT
;

p. Instead one has to rewrite such things by "left-factoring" it:

bc.. Expression :
  TerminalExpression ('+' TerminalExpression)?
;
 
TerminalExpression :
  '(' Expression ')' |
  INT
;

p. In practice this is always the same pattern and therefore not that problematic. 
However, by simply applying the Xtext AST construction features we've covered so far, a grammar ...

bc.. Expression :
  {Operation} left=TerminalExpression (op='+' right=TerminalExpression)?
;
 
TerminalExpression returns Expression:
  '(' Expression ')' |
  {IntLiteral} value=INT
;

p. ... would result in unwanted elements in the AST.
For instance the expression _(42)_ would result in a tree like this:

bc.. Operation {
  left=Operation {
    left=IntLiteral {
      value=42
    }
  }
}

p. Typically one would only want to have one instance of _IntLiteral_ instead.

One can solve this problem using a combination of unassigned rule calls and assigned actions:

bc.. Expression :
  TerminalExpression ({Operation.left=current} 
    op='+' right=Expression)?
;
 
TerminalExpression returns Expression:
  '(' Expression ')' |
  {IntLiteral} value=INT
;

p. In the example above _{Operation.left=current}_ is a so called tree rewrite action, which creates a new instance of the stated _EClass_ (_Operation_ in this case) and assigns the element currently to-be-returned (_current_ variable) to a feature of the newly created object (in this case feature _left_ of the _Operation_ instance).
In Java these semantics could be expressed as:

bc.. Operation temp = new Operation();
temp.setLeft(current);
current = temp;

h3(#hidden_terminals). Hidden Terminal Symbols

Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the interesting parts of the input. Xtext introduces the concept of hidden tokens to handle semantically unimportant things like whitespaces, comments, etc. in the input sequence gracefully. It is possible to define a set of terminal symbols, that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model. 

Hidden terminals may (or may not) appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When "reusing a single grammar":#grammarMixins its definition of hidden tokens is reused as well. The grammar _org.eclipse.xtext.common.Terminals_ comes with a reasonable default and hides all comments and whitespace from the parser rules.

If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called from the declaring rule uses the same hidden terminals as the calling rule, unless it defines other hidden tokens itself.
  
bc.. Person hidden(WS, ML_COMMENT, SL_COMMENT): 
  name=Fullname age=INT ';'
;

Fullname: 
  (firstname=ID)? lastname=ID
;

p. The sample rule "Person" defines multiline comments (_ML_COMMENT_), single-line comments (_SL_COMMENT_), and whitespace (_WS_) to be allowed between the _Fullname_ and the _age_. Because the rule _Fullname_ does not introduce another set of hidden terminals, it allows the same symbols to appear between _firstname_ and _lastname_ as the calling rule _Person_. Thus, the following input is perfectly valid for the given grammar snippet:

bc.. John /* comment */ Smith // line comment
/* comment */
      42      ; // line comment

p. A list of all default terminals like _WS_ can be found in section "Grammar Mixins":#grammarMixins.

h3(#datatypeRules). Data Type Rules

Data type rules are parsing-phase rules, which create instances of _EDataType_ instead of _EClass_. Thinking about it, one may discover that they are quite similar to terminal rules.
However, the nice thing about data type rules is that they are actually parser rules and are therefore 

# context sensitive and 
# allow for use of hidden tokens.

If you, for instance, want to define a rule to consume Java-like qualified names (e.g. "foo.bar.Baz")
you could write:

bc.. QualifiedName :
  ID ('.' ID)*
;

p. In contrast to a terminal rule this is only valid in certain contexts, i.e. it won't conflict with the rule _ID_.
If you had defined it as a terminal rule, it would possibly hide the _ID_ rule.

In addition when this has been defined as a data type rule, it is allowed to use hidden tokens (e.g. "/* comment **/") between the IDs and dots (e.g. _foo/* comment */. bar . Baz_).

Return types can be specified in the same way as in terminal rules:

bc.. QualifiedName returns ecore::EString : 
  ID ('.' ID)*
;

p. Note that if a rule does not call another parser rule and does neither contain any actions nor "assignments":#assignments, it is considered to be a data type rule and the data type _EString_ is implied if none has been explicitly declared. You have to import Ecore with the alias _ecore_ in this case.

For conversion again value converters are responsible (cf. "value converters":#valueconverter).

h3. Enum Rules

Enum rules return enumeration literals from strings. They can be seen as a shortcut for data type rules with specific value converters.
The main advantage of enum rules is their simplicity, type safety and therefore nice validation. Furthermore it is possible to infer enums and their respective literals during the Ecore model transformation.

If you want to define a _ChangeKind_ "org.eclipse.emf.ecore.change/model/Change.ecore":http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/change/impl/package-summary.html with _ADD_, _MOVE_ and _REMOVE_ you could write:

bc.. enum ChangeKind :
  ADD | MOVE | REMOVE
;

p. It is even possible to use alternative literals for your enums or reference an enum value twice:

bc.. enum ChangeKind :
  ADD = 'add' | ADD = '+' | 
  MOVE = 'move' | MOVE = '->' | 
  REMOVE = 'remove' | REMOVE = '-'
;

p. Please note, that Ecore does not support unset values for enums. If you formulate a grammar like

bc. Element: "element" name=ID (value=SomeEnum)?;

p. with the input of

bc. element Foo

the resulting value of the element _Foo_ will hold the enum value with the internal representation of '0' (zero). When generating the _EPackage_ from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation.

bc.. enum Visibility: 
  package | private | protected | public
;
 
p. You can overcome this by modifying the infered Ecore model through a "model to model transformation":#customPostProcessing.

h2(#metamodelInference). Ecore Model Inference

The Ecore model (or meta model) of a textual language describes the structure of its abstract syntax trees (AST). 

Xtext uses Ecore's _EPackages_ to define Ecore models. Ecore models are declared to be either inferred (generated) from the grammar or imported. 
By using the _generate_ directive, one tells Xtext to derive an _EPackage_ from the grammar. 

h3. Type and Package Generation

Xtext creates

* an _EPackage_
** for each generate-package declaration. After the directive _generate_ a list of parameters follows. The _name_ of the _EPackage_ will be set to the first parameter, its _nsURI_ to the second parameter. An optional alias as the third parameter allows to distinguish generated _EPackages_ later. Only one generated package declaration per alias is allowed.
* an _EClass_
** for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name as the rule itself is assumed. You can specify more than one rule that return the same type but only one _EClass_ will be generated.
** for each type defined in an action or a cross-reference.
* an _EEnum_
** for each return type of an enum rule.
* an _EDataType_
** for each return type of a terminal rule or a data type rule.

All _EClasses_, _EEnums_, and _EDataTypes_ are added to the _EPackage_ referred to by the alias provided in the type reference they were created from.

h3. Feature and Type Hierarchy Generation

While walking through the grammar, the algorithm keeps track of a set of the currently possible return types to add features to. 
* Entering a parser rule the set contains only the return type of the rule. 
* Entering a group in an alternative the set is reset to the same state it was in when entering the first group of this alternative. 
* Leaving an alternative the set contains the union of all types at the end of each of its groups.
* After an optional element, the set is reset to the same state it was before entering it. 
* After a mandatory (non-optional) rule call or mandatory action the set contains only the return type of the called rule or action. 
* An optional rule call does not modify the set.
* A rule call is optional, if its cardinality is '_?_' or '_*_'.

While iterating the parser rules Xtext creates
* an _EAttribute_ in each current return type
** of type _EBoolean_ for each feature assignment using the '_?=_' operator. No further _EReferences_ or _EAttributes_ will be generated from this assignment.
** for each assignment with the '_=_' or '_+=_' operator calling a terminal rule. Its type will be the return type of the called rule.
* an _EReference_ in each current return type
** for each assignment with the '_=_' or '_+=_' operator in a parser rule calling a parser rule. The _EReference_'s type will be the return type of the called parser rule.
** for each assigned action. The reference's type will be set to the return type of the current calling rule. 

Each _EAttribute_ or _EReference_ takes its name from the assignment or action that caused it. Multiplicities will be 0...1 for assignments with the '_=_' operator and 0...* for assignments with the '_+=_' operator. 

Furthermore, each type that is added to the currently possible return types automatically extends the current return type of the parser rule. You can specify additional common super types by means of "artificial" parser rules, that are never called, e.g.

bc.. CommonSuperType:
  SubTypeA | SubTypeB | SubTypeC;

h3. Enum Literal Generation

For each alternative defined in an enum rule, the transformer creates an enum literal, when another literal with the same name cannot be found. The _literal_ property of the generated enum literal is set to the right hand side of the declaration. If it is omitted, you will get an enum literal with equal _name_ and _literal_ attributes.

bc.. enum MyGeneratedEnum:
  NAME = 'literal' | EQUAL_NAME_AND_LITERAL;

h3. Feature Normalization

In the next step the generator examines all generated _EClasses_ and lifts up similar features to super types if there is more than one subtype and the feature is defined in every subtypes. This does even work for multiple super types.

h3(#customPostProcessing). Customized Post Processing

As a last step, the generator invokes the post processor for every generated Ecore model. The post processor expects an Xtend file with name _MyDslPostProcessor.ext_ (if the name of the grammar file is _MyDsl.xtext_) in the same folder as the grammar file. Further, for a successful invocation, the Xtend file must declare an extension with signature _process(xtext::GeneratedMetamodel)_. E.g.

bc.. process(xtext::GeneratedMetamodel this) :
  process(ePackage)
;
 
process(ecore::EPackage this) :
  ... do something
;

p. The invoked extension can then augment the generated Ecore model in place. Some typical use cases are to:
* set default values for attributes,
* add container references as opposites of existing containment references, or
* add operations with implementation using a body annotation.

Great care must be taken to not modify the Ecore model in a way preventing the Xtext parser from working correctly (e.g. removing or renaming model elements).

h3. Error Conditions

The following conditions cause an error
* An _EAttribute_ or _EReference_ has two different types or different cardinality.
* There is an _EAttribute_ and an _EReference_ with the same name in the same _EClass_.
* There is a cycle in the type hierarchy.
* An new _EAttribute_, _EReference_ or super type is added to an imported type.
* An _EClass_ is added to an imported _EPackage_.
* An undeclared alias is used. 
* An imported Ecore model cannot be loaded.

h2(#grammarMixins). Grammar Mixins

Xtext supports the reuse of existing grammars. Grammars that are created via the Xtext wizard use _org.eclipse.xtext.common.Terminals_ by default which introduces a common set of terminal rules and defines reasonable defaults for hidden terminals.

bc.. grammar org.xtext.example.MyDsl with org.eclipse.xtext.common.Terminals
 
generate myDsl 'http://www.xtext.org/example/MyDsl'
 
... some rules

p. Mixing in another grammar makes the rules defined in that grammar referable. It is also possible to overwrite rules from the used grammar. 

Example :

bc.. grammar my.SuperGrammar
...
RuleA : "a" stuff=RuleB;
RuleB : "{" name=ID "}";

grammar my.SubGrammar with my.SuperGrammar

Model : (ruleAs+=RuleA)*;

// overrides my.SuperGrammar.RuleB
RuleB : '[' name=ID ']';

p. Note that declared terminal rules always get a higher priority then imported terminal rules.

h2. Common Terminals

Xtext ships with a default set of predefined, reasonable and often required terminal rules. This grammar is defined as follows:

bc..  grammar org.eclipse.xtext.common.Terminals 
  hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

terminal ID : 
  '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;
terminal INT returns ecore::EInt: ('0'..'9')+ ;
terminal STRING	: 
  '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
  "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"; 
terminal ML_COMMENT	: '/*' -> '*/' ;
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS		: (' '|'\t'|'\r'|'\n')+ ;
terminal ANY_OTHER:	. ;

h1(#configuration). Configuration

h2(#generator). The Generator

Xtext provides lots of generic implementations for your language's
infrastructure but also uses code generation to generate some of the 
components. Those generated components are for instance the parser, the 
serializer, the inferred Ecore model (if any) and a couple of convenient base classes for 
content assist, etc.

The generator also contributes to shared project resources such as the 
_plugin.xml_, _MANIFEST.MF_ and the "Guice modules":#guicemodules.

Xtext's generator leverages "MWE2 - the modeling workflow engine":#MWE2 
from EMFT to configure the generator.

h3(#short_intro_to_mwe). A Short Introduction to MWE2

MWE2 allows to compose object graphs declaratively in a very compact manner. The nice thing about it is that it just 
instantiates Java classes and the configuration is done through public setter and adder methods as one is used to 
from Java Beans encapsulation principles. An in-depth documentation can be found in the chapter "MWE2":#MWE2.

Given the following simple Java class (POJO):

bc.. package com.mycompany;
  
public class Person {
     
  private String name;
     
  public void setName(String name) { 
    this.name = name;
  }
     
  private final List<Person> children = new ArrayList<Person>();
     
  public void addChild(Person child) {
    this.children.add(child);
  }
}
  
p. One can create a family tree with MWE2 easily by describing it in a declarative manner 
without writing a single line of Java code and without the need to compile classes:

bc.. module com.mycompany.CreatePersons

Person {
	name = "Grandpa"
	child = {
		name = "Father"
		child = {
			name = "Son"
		}
	}
}

p. These couple of lines will, when interpreted by MWE2, result in an 
object tree consisting of three instances of _com.mycompany.Person_.
The interpreter will basically do the same as the following _main_ method: 

bc.. package com.mycompany;

public class CreatePersons {
	public static void main(String[] args) {
		Person grandpa = new Person();
		grandpa.setName("Grandpa");
		Person father = new Person();
		father.setName("Father");
		grandpa.addChild(father);
		Person son = new Person();
		son.setName("Son");
		father.addChild(son);
	}
}

p. !{width:50%}images/family_tree.png! 

p. The root element is a class-name following the Java classpath visibility rules. As the module is a sibling to the class
_com.mycompany.Person_ it is not necessary to use use fully qualified name. There are other packages implicitly imported
into this workflow as well to make it convenient to instantiate actual workflows and components, but these ones are covered 
in depth in the appropriate "chapter":#MWE2. The constructed objects are furthermore configured according to the declaration 
in the module, e.g. a second instance of Person will be created and added to the list of children of "Grandpa" while the third 
person - the class is inferred from the assigned feature - becomes a child of "Father". All three instances will have 
their respective _name_ assigned via a reflective invocation _setName_. If one wants to add another child to "Father", she
can simply repeat the child assignment:

bc.. child = com.mycompany.Person {
	name = "Father"
	child = {
		name = "Son"
	}
	child = {
		name = "Daughter"
	}
}

p. As you can see in the example above MWE2 can be used to instantiate arbitrary Java object models without any dependency or
limitation to MWE2 specific implementations. This is conceptually very close to the dependency injection mechanism and 
the XML language in the "Spring Framework":http://www.springframework.org. 

*Tip*
__Whenever you are in an *.mwe2 file and wonder what kind of configuration the underlying component may accept:__
__Just use the Content Assist in the MWE2 Editor or navigate directly to the declaration of the underlying Java__ 
__implementation by means of F3 (Go To Declaration).__

This is the basic idea of the MWE2 language. There are of course a couple of additional concepts and features in the 
language and we also have not yet talked about the runtime workflow model. Please refer to the dedicated MWE2 
"reference documentation":#MWE2 for additional information.

h3. General Architecture 

Of course a generator in Xtext is not composed of fathers and sons, but of so called language configurations. 
For each language configuration a URI pointing to 
its grammar file and the file extensions for the DSL must be provided. 
In addition, a language is configured with a list of 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.IGeneratorFragment}s.
The whole generator is composed of theses fragments. We have fragments for generating parsers, the serializer, the EMF code, 
the outline view, etc. 

!{width:50%}images/generator-structure.png!

h4(#generator_fragment). Generator Fragments

Each fragment gets the grammar of the language as an EMF model passed in. A fragment is able to generate code in one 
of the configured locations and contribute to several shared artifacts. The main interface 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.IGeneratorFragment} is supported by a convenient 
abstract base class ${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.AbstractGeneratorFragment}, which 
by default delegates to an Xpand template with the same qualified name as the class and delegates some of the 
calls to Xpand template definitions.

We suggest to have a look at the fragment we have written for label providers (${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.labeling.LabelProviderFragment}). It is pretty trivial and at the same time uses the most important call backs. In addition, the structure is not cluttered with too much extra noise so that the whole package can serve as a template to write your own fragment.

h4. Configuration
 
As already explained we use MWE2 from EMFT in order to instantiate, configure and execute this structure of components. 
In the following we see an exemplary Xtext generator configuration written in MWE2 configuration code:  

bc.. module org.xtext.example.MyDsl

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.generator.*
import org.eclipse.xtext.ui.generator.*

var grammarURI = "classpath:/org/xtext/example/MyDsl.xtext"
var file.extensions = "mydsl"
var projectName = "org.xtext.example.mydsl"
var runtimeProject = "../${projectName}"

Workflow {
	bean = StandaloneSetup {
		platformUri = "${runtimeProject}/.."
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}/src-gen"
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}.ui/src-gen"
	}

	component = Generator {
		pathRtProject = runtimeProject
		pathUiProject = "${runtimeProject}.ui"
		projectNameRt = projectName
		projectNameUi = "${projectName}.ui"

		language = {
			uri = grammarURI
			fileExtensions = file.extensions

			// Java API to access grammar elements
			fragment = grammarAccess.GrammarAccessFragment {}

			/* more fragments to configure the language */
			...
		}
	}
}

p. Here the root element is _Workflow_ and is part of the very slim runtime model shipped with MWE2. It accepts 
__bean__ s and __component__ s. The _var_ declaration is a first class concept of MWE2's configuration language 
and defines the interface of the module. They allow to externalize some common configuration parameters. This 
comes especially handy in String variables where one can easily use _${variable}_ to concatenate values. 

The method _Workflow.addBean(Object)_ does nothing but provides a means to apply global side-effects, which 
unfortunately is required sometimes. In this example we do a so called __EMF stand-alone setup__. This class 
initializes a bunch of things for a non-OSGi environment that are otherwise configured by means of extension points, 
e.g. it allows to populate EMF's singletons like the _EPackage.Registry_.

Following the _bean_ assignment there are three _component_ elements. The _Workflow.addComponent()_ method 
accepts instances of _IWorkflowComponent_, which is the primary concept of MWE2's workflow model. Xtext's generator 
itself is an instance of _IWorkflowComponent_ and can therefore be used within MWE2 workflows. 

There are two fragments ${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.ImplicitRuntimeFragment} and 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.ImplicitUiFragment} will be called implicitly if 
the required paths and project names are set. They take care of common defaults.  

h3. Standard Generator Fragments

In the following table the most important standard generator fragments are listed. Please refer to the Javadocs for more detailed documentation.

|_.Class|_.Generated Artifacts|_.Related Documentation|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment}|EMF code for generated models|"Model inference":#metamodelInference|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment}|ANTLR grammar, parser, lexer and related services| |
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.grammarAccess.GrammarAccessFragment}|Access to the grammar| |
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.resourceFactory.ResourceFactoryFragment}|EMF resource factory| "Xtext Resource":#xtext_resource|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.parseTreeConstructor.ParseTreeConstructorFragment}|Model-to-text serialization|"Serialization":#serialization|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.scoping.ImportNamespacesScopingFragment}|Index-based scoping|"Index-based namespace scoping":#index_based|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.validation.JavaValidatorFragment}|Model validation|"Model validation":#custom_validation|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.formatting.FormatterFragment}|Code formatter|"Declarative formatter":#declarativeformatter|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.labeling.LabelProviderFragment}|Label provider|"Label provider":#labelProvider|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.outline.OutlineNodeAdapterFactoryFragment}|Outline view configuration|"Outline":#outline|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.outline.TransformerFragment}|Outline view configuration|"Outline":#outline|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.contentAssist.JavaBasedContentAssistFragment}| Java-based content assist|"Content assist":#contentAssist|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.parser.antlr.XtextAntlrUiGeneratorFragment}|Content assist helper based on ANTLR|"Content assist":#contentAssist|
|${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.projectWizard.SimpleProjectWizardFragment}|New project wizard|"Project wizard":#projectwizard|







h2(#dependencyInjection). Dependency Injection in Xtext with Google Guice

All Xtext components are assembled by means of Dependency Injection (DI). This means basically that whenever some code is in need for functionality (or state) 
from another component, one just declares the dependency rather then stating how to resolve it, i.e. obtaining that component.

For instance when some code wants to use a scope provider, it just declares a field (or method or constructor) and 
adds the @Inject annotation: 

bc.. 
public class MyLanguageLinker extends Linker {

  @Inject
  private IScopeProvider scopeProvider;

}
 
p. It is not the duty of the code to care about where the _IScopeProvider_ comes from or how it is created. When above's
class is instantiated, Guice sees that it requires an instance of IScopeProvider and assigns it to the specified field or method parameter.
This of course only works, if the object itself is created by Guice. In Xtext almost every instance is created that way 
and therefore the whole dependency net is controlled and configured by the means of Google Guice.

Guice of course needs to know how to instantiate real objects for declared dependencies. This is done in so called _Modules_.
A _Module_ defines a set of mappings from types to either existing instances, instance providers or concrete
classes. Modules are implemented in Java. Here's an example:

bc.. public class MyDslRuntimeModule extends AbstractMyDslRuntimeModule {
	@Override
	public void configure(Binder binder) {
		super.configure(binder);
		binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);
	}
}

p. With plain Guice modules one implements a method called configure and gets a so called _Binder_ passed in.
That binder provides a fluent API to define the mentioned mappings. This was just a very brief and simplified description.
We highly recommend to have a look at "the website Google Guice":http://code.google.com/p/google-guice/ to learn more.  

h3(#guicemodules). The Module API

p. Xtext comes with a slightly enhanced module API. For your language you get two different modules: One for the runtime bundle
which is used when executing your language infrastructure outside of Eclipse such as on the build server. The other is
located in the UI bundle and adds or overrides bindings when Xtext is used within an Eclipse environment. 

The enhancement we added to Guice's Module API is that we provide an abstract base class, which reflectively looks for certain 
methods in order to find declared bindings. The most common kind of method is :

bc.. public Class<? extends IScopeProvider> bindIScopeProvider() {
	return MyConcreteScopeProvider.class;
}

p. which would do the same as the code snippet above. It simply declares a binding from _IScopeProvider_ to _MyConcreteScopeProvider_.
That binding will make Guice instantiate and inject a new instance of _MyConcreteScopeProvider_ whenever a dependency 
to _IScopeProvider_ is declared.

Having a method per binding allows to deactivate individual bindings by overriding the corresponding methods and either change 
the binding by returning a different target type or removing that binding completely by returning null.

There are two additional kinds of binding-methods supported. The first one allows to configure a provider. A _Provider_ is
an interface with just one method : 

bc.. public interface Provider<T> {

  /**
   * Provides an instance of {@code T}. Must never return {@code null}.
   */
  T get();
}

p. This one can be used if you need a hook whenever an instance of a certain type is created. For instance if you want to 
provide lazy access to a singleton or you need to do some computation each time an instance is created (i.e. factory). If you want 
to point to a provider rather than to a concrete class you can use the following binding method.

bc.. public Class<? extends Provider<IScopeProvider>> provideIScopeProvider() {
	return MyConcreteScopeProviderFactory.class;
}

p. __(Please forgive us the overuse of the term__ provider. __The IScopeProvider is not a Guice__ provider __.)__

p. That binding tells Guice to instantiate _MyConcreteScopeProviderFactory_ and invoke get() in order to obtain an instance of 
_IScopeProvider_ 
for clients having declared a dependency to that type. Both mentioned methods are allowed to return an instance instead of a type. This
may be useful if some global state should be shared in the application:

bc.. public Provider<IScopeProvider> provideIScopeProvider() {
	return new MyConcreteScopeProviderFactory();
}

p. or

bc.. public IScopeProvider bindIScopeProvider() {
	return new MyConcreteScopeProvider();
}

p. respectively.

p. The last binding method provided by Xtext allows to do anything you can do with Guice's binding API, since it allows you to 
use it directly. If your method's name starts with the name 'configure', has a return type _void_ and accepts one argument of 
type _Binder_

bc.. public void configureIScopeProvider(Binder binder) {
	binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);
} 

h3. Obtaining an _Injector_

p. In every application wired up with Guice there is usually one point where you initialize a so called _Injector_ using the 
modules declared and after that using that injector to create the root instance of the whole application. In plain Java environments
this is something that's done in the main method. It could look like this:

bc.. public static void main(String[] args) {
	Injector injector = Guice.createInjector(new MyDslRuntimeModule());
	MyApplication application = injector.getInstance(MyApplication.class);
	application.run();
}

p. Xtext uses EMF which makes use of a couple of global registries, which have to be configured on startup. Because we
of course want to leverage Guice also for all factories, etc. that we put into those registries, we have introduced a so called
_ISetup_ which provides a method called _Injector createInjectorAndDoEMFRegistration()_. So instead of using the plain Guice
code shown above you rather use the _ISetup_ class generated for your language, which, as the method name suggests, creates
an _Injector_ and uses it to initialize a couple of EMF objects and register them in the corresponding registries.
 
bc.. Injector injector = 
    new MyStandaloneSetup().createInjectorAndDoEMFRegistration(); 

p. These are the basic ideas around Guice and the small extension Xtext provides on top. For more information we 
strongly encourage you to read through the documentation on "the website of Google Guice":http://code.google.com/p/google-guice/.

h1(#runtime_concepts). Runtime Concepts

Xtext itself and every language infrastructure developed with Xtext is configured and wired-up using 
"dependency injection":#dependencyInjection. Xtext may be used in different environments which introduce 
different constraints. Especially important is the difference between OSGi managed containers and plain 
vanilla Java programs. To honor these differences Xtext uses the concept of 
${org.eclipse.xtext/src/org.eclipse.xtext.ISetup}-implementations in normal mode and uses Eclipse's 
extension mechanism when it should be configured in an OSGi environment.   

h2. Runtime Setup (ISetup)

For each language there is an implementation of ${org.eclipse.xtext/src/org.eclipse.xtext.ISetup} 
generated. It implements a method called _createInjectorAndDoEMFRegistration()_, which can be called 
to do the initialization of the language infrastructure. This class is intended to be used for 
runtime and for unit testing, only.

The setup method returns an _Injector_, which can further be used to obtain a parser, etc. It also 
registers the ResourceFactory and generated _EPackages_ at the respective global registries provided 
by EMF. So basically you can just run the setup and start using EMF API to load and store models of 
your language.

h2. Setup within Eclipse-Equinox (OSGi)

Within Eclipse we have a generated _Activator_, which creates a Guice injector using the "modules":#guicemodules.
In addition an _IExecutableExtensionFactory_ is generated for each language, which is used to create _ExecutableExtensions_.
This means that everything which is created via extension points is managed by Guice as well, i.e. you can declare dependencies and get them injected upon creation. 

The only thing you have to do in order to use this factory is to prefix the class with the factory _[MyLanguageName]ExecutableExtensionFactory_ name followed by a colon.

bc.. <extension
  point="org.eclipse.ui.editors">
  <editor
    class="<MyLanguageName>ExecutableExtensionFactory:
      org.eclipse.xtext.ui.editor.XtextEditor"
    contributorClass=
      "org.eclipse.ui.editors.text.TextEditorActionContributor"
    default="true"
    extensions="ecoredsl"
    id="org.eclipse.xtext.example.EcoreDsl"
    name="EcoreDsl Editor">
  </editor>
</extension>

h2. Logging

Xtext uses Apache's log4j for logging. It is configured using the so called _log4j.properties_, which is looked up in the root of the Java classpath. If you want to change or provide configuration at runtime (i.e. non-OSGI), all you have to do is putting such a _log4j.properties_ in place and make sure that it is not overridden by other _log4j.properties_ in previous classpath entries.

In OSGi you provide configuration by creating a fragment for _org.apache.log4j_. In this case you need to make sure that there's no second fragment contributing a _log4j.properties_ file.

h2(#validation). Validation

Static analysis or validation is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
if they get informative feedback as they type. 
In Xtext there are basically three different kinds of validation.

h3. Automatic Validation

Some implementation aspects (e.g. the grammar, scoping) of a language have an impact on what is required for a document or semantic model to be valid. Xtext automatically takes care of this. 

h4(#syntactical_validation). Lexer/Parser: Syntactical Validation

The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology.
One can use the ${org.eclipse.xtext/src/org.eclipse.xtext.parser.antlr.ISyntaxErrorMessageProvider}-API to customize this messages.
Any syntax errors can be retrieved from the Resource using the common EMF API:

* _org.eclipse.emf.ecore.resource.Resource.getErrors()_
* _org.eclipse.emf.ecore.resource.Resource.getWarnings()_

h4(#linking_validation). Linker: Crosslink Validation

Any broken crosslinks can be checked generically. As crosslink resolution is done lazily (see "linking":#linking), any broken links are resolved lazily as well.
If you want to validate whether all links are valid, you will have to navigate through the model so that all installed EMF proxies get resolved. This is done automatically in the editor.

Similar to syntax errors, any unresolvable crosslinks will be reported and can be obtained through:

* _org.eclipse.emf.ecore.resource.Resource.getErrors()_
* _org.eclipse.emf.ecore.resource.Resource.getWarnings()_

h4(#concrete_syntax_validation). Serializer: Concrete Syntax Validation

The ${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxValidator} validates all constraints that are implied by a grammar. Meeting these constraints for a model is mandatory to be serialized.

Example:

bc.. MyRule:
  ({MySubRule} "sub")? (strVal+=ID intVal+=INT)*;
	
p. This implies several constraints:
# Types: only instances of _MyRule_ and _MySubRule_ are allowed for this rule. Sub-types are prohibited, since the parser never instantiates unknown sub-types.
# Features: In case the _MyRule_ and _MySubRule_ have _EStructuralFeatures_ besides _strVal_ and _intVal_, only _strVal_ and _intVal_ may have "non-transient values":#transientvalues.
# Quantities: The following condition must be true: _strVal.size() == intVal.size()_.
# Values: It must be possible to "convert all values":#valueconverter to valid tokens for terminal rule _STRING_.  The same is true for _intVal_ and _INT_.

p. The typical use cases for the concrete syntax validator are validation in non-Xtext-editors that, however, use an _XtextResource_. This is, for example, the case when combining GMF and Xtext. Another use case is when the semantic model is modified "manually" (not by the parser) and then serialized again. Since it is very difficult for the serializer to provide "meaningful error messages":#parsetreeconstructor, the concrete syntax validator is executed by default before serialization. A textual Xtext editor itself, however, is _not_ a valid use case. Here, the parser ensures that all syntactical constraints are met. Therefore, there is no value in additionally running the concrete syntax validator.  

p. There are some limitations to the concrete syntax validator which result from the fact that it treats the grammar as declarative, which is something the parser doesn't always do.
* Grammar rules containing assigned actions (e.g. _{MyType.myFeature=current}_ are ignored. Unassigned actions (e.g. _{MyType}_), however, are supported. 
* Grammar rules that delegate to one or more rules containing assigned actions via unassigned rule calls are ignored.
* Orders within list-features can not be validated. e.g. _Rule: (foo+=R1 foo+=R2)*_ implies that _foo_ is expected to contain instances of _R1_ and _R2_ in an alternating order. 

p. To use concrete syntax validation you can let Guice inject an instance of 
${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxValidator} and use it directly. 
Furthermore, there is an adapter (${org.eclipse.xtext/src/org.eclipse.xtext.validation.impl.ConcreteSyntaxEValidator}) 
allows integrating of the concrete syntax validator as an _EValidator_. You can, for example, enable it in 
your runtime module, by adding:

bc.. @SingletonBinding(eager = true)
public Class<? extends ConcreteSyntaxEValidator> 
      bindConcreteSyntaxEValidator() {
  return ConcreteSyntaxEValidator.class;
}
p. To customize error messages please see 
${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxDiagnosticProvider} and subclass 
${org.eclipse.xtext/src/org.eclipse.xtext.validation.impl.ConcreteSyntaxDiagnosticProvider}.


h3(#custom_validation). Custom Validation

In addition to the afore mentioned kinds of validation, which are more or less done automatically, you can specify additional constraints specific for your Ecore model.
We leverage existing EMF API (mainly _EValidator_) and have put some convenience stuff on top. 
Basically all you need to do is to make sure that an _EValidator_ is registered for your _EPackage_. The registry for _EValidators_ (_EValidator.Registry.INSTANCE_) can only be filled programmatically.
That means contrary to the EPackage and _Resource.Factory_ registries there is no Equinox extension point to populate the validator registry.

For Xtext we provide a "generator fragment":#generator_fragment for the convenient Java-based _EValidator_ API. Just add the following fragment to your generator configuration and you are good to go:

bc.. fragment = org.eclipse.xtext.generator.validation.JavaValidatorFragment {}

p. The generator will provide you with two Java classes. An abstract class generated to _src-gen/_ which extends the library class _AbstractDeclarativeValidator_. This one just registers the EPackages for which this validator introduces constraints.
The other class is a subclass of that abstract class and is generated to the _src/_ folder in order to be edited by you. That's where you put the constraints in.

The purpose of the _AbstractDeclarativeValidator_ is to allow you to write constraints in a declarative way - as the class name already suggests. That is instead of writing exhaustive if-else constructs or extending the generated EMF switch you just have to add the _@Check_ annotation to any method and it will be invoked automatically when validation takes place.
Moreover you can state for what type the respective constraint method is, just by declaring a typed parameter. This also lets you avoid any type casts.  
In addition to the reflective invocation of validation methods the _AbstractDeclarativeValidator_ provides a couple of convenient assertions.

All in all this is very similar to how JUnit works. Here is an example:

bc.. 
public class DomainmodelJavaValidator 
  extends AbstractDomainmodelJavaValidator {
    
  @Check
  public void checkTypeNameStartsWithCapital(Type type) {
    if (!Character.isUpperCase(type.getName().charAt(0)))
      warning("Name should start with a capital", 
        DomainmodelPackage.TYPE__NAME);
  }
}

p. You can also implement quick fixes for individual validation errors and warnings. See the "chapter on quick fixes":#quickfixes for details.

h3(#check_based_validation). Validation with the Check Language

In addition to the Java-based validation code you can use the language Check (from M2T/Xpand) to implement constraint checks against your model. To do so, you have to configure the "generator":#generator with the
${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.validation.CheckFragment}.
Please note, that you can combine both types of validation in your project. 

bc.. fragment = org.eclipse.xtext.generator.validation.CheckFragment {}
  
p. After regenerating your language artifacts you will find three new files "YourLanguageChecks.chk", "YourLanguageFastChecks.chk" and "YourLanguageExpensiveChecks.chk" in the _src/_ folder in the sub-package _validation_.  The checks in these files will be executed when saving a file, while typing (FastChecks) or when triggering the validation explicitly (ExpensiveChecks). When using Check the example of the previous chapter could be written like this.

bc.. context Type#name WARNING "Name should start with a capital":
  name.toFirstUpper() == name;  

p. Each check works in a specific context (here: _Type_) and can further denote a feature to which a warning or error should be attached to (here: _name_). Each check could either be a _WARNING_ or an _ERROR_ with a given string to explain the situation. The essential part of each check is an invariant that must hold true for the given context. If it fails the check will produce an issue with the provided explanation.

 Please read more about the Check language as well as the underlying expression language in Xpand's reference documentation which is shipped as Eclipse help. 
 
h3. Validating Manually

As noted above, Xtext uses EMF's _EValidator_ API to register Java or Check validators. You can run the validators on your model programmatically using EMF's _Diagnostician_, e.g.

bc.. EObject myModel = myResource.getContents().get(0);
Diagnostic diagnostic = Diagnostician.INSTANCE.validate(myModel);
switch (diagnostic.getSeverity()) {
  case Diagnostic.ERROR:
    System.err.println("Model has errors: ",diagnostic);
    break;
  case Diagnostic.WARNING:
    System.err.println("Model has warnings: ",diagnostic);
}

h3(#test_validators). Test Validators
 
If you have implemented your validators by extending ${org.eclipse.xtext/src/org.eclipse.xtext.validation.AbstractDeclarativeValidator}, there are helper classes which may assist you when testing your validators.

Testing validators typically works as follows: 
# The test creates some models which intentionally violate some constraints.
# The test runs some choosen @Check-methods from the validator.
# The test asserts whether the @Check-methods have raised the expected warnings and errors.

To create models, you can either use EMF's _ResourceSet_ to load models from your hard disk or you can utilize the _[MyLanguage]Factory_ (which EMF generates for each _EPackage_) to construct the needed model elements manually. While the fist option has the advantages that you can edit your models in your textual concrete syntax, the second option has the advantage that you can create partial models.

To run the @Check-methods and ensure they raise the intended errors and warnings, you can utilize ${org.eclipse.xtext/src/org.eclipse.xtext.junit.validation.ValidatorTester} as shown by the following example:

p. Validator:

bc.. public class MyLanguageValidator extends AbstractDeclarativeValidator {
  @Check
  public void checkFooElement(FooElement element) {
    if(element.getBarAttribute().contains("foo"))
      error("Only Foos allowed", element, 
        MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE, 101);
  }
}

p. JUnit-Test:

bc.. public class MyLanguageValidatorTest extends AbstractXtextTests {

  private ValidatorTester<MyLanguageValidator> tester;

  @Override
  public void setUp() {
    with(MyLanguageStandaloneSetup.class);
    MyLanguageValidator validator = get(MyLanguageValidator.class);
    tester = new ValidatorTester<TestingValidator>(validator);
  }

  public void testError() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validator().checkFooElement(model);
    tester.diagnose().assertError(101);
  }
  
  public void testError2() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validate(model).assertError(101);
  }
}

p. This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit 
whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the _setUp()_-method 
before each testcase and thereby helps to create some common state. In this example, the validator 
(_MyLanguageValidator_) is instantiated by means of Google Guice. As we inherit from the _AbstractXtextTests_
there are a plenty of useful methods available and the state of the global EMF singletons will be restored in the
_tearDown()_. 
Afterwards, the _ValidatorTester_ is created and parameterized with the actual validator. It acts as 
a wrapper for the validator, ensures that the validator has a valid state and provides convenient 
access to the validator itself (_tester.validator()_) as well as to the utility classes which 
assert diagnostics created by the validator (_tester.diagnose()_). Please be aware that you have to 
call _validator()_ before you can call _diagnose()_. However, you can call _validator()_ multiple 
times in a row.

While _validator()_ allows to call the validator's @Check-methods directly, _validate(model)_ leaves it 
to the framework to call the applicable @Check-methods. However, to avoid side-effects between tests, 
it is recommended to call the @Check-methods directly.

_diagnose()_ and _validate(model)_ return an object of type 
${org.eclipse.xtext.junit/src/org.eclipse.xtext.junit.validation.AssertableDiagnostics} which provides 
several _assert_-methods to verify whether the expected diagnostics are present:

* _assertError(int code)_: There must be one diagnostic with severity ERROR and the supplied error code.
* _assertErrorContains(String messageFragment)_:  There must be one diagnostic with severity ERROR and its message must contain _messageFragment_.
* _assertError(int code, String messageFragment)_: Verifies severity, error code and messageFragment.
* _assertWarning(...)_: This method is available for the same combination of parameters as _assertError()_.
* _assertOK()_: Expects that no diagnostics (errors, warnings etc.) have been raised.   
* _assertDiagnostics(int severity, int code, String messageFragment)_: Verifies severity, error code and messageFragment.
* _assertAll(DiagnosticPredicate... predicates)_: Allows to describe multiple diagnostics at the same time and verifies that all of them are present. Class ${org.eclipse.xtext/src/org.eclipse.xtext.junit.validation.AssertableDiagnostics} contains static _error()_ and _warning()_-methods which help to create the needed _DiagnosticPredicate_. Example: _assertAll(error(123), warning("some part of the message"))_. 
* _assertAny(DiagnosticPredicate predicate)_: Asserts that a diagnostic exists which matches the predicate. 


h2(#linking). Linking

The linking feature allows for specification of cross-references within an Xtext grammar.
The following things are needed for the linking:

# declaration of a crosslink in the grammar (at least in the Ecore model)
# specification of linking semantics (usually provided via the "scoping API":#scoping)

h3. Declaration of Crosslinks

In the grammar a cross-reference is specified using square brackets.

bc.. CrossReference :
  '[' type=ReferencedEClass ('|' terminal=CrossReferenceableTerminal)? ']'
;

p. Example:
  
bc.. ReferringType :
  'ref' referencedObject=[Entity|STRING]
;

p. The "Ecore model inference":#metamodelInference would create an _EClass_ _ReferringType_ with an 
_EReference_ _referencedObject_ of type _Entity_ (_containment=false_). The referenced object would 
be identified either by a _STRING_ and the surrounding information in the current context 
(see "scoping":#scoping). If you do not use _generate_ but _import_ an existing Ecore model, 
the class _ReferringType_ (or one of its super types) would need to have an _EReference_ of type 
_Entity_ (or one of its super types) declared. Also the _EReference_'s containment and container 
properties needs to be set to _false_. 

h3. Default Runtime Behavior (Lazy Linking)

Xtext uses lazy linking by default and we encourage users to stick to this because it provides  
many advantages. One of which is improved performance in all scenarios where you don't have to load 
the whole closure of all transitively referenced resources. Furthermore it automatically solves 
situations where one link relies on other links. Though cyclic linking dependencies are not 
supported by Xtext at all. 

When parsing a given input string, say

bc. ref Entity01

the ${org.eclipse.xtext/src/org.eclipse.xtext.linking.lazy.LazyLinker} first creates an EMF proxy and 
assigns it to the corresponding _EReference_. In EMF a proxy is described by a URI, which points to the 
real _EObject_. In the case of lazy linking the stored URI comprises of the context information given 
at parse time, which is the _EObject_ containing the cross-reference, the actual _EReference_, the 
index (in case it's a multi-valued cross-reference) and the string which represented the crosslink 
in the concrete syntax. The latter usually corresponds to the name of the referenced _EObject_. 
In EMF a URI consists of information about the resource the _EObject_ is contained in as well as a so 
called fragment part, which is used to find the _EObject_ within that resource. When an  EMF proxy 
is resolved, the current _ResourceSet_ is asked. The resource set uses the first part to obtain 
(i.e. load if it is not already loaded) the resource. Then the resource is asked to return the 
_EObject_ based on the fragment in the URI. The actual cross-reference resolution is done by 
_LazyLinkingResource.getEObject(String)_ which receives the fragment and delegates to the implementation 
of the _ILinkingService_. The default implementation in turn delegates to the "scoping API":#scoping.

A simple implementation of the linking service (the 
${org.eclipse.xtext/src/org.eclipse.xtext.linking.impl.DefaultLinkingService}) is shipped with Xtext 
and used for any grammar per default. Usually any necessary customization of the linking behavior 
can best be described using the "scoping API":#scoping.


h2(#scoping). Scoping

Using the scoping API one defines which elements are referable by a certain reference. For instance, 
using the introductory example (fowler's state machine language)
a transition contains two cross-references: One to a declared event and one to a declared state.

Example:

bc.. events
  nothingImportant  MYEV
end
 
state idle
  nothingImportant => idle
end
  
p. The grammar rule for transitions looks like this:

bc.. Transition :
  event=[Event] '=>' state=[State];

p. The grammar states that for the reference _event_ only instances of the type _Event_ are allowed and 
that for the EReference _state_ only instances of type _State_ can be referenced. However, this simple 
declaration doesn't say anything about where to find the states or events. That is the duty of scopes.  

An ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IScopeProvider} is responsible for providing 
an ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IScope} for a given context _EObject_ and 
_EReference_. The returned _IScope_ should contain all target candidates for the given object and cross-reference.

bc.. public interface IScopeProvider {

	/**
	 * Returns a scope for the given context. The scope 
	 * provides access to the compatible visible EObjects 
	 * for a given reference.
	 *
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference to be used to filter the elements.
	 * @return {@link IScope} representing the inner most {@link IScope} for 
	 *         the passed context and reference. Note for implementors: The 
	 *         result may not be <code>null</code>. Return 
	 *         <code>IScope.NULLSCOPE</code> instead.
	 */
	IScope getScope(EObject context, EReference reference);

}

p. A single _IScope_ represents an element of a linked list of scopes. That means that a scope can be 
nested within an outer scope. Each scope works like a symbol table or a map where the keys are strings 
and the values are so called ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IEObjectDescription}, 
which is effectively an abstract description of a real _EObject_. 

h3(#global_scopes). Global Scopes and _IResourceDescriptions_

In the state machine example we don't have references across model files. Also there is no concept like 
a namespace which would make scoping a bit more complicated. Basically, every _State_ and every _Event_ 
declared in the same resource is visible by their name. However in the real world things are most likely 
not that simple: What if you want to reuse certain declared states and events across different 
state machines and you want to share those as library between different users? You would want to introduce 
some kind of cross resource reference. 

Defining what is visible from outside the current resource is the responsibility of global scopes. 
As the name suggests, global scopes are provided by instances of the 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IGlobalScopeProvider}. The data structures used to 
store its elements are described in the next section.

h4(#resourcedescriptions). _Resource_ and _EObject_ Descriptions (_IResourceDescription_, _IEObjectDescription_)

In order to make states and events of one file referable from another file you need to export them as 
part of a so called ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceDescription}. 

A _IResourceDescription_ contains information about the resource itself (primarily its _URI_), a list 
of exported _EObjects_ (in the form of ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IEObjectDescription}) 
as well as information about outgoing cross-references and qualified names it references. The cross 
references contain only resolved references, while the list of imported qualified names also contain 
those names, which couldn't be resolved. This information is important in order to compute the transitive 
hull of dependent resources, which the shipped index infrastructure automatically does for you.

For users and especially in the context of scoping the most important information is the list of 
exported _EObjects_. An ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IEObjectDescription} 
contains information about the _URI_ to the actual _EObject_ and the qualified name of that element 
as well as the corresponding _EClass_. In addition one can export arbitrary information using the 
_user data_ map. The following diagram gives an overview on the description classes and their relationships.

!images/index_datamodel.png(Descriptions)!

A language is configured with a default implementation of _IResourceDescription.Manager_ which computes 
the list of exported _IEObjectDescriptions_ by iterating the whole EMF model and applying the 
_getQualifiedName(EObject obj)_ from ${org.eclipse.xtext/src/org.eclipse.xtext.naming.IQualifiedNameProvider} 
on each _EObject_. If the object has a qualified name an _IEObjectDescription_ is created and exported 
(i.e. added to the list). If an _EObject_ doesn't have a qualified name, the element is considered to 
be not referable from outside the resource and consequently not indexed. If you don't like this behavior, 
you can implement and bind your own implementation of _IResourceDescription.Manager_.  

There are also two different default implementations of _IQualifiedNameProvider_. Both work by looking 
up an _EAttribute_ 'name'. The ${org.eclipse.xtext/src/org.eclipse.xtext.naming.SimpleNameProvider} 
simply returns the plain value, while the 
${org.eclipse.xtext/src/org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider} concatenates 
the simple name with the qualified name of its parent exported _EObject_. This effectively simulates 
the qualified name computation of most namespace-based languages (like e.g. Java). 

As mentioned above, in order to calculate an _IResourceDescription_ for a resource the framework asks 
the _IResourceDescription.Manager_. Here's some Java code showing how to do that:

bc.. Manager manager = // obtain an instance of IResourceDescription.Manager
IResourceDescription description = manager.getResourceDescription(resource);
for (IEObjectDescription objDescription : description.getExportedObjects()) {
  System.out.println(objDescription.getQualifiedName());
} 
  
p. In order to obtain an _IResourceDescription.Manager_ it is best to ask the corresponding 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceServiceProvider}. That is because each 
language might have a totally different implementation and as you might refer from your language to a 
different language you can't reuse your language's _IResourceDescription.Manager_. One basically asks 
the _IResourceServiceProvider.Registry_ (there is usually one global instance) for an 
_IResourceServiceProvider_, which in turn provides an _IResourceDescription.Manager_ along other 
useful services.

If you're running in a Guice enabled scenario, the code looks like this:

bc.. @Inject 
private IResourceServiceProvider.Registry resourceServiceProviderRegistry;
	
private IResourceDescription.Manager getManager(Resource res) {
  IResourceServiceProvider resourceServiceProvider = 
    resourceServiceProviderRegistry.getResourceServiceProvider(res.getURI());
  return resourceServiceProvider.getResourceDescriptionManager();
}

p. If you don't run in a Guice enabled context you will likely have to directly access the singleton:

bc.. private IResourceServiceProvider.Registry resourceServiceProviderRegistry = 
  IResourceServiceProvider.Registry.INSTANCE;

p. However, we strongly encourage you to use dependency injection.
Now, that we know how to export elements to be referenceable from other resources, we need to learn 
how those exported _IEObjectDescriptions_ can be made available to the referencing resources. That is 
the responsibility of global scoping (i.e. 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IGlobalScopeProvider}) which is described in the 
following chapter.

h4(#import_uri). Global Scopes Based On Explicit Imports (ImportURI Mechanism)

A simple and straight forward solution is to have explicit references to other resources in your 
file by explicitly listing pathes (or _URIs_) to all referenced resources in your model file. That is 
for instance what most include mechanisms use. In Xtext we provide a handy implementation of an 
_IGlobalScopeProvider_ which is based on a naming convention and makes this semantics very easy to use. 
Talking of the introductory example and given you would want to add support for referencing external 
_States_ and _Events_ from within your state machine, all you had to do is add something like the 
following to the grammar definition:

bc.. Statemachine :
  (imports+=Import)* // allow imports
  'events'
     (events+=Event)+
  'end'
  ('resetEvents'
     (resetEvents+=[Event])+
  'end')?
  'commands'
     (commands+=Command)+
  'end'
  (states+=State)+;

Import : 
  'import' importURI=STRING; // feature must be named importURI

p.  This effectively allows import statements to be declared before the events section. In addition 
you'll have to make sure that you have bound the 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider} for the type 
_IGlobalScopeProvider_ by the means of "Guice":#dependencyInjection. That implementation looks up any 
_EAttributes_ named 'importURI' in your model and interprets their values as URIs that point to imported
resources. That is it adds the corresponding resources to the current resource's resource set. In 
addition the scope provider uses the "_IResourceDescription.Manager_":#resourcedescriptions of that 
imported resource to compute all the _IEObjectDescriptions_ returned by the _IScope_.  

Global scopes based on import URIs are available if you use the 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.scoping.ImportURIScopingFragment} in the 
workflow of your language. It will bind an 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider} 
(${org.eclipse.xtext/src/org.eclipse.xtext.resource.ignorecase.IgnoreCaseImportUriGlobalScopeProvider} 
if the _caseInsensitve_ flag is set) that handles _importURI_ features.

h4(#index_based). Global Scopes Based On External Configuration (e.g. Classpath-Based)

Instead of explicitly referring to imported resources, the other possibility is to have some kind of 
external configuration in order to define what is visible from outside a resource. Java for instances 
uses the notion of classpaths to define containers (jars and class folders) which contain any 
referenceable elements. In the case of Java also the order of such entries is important. 

Since version 1.0.0 Xtext provides support for this kind of global scoping. To enable it, a 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.DefaultGlobalScopeProvider} has to be bound to 
the _IGlobalScopeProvider_ interface. For case insensitive names use the 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.ignorecase.IgnoreCaseDefaultGlobalScopeProvider}.

By default Xtext leverages the classpath mechanism since it is well designed and already understood 
by most of our users. The available tooling provided by JDT and PDE to configure the classpath adds 
even more value. However, it is just a default: You can reuse the infrastructure without using Java 
and independent from the JDT.

In order to know what is available in the "world" a global scope provider which relies on external 
configuration needs to read that configuration in and be able to find all candidates for a certain 
_EReference_. If you don't want to force users to have a folder and file name structure reflecting 
the actual qualified names of the referenceable _EObjects_, you'll have to load all resources up front 
and either keep holding them in memory or remembering all information which is needed for the 
resolution of cross-references. In Xtext that information is provided by a so called 
"_IEObjectDescription_":#resourcedescriptions. 

h5(#containers). About the Index, Containers and Their Manager 

p. Xtext ships with an index which remembers all _IResourceDescription_ and their _IEObjectDescription_ 
objects. In the IDE-context (i.e. when running the editor, etc.) the index is updated by an incremental 
project builder. As opposed to that, in a non-UI context you typically do not have to deal with changes 
such that the infrastructure can be much simpler. In both situations the global index state is held 
by an implementation of ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceDescriptions} 
(Note the plural form!). The bound singleton in the UI scenario is even aware of unsaved editor changes, 
such that all linking happens to the latest maybe unsaved version of the resources. You will find the 
Guice configuration of the global index in the UI scenario in 
${org.eclipse.xtext.ui.shared/src/org.eclipse.xtext.ui.shared.internal.SharedModule}.

p. The index is basically a flat list of instances of _IResourceDescription_. The index itself doesn't 
know about visibility constraints due to classpath restriction. Rather than that, they are defined by 
the referencing language by means of so called _IContainers_: While Java might load a resource 
via _ClassLoader.loadResource()_ (i.e. using the classpath mechanism), another language could load 
the same resource using the file system paths. 
 
p. Consequently, the information which container a resource belongs to depends on the referencing 
context. Therefore an _IResourceServiceProvider_ provides another interesting service, which is called
_IContainer.Manager_. For a given _IResourceDescription_, the _IContainer.Manager_ provides you with 
the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IContainer} as well as with a list of all 
_IContainers_ which are visible from there. Note that the index (_IResourceDesciptions_) is globally 
shared between all languages while the _IContainer.Manager_ that adds the semantics of containers can 
be very different depending on the language. The following method lists all resources visible from a 
given _Resource_:  

bc.. @Inject
IContainer.Manager manager;

public void listVisibleResources(
        Resource myResource, IResourceDescriptions index) {
  IResourceDescription descr = 
        index.getResourceDescription(myResource.getURI());
  for(IContainer visibleContainer: 
  	    manager.getVisibleContainers(descr, index)) { 
    for(IResourceDescription visibleResourceDesc:
            visibleContainer.getResourceDescription()) { 
      System.out.println(visibleResourceDesc.getURI());
    }
  }
}

p. Xtext ships two implementations of _IContainer.Manager_ which are as usual bound with Guice: The 
default binding is to 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.impl.SimpleResourceDescriptionsBasedContainerManager}, 
which assumes all _IResourceDescription_ to be in a single common container. If you don't care about 
container support, you'll be fine with this one. Alternatively, you can bind 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.containers.StateBasedContainerManager} and an 
additional ${org.eclipse.xtext/src/org.eclipse.xtext.resource.containers.IAllContainersState} which 
keeps track of the set of available containers and their visibility relationships.  

p. Xtext offers a couple of strategies for managing containers: If you're running an Eclipse workbench, 
you can define containers based on Java projects and their classpaths or based on plain Eclipse projects. 
Outside Eclipse, you can provide a set of file system paths to be scanned for models. All of these only 
differ in the bound instance of _IAllContainerState_ of the referring language. These will be described 
in detail in the following sections.

!images/index_container.png(IContainer Management)!
 
h5(#jdt_based_containers). JDT-Based Container Manager 

As JDT is an Eclipse feature, this JDT-based container management is only available in the UI scenario. 
It assumes so called _IPackageFragmentRoots_ as containers. An _IPackageFragmentRoot_ in JDT is the 
root of a tree of Java model elements. It usually refers to 
* a source folder of a Java project,
* a referenced jar, 
* a classpath entry of a referenced Java project, or
* the exported packages of a required PDE plug-in.

So for an element to be referable, its resource must be on the classpath of the caller's Java project 
and it must be exported (as described above). 

As this strategy allows to reuse a lot of nice Java things like jars, OSGi, maven, etc. it is part of 
the default: You should not have to reconfigure anything to make it work. Nevertheless, if you messed 
something up, make sure you bind

bc.. public Class<? extends IContainer.Manager> bindIContainer$Manager() {
  return StateBasedContainerManager.class;
}

p. in the runtime module and 

bc.. public Provider<IAllContainersState> provideIAllContainersState() {
  return org.eclipse.xtext.ui.shared.Access.getJavaProjectsState();
  // return org.eclipse.xtext.ui.shared.Access.getStrictJavaProjectsState();
}

p. in the UI module of the referencing language. The latter looks a bit more difficult than a common 
binding, as we have to bind a global singleton to a Guice provider. The _StrictJavaProjectsState_ 
requires all elements to be on the classpath, while the default _JavaProjectsState_ also allows models 
in non-source folders. 

h5(#project_based_containers). Eclipse Project-Based Containers

If the classpath-based mechanism doesn't work for your case, Xtext offers an alternative container 
manager based on plain Eclipse projects: Each project acts as a container and the project references 
_Properties->Project References_ are the visible containers. 

In this case, your runtime module should define

bc.. public Class<? extends IContainer.Manager> bindIContainer$Manager() {
  return StateBasedContainerManager.class;
}

p. and the UI module should bind 

bc.. public Provider<IAllContainersState> provideIAllContainersState() {
  return org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState();
}

h5(#resource_set_containers). _ResourceSet_-Based Containers

If you need an _IContainer.Manager_ that is independent of Eclipse projects, you can use the 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.containers.ResourceSetBasedAllContainersState}. 
This one can be configured with a mapping of container handles to resource URIs.

It is unlikely you want to use this strategy directly in your own code, but it is used in the back-end 
of the MWE2 workflow component ${org.eclipse.xtext/src/org.eclipse.xtext.mwe.Reader}. This is responsible 
for reading in models in a workflow, e.g. for later code generation. The _Reader_ allows to either scan 
the whole classpath or a set of paths for all models therein. When paths are given, each path entry 
becomes an _IContainer_ of its own. In the following snippet,

bc.. component = org.eclipse.xtext.mwe.Reader {
  // lookup all resources on the classpath
  // useJavaClassPath = true
	
  // or define search scope explicitly
  path = "src/models"
  path = "src/further-models"

  ...
}
 
h3(#local_scoping). Local Scoping

We now know how the outer world of referenceable elements can be defined in Xtext. Nevertheless, not 
everything is available in any context and with a global name. Rather than that, each context can usually 
have a different scope. As already stated, scopes can be nested, i.e. a scope can in addition to its 
own elements contain elements of a parent scope. When parent and child scope contain different elements 
with the same name, the parent scope's element will usually be _shadowed_ by the element from the child scope.      

To illustrate that, let's have a look at Java: Java defines multiple kinds of scopes 
(object scope, type scope, etc.). For Java one would create the scope hierarchy as commented in the 
following example:

bc.. // file contents scope
import static my.Constants.STATIC;

public class ScopeExample { // class body scope
  private Object field = STATIC;

  private void method(String param) { // method body scope
    String localVar = "bar";
    innerBlock: { // block scope
      String innerScopeVar = "foo";
      Object field = innerScopeVar;
      // the scope hierarchy at this point would look like this:
      //  blockScope{field,innerScopeVar}->
      //  methodScope{localVar, param}->
      //  classScope{field}-> ('field' is shadowed)
      //  fileScope{STATIC}->
      //  classpathScope{
      //      'all qualified names of accessible static fields'} ->
      //  NULLSCOPE{}
      //
    }
    field.add(localVar);
  }
}

p. In fact the classpath scope should also reflect the order of classpath entries.
For instance:

bc.. classpathScope{stuff from bin/}
-> classpathScope{stuff from foo.jar/}
-> ...
-> classpathScope{stuff from JRE System Library}
-> NULLSCOPE{}

p. Please find the motivation behind this and some additional details in 
"this blog post":http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html .

h4. Declarative Scoping

If you have to define scopes for certain contexts, the base class 
${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider} allows to do 
that in a declarative way. It looks up methods which have either of the following two signatures:

bc.. IScope scope_<RefDeclaringEClass>_<Reference>(
    <ContextType> ctx, EReference ref)

IScope scope_<TypeToReturn>(<ContextType> ctx, EReference ref)

p. The former is used when evaluating the scope for a specific cross-reference and here _ContextReference_ 
corresponds to the name of this reference (prefixed with the name of the reference's declaring type and 
separated by an underscore). The _ref_ parameter represents this cross-reference.

The latter method signature is used when computing the scope for a given element type and is applicable 
to all cross-references of that type. Here _TypeToReturn_ is the name of that type. 

So if you for example have a state machine with a  _Transition_ object owned by its source _State_ and 
you want to compute all reachable states (i.e. potential target states), the corresponding method could 
be declared as follows (assuming the cross-reference is declared by the _Transition_ type and is called _target_):

bc. IScope scope_Transition_target(Transition this, EReference ref)

If such a method does not exist, the implementation will try to find one for the context object's container. 
Thus in the example this would match a method with the same name but _State_ as the type of the first 
parameter. It will keep on walking the containment hierarchy until a matching method is found. This 
container delegation allows to reuse the same scope definition for elements in different places of the 
containment hierarchy. Also it may make the method easier to implement as the elements comprising the 
scope are quite often owned or referenced by a container of the context object. In the example the 
_State_ objects could for instance be owned by a containing _StateMachine_ object.

If no method specific to the cross-reference in question was found for any of the objects in the 
containment hierarchy, the implementation will start looking for methods matching the other signature. Again it will first attempt to match the context object. Thus in the 
example the signature first matched would be:

bc. IScope scope_State(Transition this, EReference ref)

If no such method exists, the implementation will again try to find a method matching the context object's 
container objects. In the case of the state machine example you might want to declare the scope with 
available states at the state machine level:

bc. IScope scope_State(StateMachine this, EReference ref)

This scope can now be used for any cross-references of type _State_ for context objects owned by the 
state machine.

h3. Imported Namespace-Aware Scoping

The imported namespace aware scoping is based on qualified names and namespaces. It adds namespace 
support to your language, which is comparable and similar to the one in Scala and C#. Scala and C# both 
allow to have multiple nested packages within one file and you can put imports per namespace, so that 
imported names are only visible within that namespace. See the domain model example: its scope provider 
extends ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider}.

h4. ${org.eclipse.xtext/src/org.eclipse.xtext.naming.IQualifiedNameProvider}

The ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider} 
makes use of the so called ${org.eclipse.xtext/src/org.eclipse.xtext.naming.IQualifiedNameProvider} 
service. It computes qualified names for EObjects. The default implementation 
(${org.eclipse.xtext/src/org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider}) uses 
a simple name look up and concatenates the result to the qualified name of its parent object using a dot 
as separator. 

It also allows to override the name computation declaratively. The following snippet shows how you could 
make _Transitions_ in the state machine example referable by giving them a name. Don't forget to bind 
your implementation in your runtime module. 

bc.. FowlerDslQualifiedNameProvider 
      extends DefaultDeclarativeQualifiedNameProvider {
  public String qualifiedName(Transition t) {
    if(t.getEvent() == null || !(t.eContainer() instanceof State)) 
      return null;
    else 
      return ((State)t.eContainer()).getName() + "." t.getEvent().getName();
  }
}

h4. Importing Namespaces

The _ImportedNamespaceAwareLocalScopeProvider_ looks up _EAttributes_ with name 'importedNamespace' and 
interprets them as import statements. By default qualified names with or without a wildcard at the end 
are supported. For an import of a qualified name the simple name is made available as we know from e.g. 
Java, where

bc. import java.util.Set;

makes it possible to refer to 'java.util.Set' by its simple name 'Set'.
Contrary to Java the import is not active for the whole file but only for the namespace it is declared 
in and its child namespaces. That is why you can write the following in the example DSL:

bc.. 
package foo {
  import bar.Foo
  entity Bar extends Foo {
  }
}

package bar {
  entity Foo {}
}

p. Of course the declared elements within a package are as well referable by their simple name:

bc.. 
package bar {
  entity Bar extends Foo {}
  entity Foo {}
}

p. The following would as well be ok:

bc.. 
package bar {
  entity Bar extends bar.Foo {}
  entity Foo {}
}

p. See the JavaDocs and "this blog post":http://blog.efftinge.de/2009/07/xtext-scopes-and-emf-index-in-action.html 
for details.


h2(#valueconverter). Value Converter

Value converters are registered to convert the parsed text into a certain data type instance and vice versa.
The primary hook is called ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.IValueConverterService} 
and the concrete implementation can be registered via the runtime "Guice module":#guicemodules.
To do so override the corresponding binding in your runtime module like shown in this example:

bc.. @Override
public Class<? extends IValueConverterService> bindIValueConverterService() {
  return MySpecialValueConverterService.class;
}

h3. Annotation-Based Value Converters

The most simple way to register additional value converters is to make use of 
${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.AbstractDeclarativeValueConverterService}, 
which allows to declaratively register an ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.IValueConverter}
by means of an annotated method. 

p. If you use the common terminals grammar _org.eclipse.xtext.common.Terminals_ you should subclass 
${org.eclipse.xtext/src/org.eclipse.xtext.common.services.DefaultTerminalConverters} and override or 
add additional value converters by adding the respective methods. In addition to the explicitly 
defined converters in the default implementation, a delegating converter is registered for each 
available _EDataType_ that reuses the functionality of the corresponding EMF _EFactory_.

p. As qualified names - i.e. names composed of namespaces separated by a delimiter - are expected to occur often, we've added a ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.QualifiedNameValueConverter}. This one removes comments and whitespaces and delegates to another value converter for each segment, allowing individually quoted segments. The domainmodel example shows how to use it. 

p. The protocol of an _IValueConverter_ allows to throw a _ValueConverterException_ if something went wrong.
The exception is propagated as a syntax error by the parser or as a validation problem by the 
_ConcreteSyntaxValidator_ if the value cannot be converted to a valid string. The 
${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.AbstractLexerBasedConverter} is useful when 
implementing a custom value converter. If the converter needs to know about the rule that it currently 
works with, it may implement the interface _IValueConverter.RuleSpecific_. The framework will set the
rule such as the implementation may use it afterwards.

h2(#serialization). Serialization

p. Serialization is the process of transforming an EMF model into its textual representation. Thereby, 
serialization complements parsing and lexing.

In Xtext, the process of serialization is split into the following steps:

# Validating the semantic model. This is optional, enabled by default, done by the "concrete syntax validator":#concrete_syntax_validation and can be turned off in the "save options":#saveoptions. 
# Matching the model elements with the grammar rules and creating a stream of tokens. This is done by the "parse tree constructor":#parsetreeconstructor.
# Associating comments with semantic objects. This is done by the "comment associator":#commentassociater.
# Associating existing nodes from the node model with tokens from the token stream.
# "Merging existing whitespace":#hiddentokenmerger and line-wraps into to token stream. 
# Adding further needed whitespace or replacing all whitespace using a "formatter":#formatting.  

p. Serialization is invoked when calling 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource}.save(...). Furthermore, 
${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.Serializer} provides resource-independent 
support for serialization. Serialization is _not_ called when a textual editors contents is saved to disk. 
Another situation that triggers serialization is applying "Quick Fixes":#quickfixes with semantic modifications.

h3(#serializationcontract). The Contract

p. The contract of serialization says that a model that is serialized to its textual representation 
and then loaded (parsed) again should yield a loaded model that equals the original model. Please be 
aware that this does _not_ imply, that loading a textual representation and serializing it back produces 
identical textual representations. For example, this is the case when a default value is used in a 
textual representation and the assignment is optional. Another example is:

bc.. MyRule:
  (xval+=ID | yval+=INT)*;
  
p.  _MyRule_ in this example reads _ID_- and _INT_-elements which may occur in an arbitrary order in 
the textual representation. However, when serializing the model all _ID_-elements will be written 
first and then all _INT_-elements. If the order is important it can be preserved by storing all elements 
in the same list - which may require wrapping the _ID_- and _INT_-elements into objects.

h3. Roles of the Semantic Model and the Node Model During Serialization

A serialized document represents the state of the semantic model. However, if there is a node model available (i.e. the semantic model has been created by the parser), the serializer
* preserves "existing whitespaces":#hiddentokenmerger from the node model.
* preserves "existing comments":#commentassociater from the node model.
* preserves the representation of cross-references: If a cross-referenced object can be identified by multiple names (i.e. scoping returns multiple EObjectDescriptions for the same object), the serializer tries to keep the previously used name. 
* preserves the representation of values: For values handled by the "value converter":#valueconverter, the serializer checks whether the textual representation converted to a value equals the value from the semantic model. If that is true, the textual representation is kept.  

h3(#parsetreeconstructor). Parse Tree Constructor

p. The parse tree constructor usually does not need to be customized since it is automatically derived 
from the "Xtext Grammar":#grammarLanguage. However, it can be helpful to look into it to understand 
its error messages and its runtime performance.

For serialization to succeed, the parse tree constructor must be able to _consume_ every non-transient 
element of the to-be-serialized EMF model. To _consume_ means, in this context, to write the element to 
the textual representation of the model. This can turn out to be a not-so-easy-to-fulfill requirement, 
since a grammar usually introduces implicit constraints to the EMF model as explained for the 
"concrete syntax validator":#concrete_syntax_validation.

If a model can not be serialized, an 
${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.XtextSerializationException} is thrown. 
Possible reasons are listed below:

* A model element can not be consumed. This can have the following reasons/solutions:
** The model element should not be stored in the model.
** The grammar needs an assignment which would consume the model element.
** The "transient value service":#transientvalues can be used to indicate that this model element should not be consumed. 
* An assignment in the grammar has no corresponding model element. The default transient value service considers a model element to be transient if it is _unset_ or equals its default value. However, the parse tree constructor may serialize default values if this is required by a grammar constraint to be able to serialize another model element. The following solution may help to solve such a scenario:
** A model element should be added to the model.
** The assignment in the grammar should be made optional.
* The type of the model element differs from the type in the grammar. The type of the model element must be identical to the return type of the grammar rule or the action's type. Sub-types are not allowed.
* "Value conversion":#valueconverter fails. The value converter can indicate that a value is not serializeable by throwing a ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.ValueConverterException}.
* An enum literal is not allowed at this position. This can happen if the referenced enum rule only lists a subset of the literals of the actual enumeration.

To understand error messages and performance issues of the parse tree constructor it is important to 
know that it implements a backtracking algorithm. This basically means that the grammar is used to 
specify the structure of a tree in which one path (from the root node to a leaf node) is a valid 
serialization of a specific model. The parse tree constructor's task is to find this path - with the 
condition, that all model elements are consumed while walking this path. The parse tree constructor's 
strategy is to take the most promising branch first (the one that would consume the most model elements). 
If the branch leads to a dead end (for example, if a model element needs to be consumed that is not 
present in the model), the parse tree constructor goes back the path until a different branch can be 
taken. This behavior has two consequences:
* In case of an error, the parse tree constructor has found only dead ends but no leaf. It cannot tell which dead end is actually erroneous. Therefore, the error message lists dead ends of the longest paths, a fragment of their serialization and the reason why the path could not be continued at this point. The developer has to judge on his own which reason is the actual error.
*  For reasons of performance, it is critical that the parse tree constructor takes the most promising branch first and detects wrong branches early. One way to achieve this is to avoid having many rules which return the same type and which are called from within the same alternative in the grammar.

h3(#saveoptions). Options

${org.eclipse.xtext/src/org.eclipse.xtext.resource.SaveOptions} can be passed to 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource}.save(options) and to 
${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.Serializer}.serialize(..). 
Available options are:
* *Formatting*. Default: _false_. If enabled, it is the "formatters":#formatting job to determine all whitespace information during serialization. If disabled, the formatter only defines whitespace information for the places in which no whitespace information can be preserved from the node model. E.g. When new model elements are inserted or there is no node model.
* *Validating*. Default: _true_: Run the "concrete syntax validator":#concrete_syntax_validation before serializing the model.

h3(#commentassociater). Preserving Comments from the Node Model

p. The ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.ICommentAssociater} associates 
comments with semantic objects. This is important in case an element in the semantic model is moved 
to a different position and the model is serialized, one expects the comments to be moved to the 
new position in the document as well.

p. Which comment belongs to which semantic object is surely a very subjective issue. The default 
implementation (${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.impl.DefaultCommentAssociater}) 
behaves as follows, but can be customized:
* If there is a semantic token before a comment and in the same line, the comment is associated with this token's semantic object.
* In all other cases, the comment is associated with the semantic object of the next following object.

h3(#transientvalues). Transient Values

p. Transient values are values or model elements which are not persisted (written to the textual 
representation in the serialization phase). If a model contains model elements which can not be serialized 
with the current grammar, it is critical to mark them transient using the 
${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.ITransientValueService}, or serialization 
will fail. The default implementation marks all model elements transient, which are _eStructuralFeature.isTransient()_ 
or not _eObject.eIsSet(eStructuralFeature)_. By default, EMF returns _false_ for _eIsSet(...)_ if the 
value equals the default value.    

h3(#unassignedtext). Unassigned Text

p. If there are calls of data type rules or terminal rules that do not reside in an assignment, 
the serializer by default doesn't know which value to use for serialization.  

p. . Example:

bc.. PluralRule:
  'contents:' count=INT Plural;
  
terminal Plural: 
  'item' | 'items';
  
p. Valid models for this example are _contents 1 item_ or _contents 5 items_. However, it is not stored 
in the semantic model whether the keyword _item_ or _items_ has been parsed. This is due to the fact 
that the rule call _Plural_ is unassigned. However, the "parse tree constructor":#parsetreeconstructor 
needs to decide which value to write during serialization. This decision can be be made by customizing 
the _IValueSerializer.serializeUnassignedValue(EObject, RuleCall, AbstractNode)_.  

h3(#crossreferenceserializer). Cross-Reference Serializer

p. The cross-reference serializer specifies which values are to be written to the textual representation 
for cross-references. This behavior can be customized by implementing 
_ICrossReferenceSerializer_. 
The default implementation delegates to various other services such as the _IScopeProvider_ or the 
_LinkingHelper_ each of which may be the better place for customization.

h3(#hiddentokenmerger). Merge Whitespaces

p. After the "parse tree constructor":#parsetreeconstructor has done its job to create a stream of 
tokens which are to be written to the textual representation, and the "comment associator":#commentassociater 
has done its work, existing whitespace form the node model is merged into the stream. 

p. The strategy is as follows: If two tokens follow each other in the stream and the corresponding 
nodes in the node model follow each other as well, then the whitespace information in between is kept. 
In all other cases it is up to the "formatter":#formatting to calculate new whitespace information. 

h3(#tokenstream). Token Stream

p. The "parse tree constructor":#parsetreeconstructor and the "formatter":#formatting use an 
${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.ITokenStream} for their output, and the 
latter for its input as well. This makes them chainable. Token streams can be converted to a _String_ 
using the ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.impl.TokenStringBuffer} and to 
a _Writer_ using the ${org.eclipse.xtext/src/org.eclipse.xtext.parsetree.reconstr.impl.WriterTokenStream}.

bc.. public interface ITokenStream {
  void flush() throws IOException;
  void writeHidden(EObject grammarElement, String value) throws IOException;
  void writeSemantic(EObject grammarElement, String value) throws IOException;
}

 

h2(#formatting). Formatting (Pretty Printing)

p. A formatter can be implemented via the ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IFormatter} 
service. Technically speaking, a formatter is a "Token Stream":#tokenstream which 
inserts/removes/modifies hidden tokens (whitespace, line-breaks, comments).

The formatter is invoked during the "serialization phase":#serialization and when the user triggers 
formatting in the editor (for example, using the CTRL+SHIFT+F shortcut).

Xtext ships with two formatters:
* The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.OneWhitespaceFormatter} simply writes one whitespace between all tokens.
* The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter} allows advanced configuration using a ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig}. Both are explained in the "next chapter":#declarativeformatter.

h3(#declarativeformatter). Declarative Formatter

p. A declarative formatter can be implemented by sub-classing 
${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter}, as shown in 
the following example:

bc.. 
public class ExampleFormatter extends AbstractDeclarativeFormatter {

  @Override
  protected void configureFormatting(FormattingConfig c) {
    ExampleLanguageGrammarAccess f = getGrammarAccess();
    
    c.setAutoLinewrap(120);
    
    // find common keywords an specify formatting for them
    for (Pair<Keyword, Keyword> pair : f.findKeywordPairs("(", ")")) {
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Keyword comma : f.findKeywords(",")) {
      c.setNoSpace().before(comma);
    }

    // formatting for grammar rule Line
    c.setLinewrap(2).after(f.getLineAccess().getSemicolonKeyword_1());
    c.setNoSpace().before(f.getLineAccess().getSemicolonKeyword_1());
    
    // formatting for grammar rule TestIndentation
    c.setIndentationIncrement().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setIndentationDecrement().before(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    
    // formatting for grammar rule Param
    c.setNoLinewrap().around(f.getParamAccess().getColonKeyword_1());
    c.setNoSpace().around(f.getParamAccess().getColonKeyword_1());
    
    // formatting for Comments 
    cfg.setLinewrap(0, 1, 2).before(g.getSL_COMMENTRule());
    cfg.setLinewrap(0, 1, 2).before(g.getML_COMMENTRule());
    cfg.setLinewrap(0, 1, 1).after(g.getML_COMMENTRule());
  }
}

p. The formatter has to implement the method _configureFormatting(...)_ which declaratively sets up 
a ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig}.

The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig} consist of general 
settings and a set of formatting instructions:

h4. General FormattingConfig Settings

* _setAutoLinewrap(int)_ defines the amount of characters after which a line-break should be dynamically inserted between two tokens. The instructions _setNoLinewrap().???()_,  _setNoSpace().???()_ and _setSpace(space).???()_ suppress this behavior locally. The default is 80.

h4. FormattingConfig Instructions

p. Per default, the "declarative formatter":#declarativeformatter inserts one whitespace between two 
tokens. Instructions can be used to specify a different behavior. They consist of two parts: _When_ 
to apply the instruction and _what_ to do.

To understand _when_ an instruction is applied think of a stream of tokens whereas each token is 
associated with the corresponding grammar element. The instructions are matched against these grammar 
elements. The following matching criteria exist:
* _after(ele)_: The instruction is applied after the grammar element _ele_ has been matched. For example, if your grammar uses the keyword ";" to end lines, this can instruct the formatter to insert a line break after the semicolon.  
* _before(ele)_: The instruction is executed before the matched element. For example, if your grammar contains lists which separate their values with the keyword ",", you can instruct the formatter to suppress the whitespace before the comma.
* _around(ele)_: This is the same as _before(ele)_ combined with  _after(ele)_.  
* _between(ele1, ele2)_: This matches if _ele2_ directly follows _ele1_ in the document. There may be no other tokens in between _ele1_ and _ele2_.
* _bounds(ele1, ele2)_: This is the same as _after(ele1)_ combined with  _before(ele2)_.
* _range(ele1, ele2)_: The rule is enabled when _ele1_ is matched, and disabled when _ele2_ is matched. Thereby, the rule is active for the complete region which is surrounded by _ele1_ and _ele2_.

p. The term _tokens_ is used slightly different here compared to the parser/lexer. Here, a token is a 
keyword or the string that is matched by a terminal rule, data type rule or cross-reference. In the 
terminology of the lexer a data type rule can match a composition of multiple tokens.

p. The parameter _ele_ can be a grammar's _AbstractElement_ or a grammar's _AbstractRule_. All grammar 
rules and almost all abstract elements can be matched. This includes rule calls, parser rules, groups 
and alternatives. The semantic of _before(ele)_, _after(ele)_, etc. for rule calls and parser rules is 
identical to when the parser would "pass" this part of the grammar. The stack of called rules is taken 
into account. The following abstract elements can *not* have assigned formatting instructions:
* Actions. E.g. _{MyAction}_ or _{MyAction.myFeature=current}_.
* Grammar elements nested in data type rules. This is due to to the fact that tokens matched by a data type rule are treated as atomic by the serializer. To format these tokens, please implement a "ValueConverter":#valueconverter. 
* Grammar elements nested in _CrossReferences_.

After having explained how rules can be activated, this is what they can do:
* _setIndentationIncrement()_ increments indentation by one unit at this position. Whether one unit consists of one tab-character or spaces is defined by ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IIndentationInformation}. The default implementation consults Eclipse's _PreferenceStore_.
* _setIndentationDecrement()_ decrements indentation by one unit.
* _setLinewrap()_: Inserts a line-wrap at this position.
* _setLinewrap(int count)_: Inserts _count_ numbers of line-wrap at this position.
* _setLinewrap(int min, int default, int max)_: If the amount of line-wraps that have been at this position before formatting can be determined (i.g. when a node model is present), then the amount of of line-wraps is adjusted to be within the interval [_min_, _max_] and is then reused. In all other cases _default_ line-wraps are inserted. Example: _setLinewrap(0, 0, 1)_ will preserve existing line-wraps, but won't allow more than one line-wrap between two tokens.    
* _setNoLinewrap()_: Suppresses automatic line wrap, which may occur when the line's length exceeds the defined limit.
* _setSpace(String space)_: Inserts the string _space_ at this position. If you use this to insert something else than whitespace, tabs or newlines, a small puppy will die somewhere in this world.
* _setNoSpace()_: Suppresses the whitespace between tokens at this position. Be aware that between some tokens a whitespace is required to maintain a valid concrete syntax. 

h4. Grammar Element Finders

Sometimes, if a grammar contains many similar elements for which the same formatting instructions ought 
to apply, it can be tedious to specify them for each grammar element individually. The 
${org.eclipse.xtext/src/org.eclipse.xtext.IGrammarAccess} provides convenience methods for this. The 
find methods are available for the grammar and for each parser rule.

* _findKeywords(String... keywords)_ returns all keywords that equal one of the parameters.
* _findKeywordPairs(String leftKw, String rightKw)_: returns tuples of keywords from the same grammar rule. Pairs are matched nested and sequentially.  Example: for _Rule: '(' name=ID ('(' foo=ID ')') ')' | '(' bar=ID ')'_ _findKeywordPairs("(", ")")_ returns three pairs.

h3(#fragmentProvider). Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)

Although inter-Xtext linking is not done by URIs, you may want to be able to reference your _EObject_ 
from non-Xtext models. In those cases URIs are used, which are made up of a part identifying the resource 
and a second part that points to an object. 
Each _EObject_ contained in a resource can be identified by a so called _fragment_.

A fragment is a part of an EMF URI and needs to be unique per resource.

The generic resource shipped with EMF provides a generic path-like computation of fragments. These 
fragment paths are unique by default and do not have to be serialized. On the other hand, they can be 
easily broken by reordering the elements in a resource. 

With an XMI or other binary-like serialization it is also common and possible to use UUIDs. UUIDs 
are usually binary and technical, so you don't want them in human readable representations.

However with a textual concrete syntax we want to be able to compute fragments out of the human readable 
information. We don't want to force people to use UUIDs (i.e. synthetic identifiers) or fragile, relative, generic 
paths in order to refer to _EObjects_.

Therefore one can contribute a so called ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IFragmentProvider} 
per language. It has two methods: _getFragment(EObject, Fallback)_ to calculate the fragment of an 
_EObject_ and _getEObject(Resource, String, Fallback)_ to go the opposite direction. The _Fallback_ 
interface allows to delegate to the default strategy - usually the fragment paths described above. 

The following snippet from the "GMF Example":#gmf_integration shows how to use qualified names as fragments:   

bc.. public QualifiedNameFragmentProvider implements IFragmentProvider {

  @Inject
  private IQualifiedNameProvider qualifiedNameProvider;

  public String getFragment(EObject obj, Fallback fallback) {
    String qualifiedName = qualifiedNameProvider.getQualifiedName(obj);
    return qualifiedName != null ? qualifiedName : fallback.getFragment(obj);
  }

  public EObject getEObject(Resource resource, 
                            String fragment, 
                            Fallback fallback) {
    if (fragment != null) {
      Iterator<EObject> i = EcoreUtil.getAllContents(resource, false);
      while(i.hasNext()) {
        EObject eObject = i.next();
        String candidateFragment = (eObject.eIsProxy()) 
            ? ((InternalEObject) eObject).eProxyURI().fragment()
            : getFragment(eObject, fallback);
        if (fragment.equals(candidateFragment)) 
          return eObject;
      }
    }
    return fallback.getEObject(fragment);
  }
}

p. For performance reasons it is usually a good idea to navigate the resource based on the fragment 
information instead of traversing it completely. If you know that your fragment is computed from 
qualified names and your model contains something like _NamedElements_, you should split your fragment
into those parts and query the root elements, the children of the best match and so on.

Furthermore it's a good idea to have some kind of conflict resolution strategy to be able to distinguish
between equally named elements that actually are different, e.g. properties may have the very same qualified
name as entities. 

h2(#encoding). Encoding in Xtext

_Encoding_, AKA _character set_, describes the way characters are encoded into bytes and vice versa. 
Famous standard encodings are "UTF-8" or "ISO-8859-1". The list of available encodings can be determined
by calling _java.nio.Charset.availableCharsets()_. There is also a list of encodings and their 
canonical Java names in the "API docs":http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html.

p. Unfortunately, each platform and/or spoken language tends to define its own native encoding, 
e.g. _Cp1258_ on Windows in Vietnamese or _MacIceland_ on Mac OS X in Icelandic. 

p. In an Eclipse workspace, files, folders, projects can have individual encodings, which are stored
in the hidden file _.settings/org.eclipse.core.resources.prefs_ in each project. If a resource does not have an 
explicit encoding, it inherits the one from its parent recursively. Eclipse chooses the native
platform encoding as the default for the workspace root. You can change the default workspace 
encoding in the Eclipse preferences _Preferences->Workspace->Default text encoding_. If you develop on
different platforms, you should consider choosing an explicit common encoding for your text or code
files, especially if you use special characters. 

p. While Eclipse allows to define and inspect the encoding of a file, your file system usually doesn't. 
Given an arbitrary text file there is no general strategy to tell how it was encoded. If you deploy 
an Eclipse project as a jar (even a plug-in), any encoding information not stored in the file itself 
is lost, too. Some languages define the encoding of a file explicitly, as in the first processing 
instruction of an XML file. Most languages don't. Others imply a fixed encoding or offer enhanced 
syntax for character literals, e.g. _\uXXXX_ in Java. 

p. As Xtext is about textual modeling, it allows to tweak the encoding in various places.

h3. Encoding at Language Design Time

p. The plug-ins created by the _New Xtext Project_ wizard are by default encoded in the workspace's standard
encoding. The same holds for all files that Xtext generates in there.
If you want to change that, e.g. because your grammar uses/allows special characters, you should manually 
set the encoding in the properties of these projects after their creation. Do this before 
adding special characters to your grammar or at least make sure the grammar reads correctly after the 
encoding change. To tell the Xtext generator to generate files in the same encoding, set the encoding 
property in the workflow next to your grammar, e.g.

bc.. Generator {
	encoding ="UTF-8"
	...

h3. Encoding at Language Runtime

p. As each language could handle the encoding problem differently, Xtext offers a service here. 
The ${org.eclipse.xtext/src/org.eclipse.xtext.parser.IEncodingProvider} has a single method 
_getEncoding(URI)_ to define the encoding of the resource with the given URI. Users can implement 
their own strategy but keep in mind that this is not intended to be a long running method. If the 
encoding is stored within the model file itself, it should be extractable in an easy way, like from 
the first line in an XML file. The default implementation returns the default Java character set 
in the runtime scenario. 

p. In the UI scenario, when there is a workspace, users will expect the encoding of the model files 
to be settable the same way as for other files in the workspace. The default implementation 
of the _IEncodingProvider_ in the UI scenario therefore returns the file's workspace encoding 
for files in the workspace and delegates to the runtime implementation for all other resources, 
e.g. models in a jar or from a deployed plug-in. Keep in mind that you are going to loose the 
workspace encoding information as soon as you leave this workspace, e.g. deploy your project.

p. Unless you want to enforce a uniform encoding for all models of your language, we advise to 
override the runtime service only. It is bound in the runtime module using the binding annotation 
_@Runtime_:

bc.. @Override
public void configureRuntimeEncodingProvider(Binder binder) {
    binder.bind(IEncodingProvider.class)
          .annotatedWith(DispatchingProvider.Runtime.class)
          .to(MyEncodingProvider.class);
}

p. For the uniform encoding, bind the plain _IEncodingProvider_ to the same implementation 
in both modules:

bc.. @Override
public Class<? extends IEncodingProvider> bindIEncodingProvider() {
    return MyEncodingProvider.class;
}
	
	
h3. Encoding of an XtextResource

p. An ${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource} uses the _IEncodingProvider_ 
of your language by default. You can override that by passing an option on load and save, e.g.

bc.. Map<?,?> options = new HashMap();
options.put(XtextResource.OPTION_ENCODING, "UTF-8");
myXtextResource.load(options);
options.put(XtextResource.OPTION_ENCODING, "ISO-8859-1");
myXtextResource.save(options);

h3. Encoding in New Model Projects

p. The ${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.projectWizard.SimpleProjectWizardFragment} 
generates a wizard that clients of your language can use to create model 
projects. This wizard expects its templates to be in the encoding of the Generator that created it 
(see above). As for every new project wizard, its output will be encoded in the default encoding of the 
target workspace. 

h3. Encoding of Xtext Source Code

p. The source code of the Xtext framework itself is completely encoded in "ISO 8859-1", which is necessary 
to make the Xpand templates work everywhere (they use french quotation markup). That encoding is hard 
coded into the Xtext generator code. You are likely never going to change that. 

 
h1(#MWE2). MWE2

The Modeling Workflow Engine 2 (MWE2) is a rewritten backwards 
compatible implementation of the Modeling Workflow Engine (MWE). It 
is a declarative, externally configurable generator engine. Users 
can describe arbitrary object compositions by means of a simple, 
concise syntax that allows to declare object instances, attribute 
values and references. One use case - that's where the name had its 
origins - is the definition of workflows. Such a workflow consists 
usually of a number of components that interact with each other. 
There are components to read EMF resources, to perform 
operations (transformations) on them and to write them back or to generate 
any number of other artifacts out of the information. Workflows are 
typically executed in a single JVM. However there are no constraints 
the prevent implementors to provide components that spawn multiple 
threads or new processes.

h2(#MWE2Exampe). Examples

Let's start with a couple of examples to demonstrate some usage 
scenarios for MWE2. The first examples is a simple _HelloWorld_ 
module that does nothing but print a message to standard out. The 
second module is assembled of three components that read an Ecore 
file, transform the contained classifier-names to upper-case and 
serialize the resource back to a new file. The last examples uses 
the life-cycle methods to print the execution time of the workflow.

h3(#MWE2HelloWorld). The Simplest Workflow

The arguably shortest MWE2 module may look like the following 
snippet.

bc.. module HelloWorld 

SayHello {
  message = "Hello World!"
}
p. It configures a very simple workflow component with a message 
that should be printed to _System.out_ when the workflow is 
executed. The module begins with a declaration of its name. It must 
fulfill the Java conventions for fully qualified class-names. That's 
why the module _HelloWorld_ has to be placed into the default 
package of a Java source folder. The second element in the module is 
the class-name _SayHello_ which introduces the root element of the 
module. The interpreter will create an instance of the given 
type and configure it as declared between the curly braces. E.g. the 
assignment _message = "Hello World!"_ in the module will be 
interpreted as an invocation of the _setMessage(String)_ on the 
instantiated object. As one can easily imagine, the implementation 
of the class _SayHello_ looks straight forward:

bc.. import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowComponent;
import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowContext;

public class SayHello implements IWorkflowComponent {

  private String message = "Hello World!";
  public void setMessage(String message) {
    this.message = message;
  }
  public String getMessage() {
    return message;
  }

  public void invoke(IWorkflowContext ctx) {
    System.out.println(getMessage());
  }

  public void postInvoke() {}
  public void preInvoke() {}
}
p. It looks like a simple POJO and that's the philosophy behind MWE2. 
It is easily possible to assemble completely independent objects in 
a declarative manner. To make the workflow executable with the 
_WorkflowRunner_, the component _SayHello_ must be nested in a root 
workflow:

bc.. module HelloWorld 

Workflow {
	component = SayHello {
		message = "Hello World!"
	}
}
p. The class _Workflow_ is actually 
_org.eclipse.emf.mwe2.runtime.workflow.Workflow_ but its package is 
implicitly imported in MWE2 modules to make the the modules more 
concise. The execution result of this workflow will be revealed 
after a quick _Run As .. -> MWE2 Workflow_ in the console as 

bc.. Hello World!
h3(#MWE2SimpleTransformation). A Simple Transformation

The following workflow solves the exemplary task to rename every _EClassifier_ in an _*.ecore_ file.
It consists of three components that read, modify and write the model file:

bc.. module Renamer
Workflow {
  component = ResourceReader {
        uri = "model.ecore"
  }
  component = RenamingTransformer {}
  component = ResourceWriter {
        uri = "uppercaseModel.ecore"
  }
}
p. The implementation of these components is surprisingly simple. It is easily possible to create
own components even for minor operations to automate a process.

p. The _ResourceReader_ simply reads the file with the given _URI_ and stores it in a so called
_slot_ of the workflow context. A slot can be understood as a dictionary or map-entry.

bc.. public class ResourceReader extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    ResourceSet resourceSet = new ResourceSetImpl();
    URI fileURI = URI.createFileURI(uri); 
    Resource resource = resourceSet.getResource(fileURI, true);
    ctx.put(getSlot(), resource);
  }
	
  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}
p. The actual transformer takes the model from the slot and modifies it. It simply iterates the content
of the resource, identifies each _EClassifier_ and sets its name. 

bc.. public class RenamingTransformer extends WorkflowComponentWithSlot {
  private boolean toLowerCase = false;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    EcoreUtil.resolveAll(resource);
    Iterator<Object> contents = EcoreUtil.getAllContents(resource, true);
    Iterator<EClassifier> iter = 
        Iterators.filter(contents, EClassifier.class);
    while(iter.hasNext()) {
      EClassifier classifier = (EClassifier) iter.next();
      classifier.setName(isToLowerCase() 
          ? classifier.getName().toLowerCase()
          : classifier.getName().toUpperCase());
    }
  }

  public void setToLowerCase(boolean toLowerCase) {
    this.toLowerCase = toLowerCase;
  }
  public boolean isToLowerCase() {
    return toLowerCase;
  }
}
p. After the model has been modified it should be written to a new file. That's what the 
_ResourceWriter_ does. It actually takes the resource from the given _slot_ and saves it with
the configured _URI_:

bc.. public class ResourceWriter extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    URI uri = URI.createFileURI(getUri());
    uri = resource.getResourceSet().getURIConverter().normalize(uri);
    resource.setURI(uri);
    try {
      resource.save(null);
    } catch (IOException e) {
      throw new WrappedException(e);
    }
  }

  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}
p. Last but not least, the common super-type for those components looks like this:

bc.. public abstract class WorkflowComponentWithSlot 
      implements IWorkflowComponent {
  private String slot = "model";
  public void setSlot(String slot) {
    this.slot = slot;
  }
  public String getSlot() {
    return slot;
  }
	
  public void postInvoke() {}
  public void preInvoke() {}
}
p. Each of the mentioned implementations is rather simple and can be done in a couple of minutes. 
This is true for many tedious tasks that developers face in their daily work. MWE2 can be used to
automize these tasks with minimum effort.

h3(#MWE2Stopwatch). A Stopwatch

The last example demonstrates how to combine the MWE2 concepts to create a simple stopwatch that
allows to measure the execution time of a set of components. The idea is to add the very same stopwatch
twice as a component to a workflow. It will measure the time from the first pre-invoke to the last
post-invoke event and print the elapsed milliseconds to the console.

bc.. public class StopWatch implements IWorkflowComponent {
  private long start;
  private boolean shouldStop = false;
  public void invoke(IWorkflowContext ctx) {}

  public void postInvoke() {
    if (shouldStop) {
      long elapsed = System.currentTimeMillis() - start;
      System.out.println("Time elapsed: " + elapsed + " ms");
    }
    shouldStop = true;
  }

  public void preInvoke() {
    start = System.currentTimeMillis();
  }
}
p. Clients who want to leverage this kind of stopwatch may use the following pattern. The stopwatch-instance 
will be added as the first component and the last component to a workflow. Everything in between will
be measured. In this case, it is another workflow that does not need know about this decoration. The idea
is to use a local identifier for the instantiated _StopWatch_ and reuse this one at the end to receive
the post-invoke life-cycle event twice. 

bc.. module MeasuredWorkflow

Workflow {
  component = StopWatch: stopWatch {}
  component = @OtherWorkflow {}
  component = stopWatch
}

h2(#MWE2LanguageReference). Language Reference

MWE2 has a few well defined concepts which can be combined to 
assemble arbitrary object graphs in a compact and declarative 
manner.

* A MWE2 file defines a _module_ which exposes its root _component_ as reusable artifact.
* _Properties_ can be used to extract reusable, configurable parts of the workflow.
* Components are mapped to plain vanilla _Java objects_. Arbitrary _set- and add-methods_ are used to configure them.

Let's consider the follow short example module and _SampleClass_ to 
explain these concepts.

bc.. module com.mycompany.Example

import java.util.*

SampleClass {
  singleValue = 'a string'
  multiValue = ArrayList {}
  child = {}
} 

bc.. package com.mycompany;

import java.util.List;

public class SampleClass {
  public void setSingleValue(String value) {..}
  public void addMultiValue(List<?> value) {..}
  public void addChild(SampleClass value) {..}
}

h3(#MWE2JavaReferences). Mapping to Java Classes

p. The module _com.mycompany.Example_ defines a root component of 
type _com.mycompany.SampleClass_. It is possible to use the simple 
class-name because MWE2 uses the very same visibility rules as the 
Java compiler. Classes that are in the same package as the module 
can be referenced by their simple name. The same rule applies for 
classes from the _java.lang_ package. For convenience reasons is the 
package _org.eclipse.emf.mwe2.runtime.workflow_ implicitly imported 
as well as it exposes some library workflow components. However, the
imports are more flexible then in Java since MWE2-imports can be relative, e.g. 
the _import java.*_ resolves the reference _util.ArrayList_ to 
_java.util.ArrayList_.  

p. The root instance of type _SampleClass_ has to be configured 
after it has been created. Therefore the method _setSingleValue_ 
will be called at first. The given parameter is 
_'a string'_. The method is identified by its name which starts with 
_set_. To allow to assign multi-value properties, MWE provides 
access to methods called _add*_ as well. 

p. If the right side of the assignment in the workflow file does not 
define a class explicitly, its type is inferred from the method 
parameter. The line _child = {}_ is equivalent to 
_child = SampleClass {}_ and creates a new instance of _SampleClass_.

p. MWE2 ships with nice tool support. The editor will provide 
content assist for the allowed types and highlight incompatible 
assignments. The available properties for Java classes will be 
proposed as well.

h3(#MWE2Module). Module 

As MWE2 modules have a fully qualified name, it is possible to refer
to them from other modules. The type of the module is derived from
the type of its root component. The _com.mycompany.Example_ can be
assigned at any place where a _com.mycompany.SampleClass_ is expected.

p. Let's create a second module _com.mycompany.Second_ like this:

bc.. module com.mycompany.sub.Second

import com.mycompany.*

SampleClass {
  child = @Example {}
} 
p. The _child_ value will be assigned to an instance of _SampleClass_ 
that is configured as in the first example workflow. This enables
nice composition and a very focused, reusable component design. 

p. As the same rules apply in MWE2 like in Java, the module 
_com.mycompany.sub.Second_ has to be defined in a file called 
_Second.mwe2_ in the package _com.mycompany.sub_. The import semantic
for other modules is the same as for classes. The import statement
allows to refer to _com.mycompany.Example_ with a shortened name.

h3(#MWE2Properties). Properties

MWE2 allows to extract arbitrary information into properties to 
ensure that these pieces are not cluttered around the workflow and 
to allow for easier external customization. The exemplary component 
definition was only changed slightly by introducing a property 
_value_.

bc.. module com.mycompany.Example

var value = 'a string'

SampleClass {
  singleValue = value
}
p. The type of the property will be derived from the default value 
similar to the mechanism that is already known from _set_- and 
_add_-methods. If no default value is given, _java.lang.String_ will
be assumed. However, properties are not limited to strings. The 
second built in type is boolean via the familiar literals _true_ and
_false_. More flexibility is available via actual component literals.

bc.. module com.mycompany.Example

var childInstance = SampleClass {
                      singleValue = "child"
                    }

SampleClass {
  child = childInstance
}
p. If one wants to define string properties that are actual reusable
parts for other properties, she may use defined variables inside other
literals like this: 

bc.. var aString = "part"
var anotherString = "reuse the ${part} here"
p. This is especially useful for file paths in workflows as one would
usually want to define some common root directories only ones in the
workflow and reuse this fragment across certain other file locations.

h3(#MWE2Mandatory). Mandatory Properties

It is not always feasible to define default values for properties. 
That is where mandatory properties come into play. Modules define their
interface not only via their fully qualified name and the type of the
root component but also by means of the defined properties.    

bc.. module com.mycompany.Example

var optional = 'a string'
var mandatory

SampleClass {
  singleValue = optional
  child = {
    singleValue = mandatory
  }
}
p. This version of the example module exposes two externally assignable
properties. The second one has no default value assigned and is 
thereby considered to be mandatory. The mandatory value must be assigned
if we reuse _org.mycompany.Example_ in another module like this:

bc.. module com.mycompany.Second

var newMandatory

@Example {
  mandatory = "mandatoryValue"
  optional = newMandatory
} 
p. Note that it is even possible to reuse another module as the root
component of a new module. In this case we set the mandatory 
property of _Example_ to a specific constant value while the previously
optional value is now redefined as mandatory by means of a new property
without a default value.

p. It is not only possible to define mandatory properties for MWE2 
modules but for classes as well. Therefore MWE2 ships with the 
_@Mandatory_ annotation. If a _set_- or _add_-method is marked as
_mandatory_, the module validation will fail if no value was assigned
to that feature.

h3(#MWE2NamedComponents). Named Components

Properties are not the only way to define something that can be reused.
It is possible to assign a name to any instantiated component whether it's
created from a class literal or from another component. This allows
to refer to previously created and configured instances. Named instances
can come handy for notification and call-back mechanisms or more general
in terms of defined life-cycle events. 

p. If we wanted to assign the created instance to a property of itself,
we could use the following syntax:

bc.. module com.mycompany.Example

SampleClass : self {
  child = self
}
p. A named component can be referenced immediately after its creation but
it is not possible to define forward references in a MWE2 file.

h3(#MWE2AutoInject). Auto Injection

Existing modules or classes often expose a set of properties that 
will be assigned to features of its root component or set- and add- 
methods respectively. In many cases its quite hard to come up with 
yet another name for the very same concept which leads to the situation
where the properties itself have the very same name as the component's
feature. To avoid the overall repetition of assignments, MWE2 offers
the possibility to use the _auto-inject_ modifier on the component 
literal:

bc.. module com.mycompany.Example

var child = SampleClass {}

SampleClass auto-inject {
}
p. This example will implicitly assign the value of the property
_child_ to the feature _child_ of the root component. This is especially
useful for highly configurable workflows that expose dozens of optional
parameters each of which can be assigned to one or more components.

p. The _auto-inject_ modifier can be used for a subset of the available
features as well. It will suppressed for the explicitly set values
of a component.        

h2(#MWE2SyntaxReference). Syntax Reference

The following chapter serves as a reference for the concrete syntax of 
MWE2. The building blocks of a module will be described in a few words.

MWE2 is not sensitive to white-space and allows to define line-comments
and block comments everywhere. The syntax is the same as one is used 
to from the Java language:

bc.. // This is a comment
/* 
  This is another one.
*/
p. Every name in MWE2 can be a fully qualified identifier and must follow 
the Java conventions. However, in contrast to Java identifiers it is 
not allowed to use German umlauts or Unicode escape sequences in 
identifiers. A valid ID-segment in MWE2 starts with a letter or an 
underscore and is followed by any number of letters, numbers or underscores.
An identifier is composed from one or more segments which are delimited
by a '.' dot.

bc.. Name: ID ('.' ID)*;
ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 
p. MWE2 does not use a semicolon as statement delimiter at any place.
 
h3(#MWE2ModuleSyntax). Module

p. !{width:50%}images/mwe2/module.png!

A _module_ consists of four parts. The very first statement in a 
_*.mwe2_ file is the module declaration. The name of the module must 
follow the naming convention for Java classes. That MWE2 file's name 
must therefore be the same as the last segment of the module-name 
and it has to be placed in the appropriate package of a Java source 
path.

p. It is allowed to define any number of import statements in a module.
Imports are either suffixed by a wild-card or concrete for a class 
or module. MWE2 can handle relative imports in case one uses the 
wild-card notation:

bc.. 'import' name '.*'?   

h3(#MWE2PropertySyntax). Property

p. The list of declared properties follows the optional import section.
It is allowed to define modules without any properties. 

p. !{width:50%}images/mwe2/property.png!

p. Each declared property is locally visible in the module. It 
furthermore defines an assignable feature of the module in case one 
refers to it from another module. Properties may either have a 
default value or they are considered to be mandatory. If the type
of property is omitted it will be inferred from the default value. The
default type of a property is _java.lang.String_ so if no default
value is available, the property is mandatory and of type _String_.

p. There are four types of values available in MWE2. One may either
define a string, boolean or component literal or a reference to a
previously defined property. 

h3(#MWE2ComponentSyntax). Component

The last part of a module is the root component. It defines the externally
visible type of the module and may either be created from a Java 
type or from another module.

p. !{width:50%}images/mwe2/component.png!

p. The type of the component can be derived in many cases except for 
the root component. That's why it's optional in the component literal.
If no type is given, it will be inferred from the left side of the
assignment. The assigned feature can either be a declared property
of the module or a _set_- or _add_-method of a Java class.

p. Components can be named to make them referable in subsequent assignments.
Following the _':'_ keyword, one can define an identifier for the 
instantiated component. The identifier is locally visible in the module
and any assignment that is defined after the named component can refer
to this identifier and thereby point to exactly the instantiated object.

p. The next option for a component is _auto-inject_. If this modifier
is set on a component, any available feature of the component that has
the same name as a property or previously created named component will
be automatically assigned.

p. The core of a component is the list of assignments between the curly 
braces. An arbitrary number of values can be set on the component by
means of feature-to-value pairs. 

p. !{width:50%}images/mwe2/assignment.png! 

p. The available constructs on the right hand side of the assignment
are the same as for default values for properties. 

h3(#MWE2StringLiteralsSyntax). String Literals

String values are likely to be the most used literals in MWE2. There 
is a convenient syntax for string concatenation available due to
the high relevance in a description object composition and configuration 
language. MWE2 strings are multi-line strings and can be composed of
several parts.

bc.. var aString = 'a value'
var anotherString = 'It is possible to embed ${aString} into
 a multi-line string'
p. This is especially convenient for path-substitution if one defines
e.g. a common root directory and wants to specify other paths relative
to the base. 

p. There are two different delimiters available for strings. Users 
are free to either use single- or double-quotes to start and end strings. 
If a certain string contains a lot of single-quotes one would better
choose double-quotes as delimiter and vice versa. There is no semantic 
difference between both notations.

p. The escape character in MWE2 is the back-slash _"\"_. It can be used
to write line-breaks or tabular characters explicitly and to escape
the beginning of substitution variables _${_ and the quotes itself. Allowed
escape sequences are:

bc.. \n  .. line break
\r  .. carriage return
\t  .. tabular character
\'  .. single-quote (can be omitted in double-quoted strings)
\"  .. double-quote (can be omitted in single-quoted strings)
\${ .. escape the substitution variable start ${
\\  .. the back-slash itself
p. Other escape sequence are illegal in MWE2 strings.
  
h3(#MWE2BooleanLiterals). Boolean Literals

MWE2 has native support for the boolean type. The literals are _true_ and _false_.

h3(#MWE2References). References

Each assigned value in MWE2 either as default for properties or in a
component assignment can be a reference to a previously declared property
or named component. The can be referenced intuitively by their name.


h1(#ide_concepts). IDE Concepts

For the following part we will refer to a concrete example grammar in order to explain certain aspect 
of the UI more clearly. The used example grammar is as follows:

bc.. grammar org.eclipse.text.documentation.Sample 
    with org.eclipse.xtext.common.Terminals

generate gen 'http://www.eclipse.org/xtext/documentation/Sample'

Model :
  "model" intAttribute=INT (stringDescription=STRING)? "{" 
     (rules += AbstractRule)* 
  "}" 
;

AbstractRule:
  RuleA | RuleB
;

RuleA :
   "RuleA" "(" name = ID ")" ;

RuleB return gen::CustomType:
   "RuleB" "(" ruleA = [RuleA] ")" ;

p. 


h2(#labelProvider). Label Provider

There are various places in the UI in which model elements have to be presented to the user: In the 
"outline view":#outline, in "hyper links":#hyperlinking, in "content proposals":#contentAssist, 
find dialogs etc. Xtext allows to customize each of these appearances by individual _ILabelProviders_. 

An _ILabelProvider_ has two methods: _getText(Object)_ returns the text in an object's label, 
while _getImage(Object)_ returns the icon. In addition, the Eclipse UI framework offers the 
_IStyledLabelProvider_, which returns a styled string (i.e. with custom fonts, colors etc.) in the 
_getStyledText(Object)_ method. 

Almost all label providers in the Xtext framework inherit from the base class 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.label.AbstractLabelProvider} which unifies both 
approaches. Subclasses can either return a styled string or a string in the _doGetText(Object)_ method. 
The framework will automatically convert it to a styled text (with default styles) or to a plain text 
in the respective methods. 

Dealing with images can be cumbersome, too, as image handles tend to be scarce system resources. 
The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.label.AbstractLabelProvider} helps you managing 
the images: In your implementation of _doGetImage(Object)_ you can as well return an _Image_ or a string, 
representing a path in the _icons/_ folder of the containing plug-in. This path is actually 
configurable by Google Guice. Have a look at the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.PluginImageHelper} to learn about the 
customizing possibilities.

If you have the 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.labeling.LabelProviderFragment} in the 
list of generator fragments in the MWE2 workflow for your language, it will automatically create 
stubs and bindings for an "_{MyLang}EObjectLabelProvider_":#EObjectLabelProvider and an 
"_{MyLang}DescriptionLabelProvider_":#DescriptionLabelProvider which you can implement by manually. 

h3(#EObjectLabelProvider). Label Providers For EObjects

The first set of label providers refers to actually loaded and thereby available model elements. 
By default, Xtext binds the _DefaultEObjectLabelProvider_ to all use cases, but you can change the 
binding individually for the Outline, Content Assist or other places. For that purpose, there is a 
so called _binding annotation_ for each use case. For example, to use a custom 
_MyContentAssistLabelProvider_ to display elements in the content assist, you have to override

bc.. @Override
public void configureContentProposalLabelProvider(Binder binder) {
  binder.bind(ILabelProvider.class)
    .annotatedWith(ContentProposalLabelProvider.class)
    .to(MyContentAssistLabelProvider.class);
}

p.in your language's UI module. 

p. If your grammar uses an imported _EPackage_, there may be an existing _.edit_ plug-in generated 
by EMF that also provides label providers for model elements. To use this as a fallback, your label 
provider should call the constructor with the 
delegate parameter and use DI for the initialization, e.g.

bc.. public class MyLabelProvider {
	@Inject	
	public MyLabelProvider(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}
	...
}  

h4(#DefaultEObjectLabelProvider). DefaultEObjectLabelProvider

The default implementation of the _LabelProvider_ interface utilizes the polymorphic dispatcher idiom 
to implement an external visitor as the requirements of the LabelProvider are kind of a best match for 
this pattern. It comes down to the fact that the only thing you need to do is to implement a method 
that matches a specific signature. It either provides a image filename or the text to be used to 
represent your model element. Have a look at following example to get a more detailed idea about 
the _DefaultEObjectLabelProvider_.

bc.. public class SampleLabelProvider extends DefaultLabelProvider {

  String text(RuleA rule) {
    return "Rule: " + rule.getName();
  }
  
  String image(RuleA rule) {
    return "ruleA.gif";
  }
  
  String image(RuleB rule) {
    return "ruleB.gif";
  }
}
	
p. What is especially nice about the default implementation is the actual reason for its class 
name: It provides very reasonable defaults. To compute the label for a certain model element, it will 
at first have a look for an EAttribute _name_ and try to use this one. If it cannot find such a feature, 
it will try to use the first feature, that can be used best as a label. At worst it will return the 
class name of the model element, which is kind of unlikely to happen.

p. You can a also customize error handling by overriding the methods _handleTextError()_ or 
_handleImageError()_.
 
h3(#DescriptionLabelProvider). Label Providers For Index Entries

Xtext maintains an index of all model elements to allow quick searching and linking without loading 
the referenced resource (See the chapter on "index-based scopes":#index_based for details). The 
elements from this index also appear in some UI contexts, e.g. in the _Find model elements_ dialog or 
in the _Find references_ view. For reasons of scalability, the UI should not automatically load 
resources, so we need another implementation of a label provider that works with the elements from the 
index, i.e. _IResourceDescription_, _IEObjectDescription_, and _IReferenceDescription_.

The default implementation of this service is the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.label.DefaultDescriptionLabelProvider}. It employs the 
same polymorphic dispatch mechanism as the "DefaultEObjectLabelProvider":#DefaultEObjectLabelProvider. 
The default text of an _EObjectDescription_ is its indexed name. The image is resolved by dispatching 
to _image(EClass)_ with the _EClass_ of the described object. This is likely the only method you want 
to override. _IResourceDescriptions_ will be represented with their path and the icon registered for 
your language's editor. 

To have a custom description label provider, make sure it is bound in your UI module:

bc. public void configureResourceUIServiceLabelProvider(Binder binder) {
  binder.bind(ILabelProvider.class)
    .annotatedWith(ResourceServiceDescriptionLabelProvider.class)
    .to(MyCustomDefaultDescriptionLabelProvider.class);
}
	

h2(#contentAssist). Content Assist

The Xtext generator, amongst other things, generates the following two content assist (CA) related artifacts:

* an abstract proposal provider class named _Abstract[Language]ProposalProvider_ generated into the _src-gen_ folder within the _ui_ project
* a concrete sub-class in the _src_-folder of the _ui_ project called _[Language]ProposalProvider_

First we will investigate the generated _Abstract[Language]ProposalProvider_ with methods that look like this:

h3. ProposalProvider

bc.. public void complete[TypeName]_[FeatureName](
  EObject model, 
  Assignment assignment, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // clients may override
}

public void complete_[RuleName](
  EObject model, 
  RuleCall ruleCall, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // clients may override
}

p. The snippet above indicates that the generated ProposalProvider class contains a _complete*_-method 
for each assigned feature in the grammar and for each rule. The brackets are place-holders that should 
give a clue about the naming scheme used to create the various entry points for clients. The generated 
proposal provider falls back to some default behavior for cross-references and keywords. Furthermore 
it inherits the logic that was introduced in reused grammars. 

Clients who want to customize the behavior may override the methods from the 
_AbstractProposalProvider_ or introduce new methods with a specialized first parameter. The framework 
dispatches method calls according to the current context to the most concrete implementation, that 
can be found.

It is important to know, that for a given offset in a model file, many possible grammar elements exist. 
The framework dispatches to the method declarations for any valid element. That means, that a bunch 
of _complete*_ methods may be called.

h3. Sample Implementation

To provide a dummy proposal for the description of a model object, you may introduce a specialization 
of the generated method and implement it as follows. This will give 'Description for model #7' for a 
model with the intAttribute '7'

bc.. public void completeModel_StringDescription (
  Model model, 
  Assignment assignment, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // call implementation in superclass
  super.completeModel_StringDescription(
    model, 
    assignment, 
    context, 
    acceptor);

  // compute the plain proposal
  String proposal = "Description for model #" + model.getIntAttribute();

  // convert it to a valid STRING-terminal
  proposal = getValueConverter().toString(proposal, "STRING");

  // create the completion proposal
  // the result may be null as the createCompletionProposal(..) methods 
  // check for valid prefixes
  // and terminal token conflicts
  ICompletionProposal completionProposal = 
    createCompletionProposal(proposal, context);

  // register the proposal, the acceptor handles null-values gracefully
  acceptor.accept(completionProposal);
}

h2(#quickfixes). Quick Fixes

For validations written using the "AbstractDeclarativeValidator":#custom_validation 
it is possible to provide corresponding quick fixes in the editor. To be able to implement a quick fix 
for a given diagnostic (a warning or error) the underlying _cause_ of the diagnostic must be known 
(i.e. what actual problem does the diagnostic represent?), otherwise the fix doesn't know what needs 
to be done. As we don't want to deduce this from the diagnostic's error message we associate a problem 
specific _code_ with the diagnostic.

In the following example taken from the _DomainmodelJavaValidator_ 
the diagnostic's _code_ is given by the third argument to the _warning()_ method and it is a reference 
to the static _String_ field _==INVALID_TYPE_NAME==_ in the validator class.

bc.. warning("Name should start with a capital", 
    DomainmodelPackage.TYPE__NAME, INVALID_TYPE_NAME, type.getName());

p. Now that the validation has a unique code identifying the problem we can register quick fixes for it. 
We start by adding the 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.quickfix.QuickfixProviderFragment} 
to our workflow and after regenerating the code we should find an empty class _MyDslQuickfixProvider_ 
in our DSL's UI project and new entries in the _==plugin.xml_gen==_ file.

Continuing with the _==INVALID_TYPE_NAME==_ problem from the Domainmodel example we add a method with which 
the problem can be fixed (have a look at the _DomainmodelQuickfixProvider_ for details):

bc.. @Fix(DomainmodelJavaValidator.INVALID_TYPE_NAME)
public void fixName(final Issue issue, IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Capitalize name", // quick fix label
    "Capitalize name  of '" + issue.getData()[0] + "'",  // description 
    "upcase.png",      // quick fix icon
    new IModification() {
      public void apply(IModificationContext context) 
                                             throws BadLocationException {
        IXtextDocument xtextDocument = context.getXtextDocument();
        String firstLetter = xtextDocument.get(issue.getOffset(), 1);
        xtextDocument.replace(issue.getOffset(), 1, 
                              Strings.toFirstUpper(firstLetter));
      }
    }
  );
}

p. By using the correct signature (see below) and annotating the method with the _@Fix_ annotation 
referencing the previously specified issue code from the validator, Xtext knows that this method 
implements a fix for the problem. This also allows us to annotate multiple methods as fixes for the 
same problem.

The first three parameters given to the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor} define the 
UI representation of the quick fix. As the document is not necessarily loaded when the quick fix is 
offered, we need to provide any additional data from the model that we want to refer to in the UI 
when creating the issue in the validator above. In this case, we provided the existing type name. 
The additional data is available as _Issue.getData()_. As it is persisted in markers, only strings 
are allowed. 

The actual model modification is implemented in the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IModification}. 
The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IModificationContext} provides 
access to the erroneous document. In this case, we're using Eclipse's _IDocument_ API to replace a 
text region.    

If you prefer to implement the quick fix in terms of the semantic model use a 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.ISemanticModification} instead. 
Its _apply(EObject, IModificationContext)_ method will be invoked inside a modify-transaction and the 
first argument will be the erroneous semantic element. This makes it very easy for the fix method to 
modify the model as necessary. After the method returns the model as well as the Xtext editor's content 
will be updated accordingly. If the method fails (throws an exception) the change will not be committed. 
The following snippet shows a semantic quick fix for a similar problem.

bc.. @Fix(DomainmodelJavaValidator.INVALID_FEATURE_NAME)
public void fixFeatureName(final Issue issue, 
                           IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Uncapitalize name",    // label
    "Uncapitalize name of '" + issue.getData()[0] + "'", // description
    "upcase.png",           // icon 
    new ISemanticModification() {
      public void apply(EObject element, IModificationContext context) {
        ((Feature) element).setName(
            Strings.toFirstLower(issue.getData()[0]));
      }
    }
  );
}

h3. Quickfixes for Linking Errors and Syntax Errors

You can even define quick fixes for linking errors. The issue codes are assigned by the ${org.eclipse.xtext/src/org.eclipse.xtext.linking.ILinkingDiagnosticMessageProvider}. Have a look at the domain model example how to add quick fixes for these errors.

Analogously, there is the ${org.eclipse.xtext/src/org.eclipse.xtext.parser.antlr.ISyntaxErrorMessageProvider} to assign issue codes to syntactical errors.

  

h2(#templates). Template Proposals

Xtext-based editors automatically support code templates. That means that you get the corresponding 
preference page where users can add and change template proposals. If you want to ship a couple of 
default templates, you have to put a file named _templates.xml_ inside the _templates_ directory of 
the generated UI-plug-in. This file contains templates in a format as described in the 
"Eclipse online help":http://help.eclipse.org/ganymede/topic/org.eclipse.cdt.doc.user/tasks/cdt_t_imp_code_temp.htm .

!images/preferences_templates.png!

By default Xtext registers _ContextTypes_ for each rule (_[languageName].[RuleName]_) and for each 
keyword (_[languageName].kw_[keyword]_). If you don't 
like these defaults you'll have to subclass 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.templates.XtextTemplateContextTypeRegistry} 
and configure it via "Guice":#guicemodules. 

In addition to the standard template proposal extension mechanism, Xtext ships with a predefined set 
of _TemplateVariableResolvers_ to resolve special variable types inside a given template 
(i.e. _TemplateContext_). Besides the standard template variables available in 
_org.eclipse.jface.text.templates.GlobalTemplateVariables_ like _${user}_, _${date}_, _${time}_, 
_${cursor}_, etc., these _TemplateVariableResolver_ support the automatic resolving of 
CrossReferences (type _CrossReferences_) and Enumerations (type _Enum_) like it is explained in the 
following sections.

It is best practice to edit the templates in the preferences page, export them into the 
_templates.xml_-file and put this one into the _templates_ folder of your UI-plug-in. However, these 
templates will not be visible by default. To fix it, you have to manually edit the xml-file and insert 
an ID attribute for each template element.

h3. CrossReference TemplateVariableResolver

Xtext comes with a specific template variable resolver _TemplateVariableResolver_ called 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.templates.CrossReferenceTemplateVariableResolver}, 
which can be used to place cross-references within a template.

The syntax is as follows:

bc. ${<displayText>:CrossReference([<MyPackageName>.]<MyType>.<myRef>)}

For example the following template:

bc.. <template name="transition" description="event transition" id="transition"
  context="org.eclipse.xtext.example.FowlerDsl.Transition" enabled="true">
    ${event:CrossReference('Transition.event')} => 
    	${state:CrossReference('Transition.state')
</template>

p. yields the text _event => state_ and allows selecting any events and states using a drop down.

!images/templates_crossref.png!

h3. Enumeration TemplateVariableResolver

The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.templates.EnumTemplateVariableResolver} 
resolves a template variable to _EEnumLiteral_ literals
which are assignment-compatible to the enumeration type declared as the first parameter of the the _Enum_ _TemplateVariable_. 
 
The syntax is as follows:   
 
bc. ${<displayText>:Enum([<MyPackage>.]<EnumType>)

For example the following template (taken from the domainmodel example):

bc.. <template name="Operation" description="template for an Operation"
  id="org.eclipse.xtext.example.Domainmodel.Operation"
  context="org.eclipse.xtext.example.Domainmodel.Operation"
  enabled="true">
    ${visibility:Enum('Visibility')} op ${name}(${cursor}):
        ${type:CrossReference('Operation.type')}
</template>

p. yields the text _public op name(): type_ where the display text 'public' is replaced with a drop 
down filled with the literal values as defined in the _EEnum_ _Visibility_. Also, _name_ and _type_ 
are template variables.

!images/templates_enum.png!

h2(#outline). Outline View

h3. We redesigned the outline in 2.0. The following no longer reflects the current state of implementation. 

TODO: 
Rewrite this section

Xtext provides an outline view to help you navigate your models. By default, it provides a hierarchical 
view on your model and allows you to sort tree elements alphabetically. Selecting an element in the 
outline will highlight the corresponding element in the text editor. Users can choose to synchronize 
the outline with the editor selection by clicking the _Link with Editor_ button.

!images/sample_outline.png!

You can customize various aspects of the outline by providing implementation for its various interfaces. 
The following sections show how to do this.

h3. Influencing the Outline Structure

_outdated_ 

In its default implementation, the outline view shows the containment hierarchy of your model. 
This should be sufficient in most cases. If you want to adjust the structure of the outline, i.e., 
by omitting a certain kind of node or by introducing additional even virtual nodes, you customize 
the outline by implementing 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.transformer.ISemanticModelTransformer}.

The Xtext wizard creates an empty transformer class (_MyDslTransformer_) for your convenience. To 
transform the semantic model delivered by the Xtext parser, you need to provide transformation methods 
for each of the EClasses that are of interest:

bc.. public class MyDslTransformer extends 
    AbstractDeclarativeSemanticModelTransformer { 
  /**
   * This method will be called by naming convention:
   * - method name must be createNode
   * - first param: subclass of EObject
   * - second param: ContentOutlineNode 
   */
  public ContentOutlineNode createNode(
      Attribute semanticNode, ContentOutlineNode parentNode) {
    ContentOutlineNode node = super.newOutlineNode(semanticNode, parentNode);
    node.setLabel("special " + node.getLabel());
    return node;
  }
  
  public ContentOutlineNode createNode(
      Property semanticNode, ContentOutlineNode parentNode) {
    ContentOutlineNode node = super.newOutlineNode(semanticNode, parentNode);
    node.setLabel("pimped " + node.getLabel());
    return node;
  }

  /**
   * This method will be called by naming convention:
   * - method name must be getChildren
   * - first param: subclass of EObject
   */
  public List<EObject> getChildren(Attribute attribute) {
    return attribute.eContents();
  }

  public List<EObject> getChildren(Property property) {
    return NO_CHILDREN;
  }
}

p. To make sure Xtext picks up your new outline transformer, you have to register your implementation 
with your UI module. This binding is usually added by the respective generator fragment.

bc.. public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class<? extends ISemanticModelTransformer> 
  		bindISemanticModelTransformer() {
    return MyDslTransformer.class;
  }
  ...
}

h3. Filtering

_outdated_ 

Often, you want to allow users to filter the contents of the outline to make it easier to concentrate 
on the relevant aspects of the model. To add filtering capabilities to your outline, you need to add 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.actions.AbstractFilterAction}s to the 
outline. Actions can be contributed by implementing and registering a 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.actions.DeclarativeActionBarContributor}.

To register a _DeclarativeActionBarContributor_, add the following lines to your _MyDslUiModule_ class:

bc.. public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class<? extends IActionBarContributor> bindIActionBarContributor() {
    return MyDslActionBarContributor.class;
  }
  ...
}

p. The action bar contributor will look like this:

bc.. public class MyDslActionBarContributor extends
    DeclarativeActionBarContributor {
  public Action addFilterParserRulesToolbarAction(
      XtextContentOutlinePage page) {
    return new FilterFooAction(page);
  }
}

p. Filter actions must extend _AbstractFilterAction_ (this ensures that the action toggle state is 
handled correctly):

bc.. public class FilterFooAction extends AbstractFilterAction {

  public FilterFooAction(XtextContentOutlinePage outlinePage) {
    super("Filter Foo", outlinePage);
    setToolTipText("Show / hide foo");
    setDescription("Show / hide foo");
    setImageDescriptor(Activator.getImageDescriptor("icons/foo.gif"));
    setDisabledImageDescriptor(
    	Activator.getImageDescriptor("icons/foo.gif"));
  }

  @Override
  protected String getToggleId() {
    return "FilterFooAction.isChecked";
  }
	
  @Override
  protected ViewerFilter createFilter() {
    return new FooOutlineFilter();
  }

}

p. The filtering itself will be performed by _FooOutlineFilter_:

bc.. public class FooOutlineFilter extends ViewerFilter {

  @Override
  public boolean select(
      Viewer viewer, Object parentElement, Object element) {
    if ((parentElement != null) 
        && (parentElement instanceof ContentOutlineNode)) {
      ContentOutlineNode parentNode = (ContentOutlineNode) parentElement;
      EClass clazz = parentNode.getClazz();
      if (clazz.equals(MyDslPackage.Literals.ATTRIBUTE)) {
        return false;
      }
    }
    return true;
  }

}

h3. Context menus

_outdated_ 

You might want to register context menu actions for specific elements in the outline, e.g. to allow 
users of your DSL to invoke a generator or to validate the selected element. As all elements in the 
outline are ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.ContentOutlineNode}s, you 
cannot easily register an "Object contribution":http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/workbench_basicext_popupMenus.htm. 
(Besides, using the extension point _org.eclipse.ui.popupMenus_ is regarded somewhat old school - 
you should rather use the new command and expression framework, as depicted below).

To register context menus for specific node types of your Ecore model, we need to:

* implement ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.actions.IContentOutlineNodeAdapterFactory} which will translate ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.ContentOutlineNode}s to their underlying node type
* register a menu contribution to add a command / handler pair to the context menu for the specific node types you're interested in.

h4. Registering an _IContentOutlineNodeAdapterFactory_

The Xtext code generator creates a subclass of 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.outline.actions.DefaultContentOutlineNodeAdapterFactory}. 
All we need to do is specify a list of types that we later want to bind context menu contributions to. 

bc.. public class MyDslContentOutlineNodeAdapterFactory extends 
    DefaultContentOutlineNodeAdapterFactory {
  private static final Class<?>[] types = { Attribute.class };

  public Class<?>[] getAdapterList() {
    return types;
  }
}

p. If you want to bind context menu actions to nodes representing _Attribute_ and _Entity_, you need to 
change the declaration of _types as follows:

bc. private static final Class<?>[] types = { Attribute.class, Entity.class };

h4. Registering a Menu Contribution

_outdated_ 

You can now add command / handler pairs to the context menu.

First, you need to define a command - it will serve as a handle to glue together the handler 
and the menu contribution:

bc.. 
<extension
  point="org.eclipse.ui.commands">
  <command
    id="org.example.mydsl.ui.editor.outline.SampleOutlineCommand"
    name="Sample Command"
    description="Just a sample command">
  </command>
</extension>

p. Next, you need to define a handler which will eventually execute the code to operate on the 
selected node. Please pay special attention to the attribute _commandId_ - it must match the _id_ 
attribute of your command. 

bc.. 
<extension
  point="org.eclipse.ui.handlers">
  <handler
    class="org.example.mydsl.ui.editor.outline.SampleOutlineNodeHandler"
    commandId="org.example.mydsl.ui.editor.outline.SampleOutlineCommand">
  </handler>
</extension>

p. Finally, define a _menuContribution_ to add the command to the context menu:

bc.. 
<extension
  point="org.eclipse.ui.menus">
  <menuContribution
    locationURI="popup:org.eclipse.xtext.ui.outline?after=additions">
    <command
      commandId="org.example.mydsl.ui.editor.outline.SampleOutlineCommand"
      label="Sample action registered for Attributes">
      <visibleWhen checkEnabled="false">
        <iterate>
          <adapt type="org.example.mydsl.Attribute" />
        </iterate>
      </visibleWhen>
    </command>
  </menuContribution>
</extension>

p. Again, pay attention to the _commandId_ attribute. The connection between your node type(s) and 
the menu contribution is made by the part _<adapt type="org.example.mydsl.Attribute" />_. 

h3(#quick_outline). Quick Outline

_outdated_ 

Xtext also provides a quick outline: If you press CTRL-O in an Xtext editor, the outline of the model is shown 
in a popup window. The quick outline also supports drill-down search with wildcards. To enable the quick outline,
you have to put the ${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.outline.QuickOutlineFragment} 
into your workflow.



h2(#hyperlinking). Hyperlinking

The Xtext editor provides hyperlinking support for any tokens corresponding to cross-references in your 
grammar definition. You can either CTRL-click on any of these tokens or hit F3 
while the cursor position is at the token in question and this will take you to the referenced model 
element. As you'd expect this works for references to elements in the same resource as well as for 
references to elements in other resources. In the latter case the referenced resource will first be 
opened using the corresponding editor.

h3(#locationProvider). Location Provider

When navigating a hyperlink, Xtext will also select the text region corresponding to the referenced model 
element. Determining this text region is the responsibility of the 
${org.eclipse.xtext/src/org.eclipse.xtext.resource.ILocationInFileProvider}. The default implementation 
(${org.eclipse.xtext/src/org.eclipse.xtext.resource.DefaultLocationInFileProvider}) implements a best 
effort strategy which can be summarized as:

# If the model element's type (i.e. _EClass_) declares a feature _name_ then return the region of the corresponding token(s). As a fallback also check for a feature _id_.
# If the model element's parse tree contains any top-level tokens corresponding to _ID_ rule calls in the grammar then return a region spanning all those tokens.
# As a last resort return the region corresponding to the first keyword token of the referenced model element.

h4. Customized Location Provider

As the default strategy is a best effort it may not always result in the selection you want. If that's 
the case you can "override":#guicemodules the _ILocationInFileProvider_ binding in the UI module as 
in the following example:

bc.. public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class<? extends ILocationInFileProvider> 
  		bindILocationInFileProvider() {
    return MyDslLocationInFileProvider.class;
  }
  ...
}

p. Often the default strategy only needs some guidance (e.g. selecting the text corresponding to another 
feature than _name_). In that case you can simply subclass _DefaultLocationInFileProvider_ and override 
the methods _getIdentifierFeature()_ and / or _useKeyword()_ to guide the first and last steps of the strategy 
as described above (see ${org.eclipse.xtext.xtext.ui/src/org.eclipse.xtext.xtext.ui.XtextLocationInFileProvider} 
for an example).

h3. Customizing Available Hyperlinks
 
The hyperlinks are provided by the ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.hyperlinking.HyperlinkHelper}
which will create links for cross-referenced objects by default. Clients may want to override 
_createHyperlinksByOffset(XtextResource, int, IHyperlinkAcceptor)_ to provide additional links or 
supersede the default implementation. 

h2(#highlighting). Syntax Coloring

Besides the already mentioned advanced features like content assist and code formatting the powerful 
editor for your DSL is capable to mark up your model-code to improve the overall readability. It is 
possible to use different colors and fonts according to the meaning of the different parts of your 
input file. One may want to use some decent colors for large blocks of comments while identifiers, 
keywords and strings should be colored differently to make it easier to distinguish between them. 
This kind of text decorating markup does not influence the semantics of the various sections but 
helps to understand the meaning and to find errors in the source code.

!{width:100%}images/highlighting.png!

The highlighting is done in two stages. This allows for sophisticated algorithms that are executed 
asynchronously to provide advanced coloring while simple pattern matching may be used to highlight 
parts of the text instantaneously. The latter is called lexical highlighting while the first is based 
on the meaning of your different model elements and therefore called semantic highlighting.

When you introduce new highlighting styles, the preference page for your DSL is automatically 
configured and allows the customization of any registered highlighting setting. They are automatically 
persisted and reloaded on startup.

!{width:50%}images/preferences_syntax.png!

h3. Lexical Highlighting

The lexical highlighting can be customized by providing implementations of the interface 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightingConfiguration} and 
the abstract class ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.AbstractTokenScanner}. 
The latter fulfills the interface _ITokenScanner_ from the underlying JFace Framework, which may be 
implemented by clients directly.

The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightingConfiguration} is used
to register any default style without a specific binding to 
a pattern in the model file. It is used to populate the preferences page and to initialize the 
_ITextAttributeProvider_, which in turn is the component that is used to obtain the actual settings 
for a style's id. An implementation will usually be very similar to the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.DefaultHighlightingConfiguration} and read like this: 

bc.. public class DefaultHighlightingConfiguration 
    implements IHighlightingConfiguration {

  public static final String KEYWORD_ID = "keyword";
  public static final String COMMENT_ID = "comment";

  public void configure(IHighlightingConfigurationAcceptor acceptor) {
    acceptor.acceptDefaultHighlighting(KEYWORD_ID, "Keyword", 
        keywordTextStyle());
    acceptor.acceptDefaultHighlighting(COMMENT_ID, "Comment", // ...
    // ...
  }
  
  public TextStyle keywordTextStyle() {
    TextStyle textStyle = new TextStyle();
    textStyle.setColor(new RGB(127, 0, 85));
    textStyle.setStyle(SWT.BOLD);
    return textStyle;
  }
  
  // ...
}

p. Implementations of the _ITokenScanner_ are responsible for splitting the content of a document into 
various parts, the so called tokens, and return the highlighting information for each identified range. 
It is critical that this is done very fast because this component is used on each keystroke. Xtext 
ships with a default implementation that is based on the lexer that is generated by ANTLR which is very 
lightweight and fast. This default implementation can be customized by clients easily. They simply have 
to bind another implementation of the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.AbstractAntlrTokenToAttributeIdMapper}. 
To get an idea about it, have a look at the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.DefaultAntlrTokenToAttributeIdMapper}.

h3. Semantic Highlighting

The semantic highlighting stage is executed asynchronously in the background and can be used to calculated 
highlighting states based on the meaning of the different model elements. Users of the editor will 
notice a very short delay after they have edited the text until the styles are actually applied to the 
document. This keeps the editor responsive while providing aid when reading and writing your model.

As for the lexical highlighting the interface to register the available styles is the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightingConfiguration}. 
The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.ISemanticHighlightingCalculator} 
is the primary hook to implement the logic that will compute to-be-highlighted ranges based on the model 
elements. 

The framework will pass the current XtextResource and an 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.syntaxcoloring.IHighlightedPositionAcceptor} to 
the calculator. It is ensured, that the resource will not be altered externally until the called method 
_provideHighlightingFor()_ returns. However, the resource may be null. The implementor's task is to 
navigate your semantic model and compute various ranges based on the attached node information and 
associate styles with them. This may read similar to the following snippet:

bc.. public void provideHighlightingFor(XtextResource resource, 
    IHighlightedPositionAcceptor acceptor) {
  if (resource == null)
    return;
    
  Iterable<AbstractNode> allNodes = NodeUtil.getAllContents(
    resource.getParseResult().getRootNode());
  for (AbstractNode node : allNodes) {
    if (node.getGrammarElement() instanceof CrossReference) {
      acceptor.addPosition(node.getOffset(), node.getLength(), 
        MyHighlightingConfiguration.CROSS_REF);
    }
  }
}

p. This example refers to an implementation of the _IHighlightingConfiguration_ that registers a style 
for a cross-reference. It is pretty much the same implementation as for the previously mentioned sample 
of a lexical _IHighlightingConfiguration_.

bc.. public class HighlightingConfiguration 
    implements IHighlightingConfiguration {
  
  // lexical stuff goes here 
  // ..
  public final static String CROSS_REF = "CrossReference"; 

  public void configure(IHighlightingConfigurationAcceptor acceptor) {
    // lexical stuff goes here 
    // ..
    acceptor.acceptDefaultHighlighting(CROSS_REF, 
      "Cross-References", crossReferenceTextStyle());
  }
  
  public TextStyle crossReferenceTextStyle() {
    TextStyle textStyle = new TextStyle();
    textStyle.setStyle(SWT.ITALIC);
    return textStyle;
  }
}

p. The implementor of an _IHighlightingCalculator_ should be aware of performance to ensure a good user 
experience. It is probably not a good idea to traverse everything of your model when you will only 
register a few highlighted ranges that can be found easier with some typed method calls. It is strongly 
advised to use purposeful ways to navigate your model. The parts of Xtext's core that are responsible 
for the semantic highlighting are pretty optimized in this regard as well. The framework will only 
update the ranges that actually have been altered, for example. This speeds up the redraw process. It 
will even move, shrink or enlarge previously announced regions based on a best guess before the next 
semantic highlighting pass has been triggered after the user has changed the document.





h2(#projectwizard). Project Wizard

Optionally, Xtext can generate a _New Project Wizard_ for your DSL. Using this wizard a user can create a new 
project with only a few clicks that is configured with the right dependencies and natures. By default 
it contains a sample model file and workflow that serve as a scaffold for the user. Furthermore it 
has the Xtext nature and thereby the builder assigned. You enable the generation of the project wizard by adding the 
_SimpleProjectWizardFragment_ fragment to the "workflow":#generator_fragment:

bc.. import org.eclipse.xtext.ui.generator.* 

// project wizard fragment
fragment = projectWizard.SimpleProjectWizardFragment {
  generatorProjectName = "${projectName}.generator"
  modelFileExtension = file.extensions
}

p. Here

* the _generatorProjectName_ is used to specify the project that contains the workflows and templates used to generate artifacts from your DSL. The generated project wizard uses this to add a corresponding dependency to the created project.
* and the _modelFileExtension_ specifies the default file extension associated with your DSL. When the user clicks the _Finish_ button the project wizard will look for a file with the given extension in the created project and open a editor. 

p. After running the Xtext generator, the DSL's UI project will contain a new Xpand template 
_MyDslNewProject.xpt_ in the _src_ folder in the package _[base-package].ui.wizard_. 
Note: It may be necessary to manually merge the new entry in the _plugin.xml___gen_ into your 
_plugin.xml_ of the UI project to enable the wizard contribution.

p. The generated Xpand template will be expanded by the project wizard when the user clicks the _Finish_ button 
and it is responsible for initializing the project with some sample content. When finishing the wizard 
the template will be used to create a sample model file and a simple workflow to run the 
model through the generator project's _MyDslGenerator.mwe_ workflow. However, this is only a pragmatic default.
As the Xpand template is in the _src_ source folder you may of course modify it to generate whatever 
initial content you want for a new project. Just make sure to leave the top-level _main_ definition 
in place, as that is the interface for the project wizard.

p. *Note:* To edit the generated Xpand template you should check that the _JavaBeans meta model contributor_ 
is enabled under _Preferences > Xtend/Xpand_. Further you should also configure the UI project with the 
Xpand/Xtend nature using _Configure > Add Xpand/Xtend Nature_ in the context menu.

h3. Customizing the Project Wizard

p. To further customize the creation of the project you can implement your own _project creator_. 
The default project creator is represented by the generated class _MyDslProjectCreator_ in the
_src-gen_ folder. It is highly extensible. Without any changes it will simply create a new plug-in project 
with the Xtext nature assigned. Afterwards it will execute the _main_ definition of the Xpand template 
as described above.

p. To add more pages or input fields to the project wizard you should subclass the class 
_MyDslNewProjectWizard_ as appropriate. Don't forget to register the subclass in the UI project's 
_MyDslUiModule_. You may also want to make additionally entered user data available to the Xpand template. 
In this case you should enhance the _MyDslProjectInfo_ to allow that one to hold the information. This is the 
context object which gets passed to the template when it's executed. Don't forget that your specialized 
_MyDslNewProjectWizard_ has to populate the data fields of your _MyDslProjectInfo_.

h1(#jvmtypes). Referring to Java Types

A common use case when developing languages is the requirement to refer to existing concepts of other 
languages. Xtext makes this very easy for other self defined languages. However, it is often very useful
to have access to the available types of the Java Virtual Machine. The JVM types Ecore model enables
clients to do exactly this. It is possible to create cross-references to classes, interfaces, and their 
fields and methods. Basically every information about the structural concepts of the Java type system
is available via the JVM types. This includes annotations and their specific values and enumeration 
literals as well.

The implementation will be selected transparently to the client code depending on where the code is 
executed. If the environment is a plain stand-alone Java or OSGi environment, the _java.lang.reflect_ 
API will be used to deduce the necessary data. On the contrary, the type-model will be created from the 
live data of the JDT in an interactive Eclipse environment. All this happens behind the scenes via different
implementations that are bound to specific interfaces with Google Guice. 

h2. How to Use Java Types 

Using the JVM types model is very simple. First of all, the grammar has to import the _JavaVMTypes_ Ecore model. 
Thanks to content assist this is easy to spot in the list of proposals.  

bc.. import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

p. The next step is to actually refer to an imported concept. Let's define a mapping to actually available
Java types for the simple data types in the self defined language. By means of cross-references this works
as one got already used to when dealing with references in Xtext.

bc.. Type:
  'type' name=ID 'mapped-to' javaType=[types::JvmType|FQN];

p. Last but not least, the ${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.types.TypesGeneratorFragment} 
has to be added to the workflow. The safest way is 
to add it after the actually used scoping fragments as a specialized version of the _IGlobalScopeProvider_ 
will be configured. Don't forget to refer to the _genmodel_ of the Java VM types. The shortest possible
URI is a classpath-URI.    

bc.. fragment = ecore.EcoreGeneratorFragment {
  referencedGenModels="classpath:/model/JavaVMTypes.genmodel"
}

...
// scoping and exporting API 
...

fragment = types.TypesGeneratorFragment {}

p. After regenerating your language, it will be allowed to define a type _Date_ that maps to the _java.util.Date_
like this:

bc.. type Date mapped-to java.util.Date

p. These two steps will provide a nice integration into the Eclipse JDT. There is _Find References_ on Java methods, 
fields and types that will reveal results in your language files. _Go To Declaration_ works as expected
and content assist will propose the list of available types. 

h2. Customization Points

There are several customization hooks in the runtime layer and on the editor side as well:

The ${org.eclipse.xtext.common.types/src/org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider} 
can be used to create scopes for members with respect to
the override semantics of the Java language. Of course it is possible to use this implementation to
create scopes for types as well.

As the Java VM types expose a lot of information about visibility, parameter- and return types, generic,
available annotations or enumeration literals, it is very easy to define constraints for the referred types.

The ${org.eclipse.xtext.common.types.ui/src/org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider} can be
used to provide optimized proposals based on various filter criteria. 
The most common selector can be used directly via _createSubTypeProposals_. The implementation is optimized
and uses the JDT Index directly to minimize the effort for object instantiation. The class 
${org.eclipse.xtext.common.types.ui/src/org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters}
provides a comprehensive set of reusable filters that can be easily combined to reduce the list of proposals
to a smaller number of valid entries.

bc.. import static org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters.*; 
..
..

  proposalProvider.createSubTypeProposals(factory, context,
      and(not(canInstantiate()), isPublic()), acceptor);
 
 
p. _Since Xtext 1.0.1:_

Proposals can be created by means of a scoped proposal provider that is actually aware of existing import 
statements and scoping rules while still leveraging the JDT index for faster proposal creation. Use the 
_ITypesProposalProvider.IScopableTypesProposalProvider_ to create a scoped proposal provider and use this 
one instead of the plain implementation.

bc.. @Override
public void complete<TypeName>_<ReferenceName>(
    EObject model,
    Assignment assignment,
    ContentAssistContext context,
    ICompletionProposalAcceptor acceptor) {
  IScope scope = getScopeProvider().getScope(
      model,
      <MyDsl>Package.Literals.<POINTER_TO_REFERENCE>);
  ITypesProposalProvider scopedProposalProvider =
      scopableProposalProvider.getScopedProposalProvider(model, scope);
  scopedProposalProvider.create...
}


h1(#special_languages). Typical Language Configurations

h2(#case_insensitive_languages). Case Insensitive Languages

In some cases, e.g. if your _SHIFT_ key is broken, you might want to design a case insensitive language. Xtext offers separate "generator fragments":#generator_fragment for this purpose. 

For case insensitive keywords, open your MWE workflow and replace the Antlr related fragments: 

bc.. // The antlr parser generator fragment.
fragment = parser.antlr.XtextAntlrGeneratorFragment {
//  options = {
//		backtrack = true
//	}
}
...

// generates a more lightweight Antlr parser and lexer tailored ...
fragment = parser.antlr.XtextAntlrUiGeneratorFragment {
}

p. with

bc.. // The antlr parser generator fragment.
fragment = parser.antlr.ex.rt.AntlrGeneratorFragment {
    options = {
        ignoreCase = true
    }
}
...

// generates a more lightweight Antlr parser and lexer tailored ...
fragment = parser.antlr.ex.ca.ContentAssistParserGeneratorFragment {
    options = {
        ignoreCase = true
    }
}

p. For case insensitve element names, use the _ignoreCase_ option in your scope fragment, i.e.

bc.. fragment = scoping.ImportNamespacesScopingFragment {
    ignoreCase = true
}

p. or if you are using "importURI based global scopes":#import_uri

bc.. fragment = scoping.ImportURIScopingFragment {
    ignoreCase = true
}

h2(#java_independent_languages). Languages Independent of JDT

The following section describes how you make your language independent of Eclipse's Java Development Toolkit (JDT).

In the _UIModule_ of your language you have to overwrite some bindings. First, remove the bindings to components with support for the '_classpath:_' URI protocol, i.e. 

bc.. @Override
public Class<? extends IResourceForEditorInputFactory>
    bindIResourceForEditorInputFactory() {
        return ResourceForIEditorInputFactory.class;
}

@Override
public Class<? extends IResourceSetProvider> bindIResourceSetProvider() {
    return SimpleResourceSetProvider.class;
}

p. Second, configure the global scope provider to scan project root folders instead of the classpath of Java projects.   

bc.. @Override
public com.google.inject.Provider
    <org.eclipse.xtext.resource.containers.IAllContainersState>
    provideIAllContainersState() {
    return org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState();
}

p. The remaining steps show you how to adapt the  
"project wizard":#projectwizard for your language, if you have generated one.
The best way to do this is to create a new subclass of the generated 
_IProjectCreator_ in the _src/_ folder of the _ui_ project and 
apply the necessary changes there. First, remove the JDT project configuration 
by overriding _configureProject_ with an empty body. 

The next thing is to redefine the project natures and builders that should be
applied to you language projects.

In in this case just remove the JDT stuff in this way:

bc.. protected String[] getProjectNatures() {
    return new String[] {
        "org.eclipse.pde.PluginNature",
        "org.eclipse.xtext.ui.shared.xtextNature"
    };
}

protected String[] getBuilders() {
    return new String[] {
        "org.eclipse.pde.ManifestBuilder", 
        "org.eclipse.pde.SchemaBuilder"
    };
}

p. After that you have to bind the new _IProjectCreator_

bc.. @Override
public Class<? extends IProjectCreator> bindIProjectCreator() {
    return JDTFreeMyDslProjectCreator.class;
}

p. That's all. Your language and its IDE should now no longer depend on JDT.

h2(#expressions). Parsing Expressions with Xtext

Parsing simple XML-like, structural languages with Xtext is a no-brainer. However, parsing nested expressions is often considered a bit more complicated. This is because they are more complicated due to their recursive nature and also because with Xtext you have to avoid left recursive parser rules. As the underlying parser (generated by Antlr) uses a top-down approach it would recurse endlessly if you had a left recursive grammar.

Let's have a look at parsing a simple arithmetic expression:

bc. 2 + 20 * 2

p. If you know EBNF a bit and wouldn't think about avoiding left recursion, operator precedence or associativity, you'ld probably write a grammar like this:

bc.. Expression :
  Expression '+' Expression |
  Expression '*' Expression |
  INT;

p. This grammar would be left recursive because the parser reads the grammar top down and left to right and would endlessly call the Expression rule without consuming any characters, i.e. altering the underlying state of the parser. While this kind of grammar can be written for bottom-up parsers, you'ld still have to deal with operator precedence in addition. That is define that a multiplication has higher precedence than an addition for example.

In Xtext you define the precedence implicitly when left-factoring such a grammar. Left-factoring means you get rid of left recursion by applying a certain technique, which we will show in the following.

So here is a left-factored grammar (not yet working with Xtext) for the expression language above :

bc.. Addition :
  Multiplication ('+' Multiplication)*;

Multiplication:
  NumberLiteral ('*' NumberLiteral)*;

NumberLiteral:
  INT;

p. As you can see the main difference is that we have three rules instead of one and if you look a bit closer you see, that there's a certain delegation pattern involved. The rule Addition doesn't call itself but calls Multiplication instead. The operator precedence is defined by the order of delegation. The later the rule is called the higher is its precedence. This is at least the case for the first two rules which are of a left recursive nature (but we've left-factored them now). The last rule is not left recursive which is why you can write them down without applying this pattern.

We should allow users to explicitly adjust precedence by adding parenthesis, e.g. write something like (2 + 20) * 2.
So let's add support for that (note that the grammar is still not working with Xtext):

bc.. Addition :
  Multiplication ('+' Multiplication)*;

Multiplication:
  Primary ('*' Primary)*;

Primary :
  NumberLiteral |
  '(' Addition ')';

NumberLiteral:
  INT;
  
p. So once again: if you have some construct that recurses on the left hand side, you need to put it into the delegation chain according to their operator precedence. The pattern is always the same, the thing that recurses delegates to the rule with the next higher precedence.

h3. Construction of an AST

Now that we know how to avoid left recursion, let's have a look at what the parser produces. In Xtext each rule returns some value. Parser rules return AST nodes (i.e. EObject instances), enum rules return enum literals and datatype rules as well as terminal rules return simple values like strings and the like (EDatatype in EMF jargon).
Xtext can automatically infer whether some rule is a parser rule, i.e. constructs and returns an AST node, or if it is a datatype rule that returns a value. The grammar above only consists of datatype rules all of them returning plain strings.
In order to construct an AST we need to add Assignments and Actions. But before we do that we need to talk about return types.

The return type of a rule can be specified explicitly using the 'returns' keyword but can be inferred if the type's name is the same as the rule's name.
That is

bc.. NumberLiteral : ... ;

p. is a short form of

bc.. NumberLiteral returns NumberLiteral : ... ;

p. However in the case of the expressions grammar above, all rules need to return the same type since they are recursive. So in order to make the grammar functional we need to add a common return type explicitly (but the grammar is still missing some bits):

bc.. Addition returns Expression:
  Multiplication ('+' Multiplication)*;
  
Multiplication returns Expression:
  Primary ('*' Primary)*;
  
Primary returns Expression:
  NumberLiteral |
  '(' Addition ')';
  
NumberLiteral:
  INT;

p. The AST type inference mechanism of Xtext will infer two types: Expression and NumberLiteral. Now we need to add assignments and Actions in order to store all the important information in the AST and to create reasonable subtypes for the two operations.

In the following you see the final fully working Xtext grammar:

bc.. Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)*;
  
Multiplication returns Expression:
  Primary ({Multiplication.left=current} '*' right=Primary)*;
  
Primary returns Expression:
  NumberLiteral |
  '(' Addition ')';
  
NumberLiteral:
  value=INT;

p. Let's go through the grammar as the parser would do it for the expression

bc.. (1 + 20) * 2

p. The parser always starts with the first rule (Addition). Therein the first element is an unassigned rule call to Multiplication which in turn calls Primary. Primary now has two alternatives. The first one is calling NumberLiteral which consists only of one assignment to a feature called 'value'. The type of 'value' has to be compatible to the return type of the INT rule.

But as the first token in the sample expression is an opening parenthesis '(' the parser will take the second alternative in Primary, consume the '(' and call the rule Addition. Now the value '1' is the lookahead token and again Addition calls Multiplication and Multiplication calls Primary. This time the parser takes the first alternative because '1' was consumed by the INT rule (which btw. is a reused library terminal rule).

As soon as the parser hits an assignment it checks whether an AST node for the current rule was already created. If not it will create one based on the return type of the current rule, which is NumberLiteral. The Xtext generator created an EClass 'NumberLiteral' before which can now be instantiated. That type will also have a property called value of type int (actually of type EInt), which will get the value '1' set. This is what the Java equivalent would look like:

bc.. // value=INT
if (current == null)
 current = new NumberLiteral();
current.setValue(ruleINT());
...

p. Now that the rule has been completed the created EObject is returned to the calling rule Primary, which in turn returns the object unchanged to its own caller. Within Multiplication the call to Primary has been successfully parsed and returned an instance of NumberLiteral. The second part of the rule (everything within the parenthesis) is a so called group. The asterisk behind the closing parenthesis states that this part can be consumed zero or more times. The first token to consume in this part is the multiplication operator '*'. Unfortunately in the current situation the next token to accept is the plus operator '+', so the group is not consumed at all and the rule returns what they got from the unassigned rule call (the NumberLiteral).

In rule Addition there's a similar group but this time it expects the correct operator so the parser steps into the group.
The first element in the group is a so called action. As Xtext grammars are highly declarative and bi-directional it is not a good idea to allow arbitrary expression within actions as it is usually the case with parser generators. Instead we only support two kinds of actions. This one will create a new instance of type Addition and assign what was the to-be-returned object to the feature left. In Java this would have been something like:

bc.. // Multiplication rule call
current = ruleMultiplication();
// {Addition.left=current}
Addition temp = new Addition();
temp.setLeft(current);
current = temp;
...

p. As a result the rule would now return an instance of Addition which has a NumberLiteral set to its property left. Next up the parser consumes the '+' operator. We do not store the operator in the AST because we have an explicit Addition type, which implicitly contains this information.
The assignment ('right=Multiplication') calls the rule Multiplication another time and assigns the returned object (a NumberLiteral of value=20) to the property named right.

If we now had an additional plus operation '+' (e.g. 1 + 2 + 3) the group would match another time and create another instance of Addition. But we don't and therefore the rule is completed and returns the created instance of Addition to its caller which was the second alternative in Primary. Now the closing parenthesis is matched and consumed and the parser stack is reduced once more.

We are now in rule Multiplication and have the multiplication operator '*' on the lookahead. The parser goes into the group and applies the action. Finally it calls the Primary rule, gets another instance of NumberLiteral (value=2), assigns it as the 'right' operand of the Multiplication and returns the Multiplication to the rule Addition which in turn returns the very same object as there's nothing left to parse.

The resulting AST looks like this:

!images/expression-ast.png!


p. (It's pretty hard to follow what's going on just by reading this text. Therefore we have prepared a small video which visualizes and explains the details. see http://vimeo.com/14358869)

h3. Associativity

There is still one topic we should mention, which is associativity. There is left and right associativity as well as none associativity. In the example we have seen left associativity. Associativity tells the parser how to construct the AST when there are two infix operations with the same precedence. The following example is taken from the corresponding wikipedia entry:

Consider the expression a ~ b ~ c. If the operator ~ has left associativity, this expression would be interpreted as (a ~ b) ~ c and evaluated left-to-right. If the operator has right associativity, the expression would be interpreted as a ~ (b ~ c) and evaluated right-to-left. If the operator is non-associative, the expression might be a syntax error, or it might have some special meaning.
We already know the most important form which is left associativity:

bc.. Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)*;

p. Right associativity is done using the following pattern (note the quantity operator and the call to the rule itself at the end):

bc.. Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Addition)?;

p. And if you don't want to allow multiple usages of the same expression in a row (hence non-associativity) you write:

bc.. Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)?;

p. Note that sometimes it's better to allow associativity on parser level, but forbid it later using validation, because you can come up with a better error message. Also the whole parsing process won't be interrupted, so your tooling will generally be more forgiving.

h1(#emf_integration). Integration with EMF and Other EMF Editors

Xtext relies heavily on EMF internally, but it can also be used as the serialization back-end of other EMF-based tools.
In this section we introduce the basic concepts of the "Eclipse Modeling Framework (EMF)":http://www.eclipse.org/emf in the context of Xtext.  
If you want to learn more about EMF, we recommend reading the "EMF book":http://www.eclipse.org/emf.

h2(#model_metamodel). Model, Ecore Model, and Ecore 
 
When Xtext uses EMF models as the in-memory representation of any parsed text files. This in-memory object graph is called the _Abstract Syntax Tree_ (AST). 
Depending on the community this concepts is also called _document object graph (DOM)_, _semantic model_, or simply _model_. We use _model_ and _AST_ interchangeably. 
Given the example model from the "introduction":#getting-started-xtext, the AST looks similar to this

!{width:50%}images/ast.png(Sample AST)!

The _AST_ should contain the essence of your textual models and abstract over syntactical information. It is used by later processing steps, 
such as validation, compilation or interpretation. In EMF a model is made up of instances of _EObjects_ which are connected 
and an _EObject_ is an instance of an _EClass_. 
A set of _EClasses_ if contained in a so called _EPackage_, which are both concepts of _Ecore_ 
In Xtext, meta models are either inferred from the grammar or predefined by the user (see the section on "package declarations":#package_declarations for details). The next diagram shows the meta model of our example:

!images/metamodel.png(Sample meta model)! 

The language in which the meta model is defined is called _Ecore_. In other words, the meta model is the Ecore model of your language. Ecore an essential part of EMF. Your your models instantiate the meta model, and your meta model instantiates Ecore. To put an end to this recursion, Ecore is defined in itself (an instance of itself). 

The meta model defines the types of the semantic nodes as Ecore _EClasses_. EClasses are shown as boxes in the meta mode diagram, so in our example, _Model_, _Type_, _SimpleType_, _Entity_, and _Property_ are EClasses. An EClass can inherit from other EClasses. Multiple inheritance is allowed in Ecore, but of course cycles are forbidden.  

EClasses can have _EAttributes_ for their simple properties. These are shown inside the EClasses nodes. The example contains two EAttributes _name_ and one EAttribute _isMulti_. The domain of values for an EAttribute is defined by its _EDataType_. Ecore ships with some predefined _EDataTypes_, which essentially refer to Java primitive types and other immutable classes like String. To make a distinction from the Java types, the EDataTypes are prefixed with an _E_. In our example, that's _EString_ and _EBoolean_.  

In contrast to EAttributes, _EReferences_ point to other EClasses. The _containment_ flag indicates whether an EReference is a _containment reference_ or a _cross-reference_. In the diagram, references are edges and containment references are marked with a diamond. At the model level, each element can have at most one container, i.e. another element referring to it with a containment reference. This infers a tree structure to the models, as can be seen in the sample model diagram. On the other hand, _cross-references_ refer to elements that can be contained anywhere else. In the example, _elements_ and _properties_ are containment references, while _type_ and _extends_ are cross-references. For reasons of readability, we skipped the cross-references in the sample model diagram. Note that in contrast to other parser generators, Xtext creates ASTs with linked cross-references. 

Other than associations in UML, EReferences in Ecore are always owned by one EClass and only navigable in the direction form the owner to the type. Bi-directional associations must be modeled as two references, being _eOpposite_ of each other and owned by either end of the associations.

The superclass of EAttibutes and EReferences is _EStructuralFeature_ and allows to define a name and a cardinality by setting _lowerBound_ and _upperBound_. Setting the latter to -1 means 'unbounded'. 

The common supertype of EDataType and EClass is _EClassifier_. An _EPackage_ acts as a namespace and container of EClassifiers. 

We have summarized these most relevant concepts of Ecore in the following diagram:  

!images/ecore.png(Ecore concepts)!

h2(#emf_codegen). EMF Code Generation

EMF also ships with a code generator that generates Java classes from your Ecore model. The code generators input is the so called _EMF generator model_. It decorates (references) the Ecore model and adds additional information for the Ecore -> Java transformation. Xtext will automatically generate a generator model with reasonable defaults for all generated metamodels, and run the EMF code generator on them. 

The generated classes are based on the EMF runtime library, which offers a lot of infrastructure and tools to work with your models, such as persistence, reflection, referential integrity, lazy loading etc.

Among other things, the code generator will generate
* A Java interface and a Java class for each EClassifier in your Ecore model. By default, all classes will implement the interface _org.eclipse.emf.ecore.EObject_, linking a lot of runtime functionality. 
* A Java bean property for each EStructuralFeature (member variable, accessor methods)
* A package interface and class, holding singleton objects for all elements of your Ecore model, allowing reflection. EPackages are also registered to the _EPackage.Registry_ to be usable at runtime.
* A factory interface and class for creating instances
* An abstract switch class implementing a visitor pattern to avoid if-instanceof cascades in your code.

h2(#xtext_resource). XtextResource Implementation

Xtext provides an implementation of EMF's resource, the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource}. This does not only encapsulate the parser that converts text to an EMF model but also the serializer working the opposite direction. That way, an Xtext model just looks like any other Ecore-based model from the outside, making it amenable for the use by other EMF based tools. In fact, the Xpand templates in the generator plug-in created by the Xtext wizard do not make any assumption on the fact that the model is described in Xtext, and they would work fine with any model based on the same Ecore model of the language. So in the ideal case, you can switch the serialization format of your models to your self-defined DSL by just replacing the resource implementation used by your other modeling tools. 

!images/emf-integration.png!

The generator fragment ${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.resourceFactory.ResourceFactoryFragment} registers a factory for the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.XtextResource} to EMF's resource factory registry, such that all tools using the default mechanism to resolve a resource implementation will automatically get that resource implementation.   

Using a self-defined textual syntax as the primary storage format has a number of advantages over the default XMI serialization, e.g.
* You can use well-known and easy-to-use tools and techniques for manipulation, such as text editors, regular expressions, or stream editors.
* You can use the same tools for version control as you use for source code. Merging and diffing is performed in a syntax the developer is familiar with. 
* It is impossible to break the model such that it cannot be reopened in the editor again. 
* Models can be fixed using the same tools, even if they have become incompatible with a new version of the Ecore model.

Xtext targets easy to use and naturally feeling languages. It focuses on the lexical aspects of a language a bit more than on the semantic ones. As a consequence, a referenced Ecore model can contain more concepts than are actually covered by the Xtext grammar. As a result, not everything that is possibly expressed in the EMF model can be serialized back into a textual representation with regards to the grammar. So if you want to use Xtext to serialize your models as described above, it is good to have a couple of things in mind:

* Prefer optional rule calls (cardinality _?_ or _*_) to mandatory ones (cardinality _+_ or default), such that missing references will not obstruct serialization. 
* You should not use an Xtext-Editor on the same model instance as a self-synchronizing other editor, e.g. a canonical GMF editor (see :#gmf_integration_stage_1 for details). The Xtext parser replaces re-parsed subtrees of the AST rather than modifying it, so elements will become stale. As the Xtext editor continuously re-parses the model on changes, this will happen rather often. It is safer to synchronize editors more loosely, e.g. on file changes. 
* Implement an _IFragmentProvider_:#fragmentProvider to make the XtextResource return stable fragments for its contained elements, e.g. based on composite names rather than order of appearance.
* Implement an _IQualifiedNameProvider_ and an _IScopeProvider_:#scoping to make the names of all linkable elements in cross-references unique. 
* Provide an _IFormatter_:#formatting to improve the readability of the generated textual models.  
* Register an _IReferableElementsUnloader_ to turn deleted/replaced model elements into EMF proxies. Design the rest of your application such that it does never keep references to  _EObjects_ or to cope with proxies. That will improve the stability of your application drastically.
* Xtext will register an EMF _ResourceFactory_, so resources with the file extension you entered when generating the Xtext plug-ins will be automatically loaded in an _XtextResource_ when you use EMF's _ResourceSet_ API to load it.

h2(#gmf_integration). Integration with GMF Editors

The "Graphical Modeling Framework (GMF)":http://www.eclipse.org/modeling/gmp/?project=gmf allows to create graphical diagram editors for Ecore models. To illustrate how to build a GMF on top of an _XtextResource_ we have provided an example. You must have the Helios version 2.3 of GMF Notation, Runtime and Tooling and their dependencies installed in your workbench to run the example. With other versions of GMF it might work to regenerate the diagram code. Choose _New->Examples->Xtext->Xtext GMF Integration_ to import it into your workbench. The example consists of a number of plug-ins

|Plug-in|Framework|Purpose|Contents|
|o.e.x.example.gmf|Xtext|Xtext runtime plug-in|Grammar, derived metamodel and language infrastructure| 
|o.e.x.e.g.ui|Xtext|Xtext UI plug-in|Xtext editor and services|
|o.e.x.e.g.edit|EMF|EMF.edit plug-in|UI services generated from the metamodel|
|o.e.x.e.g.models|GMF|GMF design models|Input for the GMF code generator|
|o.e.x.e.g.diagram|GMF|GMF diagram editor|Purely generated from the GMF design models|
|o.e.x.e.g.d.extensions|GMF and Xtext|GMF diagram editor extensions|Manual extensions to the generated GMF editor for integration with Xtext|
|o.e.x.gmf.glue|Xtext and GMF|Glue code|Generic code to integrate Xtext and GMF|

We will elaborate the example in three stages.

h3(#gmf_integration_stage_1). Stage 1: Make GMF Read and Write the Semantic Model As Text
 
A diagram editor in GMF by default manages two resources: One for the semantic model, that is the model we're actually interested in for further processing. In our example it is a model representing entities and datatypes. The second resource holds the notation model. It represents the shapes you see in the diagram and their graphical properties. Notation elements reference their semantic counterparts. An entity's name would be in the semantic model, while the font to draw it in the diagram would be stored the notation model. Note that in the integration example we're only trying to represent the semantic resource as text.

To keep the semantic model and the diagram model in sync, GMF uses a so called _CanonicalEditPolicy_. This component registers as a listener to the semantic model and automatically updates diagram elements when their semantic counterparts change, are added or are removed. Some notational information can be derived from the semantic model by some default mapping, but usually there is a lot of graphical stuff that the user wants to change to make the diagram look better.   

In an Xtext editor, changes in the text are transfered to the underlying _XtextResource_ by a call to the method _org.eclipse.xtext.resource.XtextResource.update(int, int, String)_, which will trigger a partial parsing of the dirty text region and a replacement of the corresponding subtree in the AST model (semantic model). 

Having an Xtext editor and a canonical GMF editor on the same resource can therefore lead to loss of notational information, as a change in the Xtext editor will remove a subtree in the AST, causing the  _CanonicalEditPolicy_ to remove all notational elements, even though it was customized by the user. The Xtext rebuilds the AST and the notation model is restored using the default mapping. It is therefore not recommended to let an Xtext editor and a canonical GMF editor work on the same resource.    
 
In this example, we let each editor use its own memory instance of the model and synchronize on file changes only. Both frameworks already synchronize with external changes to the edited files out-of-the-box. In the glue code, a ${org.eclipse.xtext.gmf.glue/src/org.eclipse.xtext.gmf.glue.concurrency.ConcurrentModificationObserver} warns the user if she tries to edit the same file with two different model editors concurrently.

In the example, we started with writing an Xtext grammar for an entity language. As explained above, we preferred optional assignments and rather covered mandatory attributes in a validator. Into the bargain, we added some services to improve the EMF integration, namely a formatter, a fragment provider and an unloader. Then we let Xtext generate the language infrastructure. From the derived Ecore model and its generator model, we generated the edit plug-in (needed by GMF) and added some fancier icons. 

From the GMF side, we followed the default procedure and created a gmfgraph model, a gmftool model and a gmfmap model referring to the Ecore model derived form the Xtext grammar. We changed some settings in the gmfgen model derived by GMF from the gmfmap model, namely to enable printing and to enable validation and validation decorators. Then we generated the diagram editor.     

Voilà, we now have a diagram editor that reads/writes its semantic model as text. Also note that the validator from Xtext is already integrated in the diagram editor via the menu bar. 

h4. Stage 2: Calling the Xtext Parser to Parse GMF Labels

GMF's generated parser for the labels is a bit poor: It will work on attributes only, and will fail for cross-references, e.g. an attibute's type. So why not use the Xtext parser to process the user's input? 

An _XtextResource_ keeps track of it's concrete syntax representation by means of a so called node model (see :#parser_rules for a more detailed description). The node model represents the parse tree and provides information on the offset, length and text that has been parsed to create a semantic model element. The nodes are attached to their semantic elements by means of a node adapter.    

We can use the node adapter to access the text block that represents an attribute, and call the Xtext parser to parse the user input. The example code is contained in  ${org.eclipse.xtext.gmf.glue/src/org.eclipse.xtext.gmf.glue.edit.part.AntlrParserWrapper}. _SimplePropertyWrapperEditPartOverride_ shows how this is integrated into the generated GMF editor. Use the _EntitiesEditPartFactoryOverride_ to instantiate it and the _EntitiesEditPartProviderOverride_ to create the overridden factory, and register the latter to the extension point. Note that this is a non-invasive way to extend generated GMF editors.

When you test the editor, you will note that the node model will be corrupt after editing a few labels. This is because the node model is only updated by the Xtext parser and not by the serializer. So we need a way to automatically call the (partial) parser every time the semantic model is changed. You will find the required classes in the package _org.eclipse.xtext.gmf.glue.editingdomain_. To activate node model reconciling, you have to add a line 

bc.. XtextNodeModelReconciler.adapt(editingDomain);

p. in the method _createEditingDomain()_ of the generated _EntitiesDocumentProvider_. To avoid changing the generated code, you can modify the code generation template for that class by setting

bc.. Dynamic Templates -> true
	   Template Directory -> "org.eclipse.xtext.example.gmf.models/templates"
	   
p. in the _GenEditorGenerator_ and 

bc.. Required Plugins -> "org.eclipse.xtext.gmf.glue" 

p. in the _GenPlugin_ element of the gmfgen before generating the diagram editor anew.

h4. Stage 3: A Popup Xtext Editor (experimental)

_SimplePropertyPopupXtextEditorEditPartOverride_ demonstrates how to spawn an Xtext editor to edit a model element. The editor pops up in its control and shows only the section of the selected element. It is a fully fledged Xtext editor, with support of validation, code assist and syntax highlighting. The edited text is only transfered back to the model if it does not have any errors.   

Note that there still are synchronization issues, that's why we keep this one marked as experimental.

 
h1(#migrating_from_0_7). Migrating from Xtext 0.7.x to 1.0

Most of the tasks when migrating to Xtext 1.0 can be automated. Some changes will be necessary in the manually written code where you have to carefully
verify that your implementation is still working with Xtext 1.0. A reliable test-suite helps a lot. 

The grammar language is fully backward compatible. You should not have to apply any changes in the primary artifact. However, we introduced some additional
validation rules that mark inconsistencies in your grammar. If you get any warnings in the grammar editor, it should be straight forward to fix them.

_Tip: You'll learn something about the new features if you compare a freshly created Xtext project based on 0.7.x with a new Xtext project based on 1.0. Especially the new fragments in the workflow are a good indicator for useful new features._ 

h2. Take the Shortcut

If you haven't made too many customizations to the generated defaults and if you're not referencing many classes of your Xtext language from the outside, you might consider starting with a new Xtext project, copying your grammar and then manually restoring your changes step by step. If that does not work for you, go on reading!

h2. Migrating Step By Step

Before you start the migration to Xtext 1.0, you should make sure that no old plug-ins are in your target platform. Some plug-ins from Xtext 0.7.x have been merged and 
do no longer exist. 

_Tip: The following steps try to use the Eclipse compiler to spot any source-incompatible changes while fixing them with only a few well described user actions. Doing these steps in another order causes most likely a higher effort._

h3. Update the Plug-in Dependencies and Import Statements

You should update the constraints from version _0.7.x_ to _[1.0.0,2.0.0)_ in your manifest files if you specified any concrete versions.
Make sure that your _dsl.ui_-projects do not refer to the plug-in _org.eclipse.xtext.ui.common_ or _org.eclipse.xtext.ui.core_ but to _org.eclipse.xtext.ui_ instead. The arguably easiest way is a global text-based search and replace across the manifest files. The bundle _org.eclipse.xtext.log4j_ is obsolete as well. The generator will create _import-package_ entries in the manifests later on.
 
p. The next step is to fix the import statements in your classes to match the refactored naming scheme in Xtext. Perform a global search for "_import org.eclipse.xtext.ui.common._" and 
"_import org.eclipse.xtext.ui.core._" and replace the matches with "_import org.eclipse.xtext.ui._". This fixes most of the problems in the manually written code. 

h3. Rename the Packages in the dsl.ui-Plug-in

We changed the naming pattern for artifacts in the _dsl.ui_-plug-in to match the OSGI conventions. The easiest way to update your existing projects is to apply a 
"Rename Package" refactoring on the packages in the _src_- and _src-gen_ folder *before* you re-run the workflow that regenerates your language. Make sure you ticked "Rename sub-packages" in the dialog. It is error-prone to enable the search in non-Java files as this will perform incompatible changes in the manifest files. Furthermore, it is important to perform the rename operation in the _src-gen_ folder, too. This ensures that the references in your manually written code are properly updated.

h3. Update the Workflow

The _JavaScopingFragment_ does no longer exist. It has been superseded by the _ImportURIScopingFragment_ in combination with the _SimpleNamesFragment_.
Please replace  

bc.. <fragment 
    class="org.eclipse.xtext.generator.scoping.JavaScopingFragment"/>
p. with

bc.. <fragment 
    class="org.eclipse.xtext.generator.scoping.ImportURIScopingFragment"/>
<fragment 
    class="org.eclipse.xtext.generator.exporting.SimpleNamesFragment"/>
p. The _PackratParserFragment_ has been abandoned as well. It is save to remove the reference to that one if it is activated in your workflow. After you've changed your workflow, it should be possible to regenerate your language without any errors in the console. It is ok to have compilation errors prior to executing the workflow.

h3. MANIFEST.MF and plugin.xml

The previous rename package refactoring updated most of the entries in the _MANIFEST.MF_ and and some entries in the _plugin.xml_. Others have to be fixed manually. The Eclipse compiler will point to many of the remaining problems in the manifest files but it is unlikely that it will spot the erroneous references in the _plugin.xml_.

* In the generated UI plug-in's _MANIFEST.MF_, remove the package exports of no longer existing packages and make sure the bundle activator points to the newly generated one (with _.ui._ in its package name).  
* It was already mentioned that the plug-ins _org.eclipse.xtext.ui.core_ and _org.eclipse.xtext.ui.common_ have been merged into a new single plug-in _org.eclipse.xtext.ui_. The same happened to the respective Java packages. Change eventually remaining bundle-dependencies in all manifests. 
* The plug-in _org.eclipse.xtext.log4j_ no longer exists. We use a package import of _org.apache.log4j_ instead. Also remove the buddy registration. 
* Due to renamed packages, you have to fix all references to classes therein in the _plugin.xml_. A diff with the _plugin.xml___gen_ will be a great help. If you haven't added a lot manually, consider merging these into the generated version instead of going the other way around. Note that warnings in the _plugin.xml_ can be considered to be real errors most of the time. Make sure
** the _[MyDsl]ExecutableExtensionFactory_ has the _.ui._ package prefix
** classes from _org.eclipse.xtext.ui.common_ and _org.eclipse.xtext.ui.core_ are now usually somewhere in _org.eclipse.xtext.ui_. They are also referenced by the _[MyDsl]ExecutableExtensionFactory_ and thus not covered by the editor's validation. 
* A number of new features are being registered in the _plugin.xml_, e.g. _Find references_, _Quick Outline_, and _Quick Fixes_. You can enable them by manually copying the respective entries from _plugin.xml___gen_ to  _plugin.xml_.
* To run MWE2 workflows later on, you must change the plug-in dependencies from _org.eclipse.emf.mwe.core_ to _org.eclipse.emf.mwe2.launch_ in your manifest. Optional resolution is fine.

h3. Noteworthy API Changes 

The _src_ folders are generated once, so existing code will not be overwritten but has to be updated manually. At least one new class has appeared in your _src_-folder of the _ui_ plug-in. there will now be a _[MyDsl]StandaloneSetup_ inheriting form the generated _[MyDsl]StandaloneSetupGenerated_ to allow customization.

You will face a couple of compilation problems due to changes in the API. Here's a list of the most prominent changes. It is usually only necessary to change your code, if you face any compilation problems.
* The method _IScopeProvider.getScope(EObject,EClass)_ has been removed. Use  _IScopeProvider.getScope(EObject,EReference)_ instead. 
* Renamed _DefaultScopeProvider_ to _SimpleNameScopeProvider_. There have been further significant changes in the scoping API that allow for optimized implementations. Consult the "section on scoping":#scoping for details.
* The return type of _AbstractInjectableValidator.getEPackages()_ was changed from _List<? extends EPackage>_ to _List&lt;EPackage>_.
* The parser interfaces now use _java.io.Reader_ instead of _java.io.InputStream_ to explicitly address encoding. Have a look at the "section on encoding":#encoding for details.
* The handling of _ILabelProvider_ in various contexts has been refactored. The former base class _DefaultLabelProvider_ no longer exists. Use the _DefaultEObjectLabelProvider_ instead. See the "section on label providers":#labelProvider for details. 
* We have introduced a couple of new packages to better separate concerns. Most classes should be easy to relocate. 
* The runtime and UI modules have separate base classes _DefaultRuntimeModule_ and _DefaultUiModule_ now. We use Guice's module overrides to combine them with the newly introduced _SharedModule_.  You have to add a constructor the your _[MyDsl]UiModule_ that takes an _AbstractUiPlugin_ as argument and pass that one to the super constructor. _Tip: There is an Eclipse quick fix available for that one._
* The interfaces _ILexicalHighlightigConfiguration_ and _ISemanticHighlightingConfiguration_ have been merged into _IHighlightingConfiguration_.
* The _DefaultTemplateProposalProvider_ takes an additional, injectable constructor parameter of type _ContextTypeIdHelper_.
* The _HyperlinkHelper_ uses field injection instead of constructor injection. The method _createHyperlinksByOffset_ should be overridden instead of the former _findCrossLinkedEObject_.
* The API to skip a node in the outline has changed. Instead of returning the _HIDDEN_NODE_ you'll have to implement _boolean consumeNode(MyType)_ and return _false_.
* The _Readonly*Storage_ implementations have been removed. There is a new API to open editors for objects with a given URI. Please use the _IURIEditorOpener_ to create an editor or the _IStorage2UriMapper_ to obtain an _IStorage_ for a given URI.
* The interfaces _IStateAccess_ and _IEObjectHandle_ have been moved along with the _IUnitOfWork_ to the package _org.eclipse.xtext.util.concurrent_.
* The _ValidationJobFactory_ is gone. Please implement a custom _IResourceValidator_ instead.
* The grammar elements _Alternatives_ and _Group_ have a new common super type _CompoundElement_. The methods _getGroups_ and _getTokens_ have been refactored to _getElements_.
* Completion proposals take a _StyledString_ instead of a plain string as display string.
* The _AbstractLabelProvider_ does no longer expose its _IImageHelper_. Use _convertToImage_ instead or inject your own _IImageHelper_.
* The implementation-classes from _org.eclipse.xtext.index_ were superseded by the builder infrastructure. Use the _QualifiedNamesFragment_ and the _ImportNamespacesScopingFragment_ instead of the _ImportedNamespacesScopingFragment_. Please refer to the section about the builder infrastructure for details.
* All the Xtend-based fragments were removed. 
* _ILinkingService.getLinkText_ was removed. Have a look at the _LinkingHelper_ and the _CrossReferenceSerializer_ if you relied on this method.
* The _SerializerUtil_ was renamed to _Serializer_. There were other heavy refactorings that involved the serializer and its components (like e.g. the _ITransientValueService_) but it should be pretty straight forward to migrate existing client code.
* The method-signatures of the _IFragmentProvider_ have changed. The documentation will give a clue on how to update existing implementations.
* Some static methods were removed from utility classes such as _EcoreUtil2_ and _ParsetreeUtil_ in favor of more sophisticated implementations.


h2. Now Go For The New Features

After migrating, some of the new features in Xtext 1.0 will be automatically available. Others require further configuration.
We recommend reading the sections about
* "qualified names and namespace imports":#index_based
* "the builder infrastructure":#containers
* "quick fixes":#quickfixes
* "unordered groups":#unordered_groups
* "quick outline":#quick_outline
* "MWE2":#MWE2
* "refering to Java elements":#jvmtypes
For an overview over the new features consult our "New and Noteworthy":http://www.eclipse.org/Xtext/documentation/helios/new_and_noteworthy.php online. 

h1(#antlr_ip_issue). The ANTLR IP Issue (Or Which Parser To Use?)

In order to be able to parse models written in your language, Xtext needs to provide a special parser 
for it. The parser is generated from the self defined language grammar. 

It is recommended to use the "ANTLR":http://www.antlr.org -based parser.
ANTLR is a very sophisticated parser generator framework which implements a so called LL(*) algorithm.
It is fast, simple and at the same time has some very nice and sophisticated features. Especially its 
support for error recovery is much better than what other parser generators provide.

Xtext uses ANTLR 3 which comes in two parts: the runtime and the generator.
Both are shipped under the BSD license and have a clean intellectual property history. 
However the ANTLR parser generator is unfortunately still implemented in an older version of itself 
(v 2.x), where it was not possible for the Eclipse Foundation to ensure where exactly every line of 
code originated. Therefore ANTLR 2 didn't get the required IP approval. Eclipse has a strict IP policy, 
which makes sure that everything provided by Eclipse can be consumed under the terms of the Eclipse 
Public License. The details are described in 
"this document":http://www.eclipse.org/org/documents/Eclipse_IP_Policy.pdf. That is why we are not 
allowed to ship Xtext with the ANTLR generator but only with the IP approvied runtime components. We 
have to provide it separately and for your convenience you'll be asked to download the ANTLR generator 
when you run your language generator for the first time. You can even download it directly or install 
an additional plug-in into Eclipse: 

* "http://download.itemis.com/antlr-generator-3.0.1.jar":http://download.itemis.com/antlr-generator-3.0.1.jar
* or use the update site at "http://download.itemis.com/updates":http://download.itemis.com/updates

The workflow will not bother you with this issue on subsequent executions as the archive will be stored
in your project's root directory and can thereby be reused during the next run. 

**IMPORTANT** :
__Although if you use the non-IP approved ANTLR generator, you can still ship any languages and the IDEs you've developed with Xtext without any worrying, because it is not needed at runtime__
