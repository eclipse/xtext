<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Xtext and Java</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="xtext.html" title="">
</head>
<body>
<a name="Xbase"></a>
<h1>Xtext and Java</h1>
<p>
The following chapter demonstrates how to integrate your own DSL with Java. We will do this in four
stages: First, you will learn how to refer to existing Java elements from within your language. Then
you will use Xbase to refer to generic types. In the third step, you will map your own DSL&apos;s concepts 
to Java concepts. Last but not least, you will use both Java types and your concepts within Xbase 
expressions and execute it. 
</p>
<p>
Throughout this chapter, we will step by step improve the <a href="030-tutorial-next-steps.html#DomainmodelNextSteps" title="Go to &quot;15 Minutes Tutorial - Extended&quot;">domain model example from the tutorial</a>.  
</p>
<a name="Xbase_3"></a>
<h2>Plug-in Setup</h2>
<p>
In the following, we are going to use the JVM types model and the Xbase language library. Have a look at your 
MWE2 workflow and make sure that 
<ul>
	<li>
		the Xbase models are registered in the standalone setup and
	</li>
	<li>
		the 
		    <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/types/TypesGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.types.TypesGeneratorFragment" >TypesGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/types/TypesGeneratorFragment.java" title="View Source Code" >(src)</a> and the 
		    <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment" >XbaseGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.java" title="View Source Code" >(src)</a> are enabled.
	</li>
</ul>
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
bean&nbsp;=&nbsp;StandaloneSetup&nbsp;{<br/>
&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;registerGeneratedEPackage&nbsp;=&nbsp;<span class="string">"org.eclipse.xtext.xbase.XbasePackage"</span><br/>
&nbsp;&nbsp;registerGenModelFile&nbsp;=&nbsp;<span class="string">"platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel"</span><br/>
}<br/>
...<br/>
fragment&nbsp;=&nbsp;types.TypesGeneratorFragment&nbsp;{}<br/>
fragment&nbsp;=&nbsp;xbase.XbaseGeneratorFragment&nbsp;{}
</p>
</div>
</div>
</p>
<p>
To avoid running out of memory when regenerating, make sure to run the workflow with reasonably sized heap and
PermGen space. We recommend at least 
</p>
<p>
<span class="inlinecode">-Xmx512m&nbsp;-XX:MaxPermSize=128m</span> 
</p>
<p>
in the <em>VM Arguments</em> section of the <em>Arguments</em> tab of the run configuration. If you are experiencing ambiguity 
warnings from Antlr, the <a href="020-grammar-language.html#antlr_errors" title="Go to &quot;Syntactic Predicates&quot;">usual countermeasures</a> apply. The launch configuration that
you get with a new Xtext project is already configured properly.
</p>
<a name="jvmtypes"></a>
<h2>Referring to Java Elements using JVM Types</h2>
<p>
A common case when developing languages is the requirement to refer to existing concepts of other 
languages. Xtext makes this very easy for other self defined DSLs. However, it is often very useful
to have access to the available types of the Java Virtual Machine as well. The JVM types Ecore model enables
clients to do exactly this. It is possible to create cross-references to classes, interfaces, and their 
fields and methods. Basically every information about the structural concepts of the Java type system
is available via the JVM types. This includes annotations and their specific values and enumeration 
literals, too.
</p>
<p>
The implementation will be selected transparently depending on how the client code is 
executed. If the environment is a plain stand-alone Java or OSGi environment, the <em>java.lang.reflect</em> 
API will be used to deduce the necessary data. On the contrary, the type-model will be created from the 
live data of the JDT in an interactive Eclipse environment. All this happens transparently for the clients
behind the scenes via different implementations that are bound to specific interfaces by means of Google Guice. 
</p>
<p>
Using the JVM types model is very simple. First of all, the grammar has to import the <em>JavaVMTypes</em> Ecore model. 
Thanks to content assist this is easy to spot in the list of proposals.  
</p>
<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;<span class="string">"http://www.eclipse.org/xtext/common/JavaVMTypes"</span>&nbsp;<span class="keyword">as</span>&nbsp;jvmTypes</span>
</p>
<p>
The next step is to actually refer to an imported concept. Let&apos;s define a mapping to available
Java types for the simple data types in the domain model language. This can be done with a simple cross-reference:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">//&nbsp;simple&nbsp;cross&nbsp;reference&nbsp;to&nbsp;a&nbsp;Java&nbsp;type<br/>
</span>DataType:<br/>
&nbsp;&nbsp;<span class="string">&apos;datatype&apos;</span>&nbsp;name=ID&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;mapped-to&apos;</span>&nbsp;javaType=[jvmTypes::JvmType|QualifiedName];
</p>
</div>
</div>
</p>
<p>
After regenerating your language, it will be allowed to define a type <span class="inlinecode">Date</span> that maps to the <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html" title="View JavaDoc"><abbr title="java.util.Date" >Date</abbr></a>
like this:
</p>
<p>
<span class="inlinecode"><span class="keyword">datatype</span>&nbsp;Date&nbsp;mapped-to&nbsp;java.util.Date</span>
</p>
<p>
These two steps will provide a nice integration into the Eclipse JDT. There is <em>Find References</em> on Java methods, 
fields and types that will reveal results in your language files. <em>Go To Declaration</em> works as expected
and content assist will propose the list of available types. Even the <em>import</em> statements will also
apply for Java types. 
</p>
<a name="jvmtypes_10"></a>
<h3>Customization Points</h3>
<p>
There are several customization hooks in the runtime layer of the JVM types and on the editor side as well:
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider" >AbstractTypeScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/src/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.java" title="View Source Code" >(src)</a> 
can be used to create scopes for members with respect to
the override semantics of the Java language. Of course it is possible to use this implementation to
create scopes for types as well.
</p>
<p>
As the Java VM types expose a lot of information about visibility, parameter types and return types, generics,
available annotations or enumeration literals, it is very easy to define constraints for the referred types.
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider" >ITypesProposalProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.java" title="View Source Code" >(src)</a> can be
used to provide optimized proposals based on various filter criteria. 
The most common selector can be used directly via <span class="inlinecode">createSubTypeProposals(..)</span>. The implementation is optimized
and uses the JDT Index directly to minimize the effort for object instantiation. The class 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters" >TypeMatchFilters</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.java" title="View Source Code" >(src)</a>
provides a comprehensive set of reusable filters that can be easily combined to reduce the list of proposals
to a smaller number of valid entries.
</p>
<a name="xbaseJavaReferences"></a>
<h2>Referring to Java Types Using Xbase</h2>
<p>
While the JVM types approach from the previous chapter allows to refer to any Java element, it is quite
limited when it comes to generics. Usually, a type reference in Java can have type arguments which can also include
wildcards, upper and lower bounds etc. A simple cross-reference using a qualified name is not enough
to express neither the syntax nor the structure of such a type reference. 
</p>
<p>
Xbase offers a parser rule <em>JvmTypeReference</em> which supports the full syntax of a Java type reference
and instantiates a JVM element of type <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmTypeReference.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmTypeReference" >JvmTypeReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmTypeReference.java" title="View Source Code" >(src)</a>. So
let us start by inheriting from Xbase:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.xbase.Xbase
</p>
</div>
</div>
</p>
<p>
Because we can express all kinds of Java type references directly now, an indirection for <em>DataTypes</em> as
in the previous section is no longer necessary. If we start from the <a href="030-tutorial-next-steps.html#DomainmodelNextSteps" title="Go to &quot;15 Minutes Tutorial - Extended&quot;">domain model 
example in the tutorial</a> again, we have to replace all cross-references to <em>Types</em> by calls to the production 
rule <em>JvmTypeReference</em>. The rules <em>DataType</em>, <em>Type</em>, and <em>QualifiedName</em> become obsolete (the latter is 
already defined in Xbase), and the <em>Type</em> in <em>AbstractEntity</em> must be changed to <em>Entity</em>. As we now have 
all kinds of generic Java collections at hand, <em>Feature.many</em> is obsolete, too. The whole grammar now reads concisely:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.eclipse.xtext.xbase.Xbase<br/>
<br/>
<span class="keyword">generate</span>&nbsp;domainmodel&nbsp;<span class="string">"http://www.eclipse.org/xtext/example/Domainmodel"</span><br/>
<br/>
Domainmodel:<br/>
&nbsp;&nbsp;importSection=XImportSection?<br/>
&nbsp;&nbsp;(elements&nbsp;+=&nbsp;AbstractElement)*<br/>
;<br/>
<br/>
PackageDeclaration:<br/>
&nbsp;&nbsp;<span class="string">&apos;package&apos;</span>&nbsp;name&nbsp;=&nbsp;QualifiedName&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(elements&nbsp;+=&nbsp;AbstractElement)*<br/>
&nbsp;&nbsp;<span class="string">&apos;}&apos;</span><br/>
;<br/>
<br/>
AbstractElement:<br/>
&nbsp;&nbsp;PackageDeclaration&nbsp;|&nbsp;Entity<br/>
;<br/>
<br/>
Entity:<br/>
&nbsp;&nbsp;<span class="string">&apos;entity&apos;</span>&nbsp;name&nbsp;=&nbsp;ID&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;extends&apos;</span>&nbsp;superType&nbsp;=&nbsp;JvmTypeReference)?<br/>
&nbsp;&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(features&nbsp;+=&nbsp;Feature)*<br/>
&nbsp;&nbsp;<span class="string">&apos;}&apos;</span><br/>
;<br/>
&nbsp;<br/>
Feature:<br/>
&nbsp;&nbsp;name&nbsp;=&nbsp;ID&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type&nbsp;=&nbsp;JvmTypeReference<br/>
;
</p>
</div>
</div>
</p>
<p>
As we changed the grammar, we have to regenerate the language now.
</p>
<p>
Being able to parse a Java type reference is already nice, but we also have to write them back to their string
representation when we generate Java code. Unfortunately, a generic type reference with fully qualified
class names can become a bit bulky. Therefore, the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/ImportManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager" >ImportManager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java" title="View Source Code" >(src)</a> shortens
fully qualified names, keeps track of imported namespaces, avoids name collisions, and helps to serialize
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmTypeReference.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmTypeReference" >JvmTypeReferences</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmTypeReference.java" title="View Source Code" >(src)</a> by means of the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer" >TypeReferenceSerializer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.java" title="View Source Code" >(src)</a>. This utility encapsulates how type
references may be serialized depending on the concrete context in the output.
</p>
<p>
The following snippet shows our code generator using an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/ImportManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager" >ImportManager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java" title="View Source Code" >(src)</a>
in conjunction with as <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer" >TypeReferenceSerializer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.java" title="View Source Code" >(src)</a>.
We create a new instance and pass it through the generation functions, collecting types on the way. As
the import section in a Java file precedes the class body, we create the body into a String variable
and assemble the whole file&apos;s content in a second step.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;IQualifiedNameProvider<br/>
&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;TypeReferenceSerializer&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;<span class="keyword">void</span>&nbsp;doGenerate(Resource&nbsp;resource,&nbsp;IFileSystemAccess&nbsp;fsa)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(e:&nbsp;resource.allContents.toIterable.filter(<span class="keyword">typeof</span>(Entity)))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsa.generateFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.fullyQualifiedName.toString(<span class="string">"/"</span>)&nbsp;+&nbsp;<span class="string">".java"</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.compile)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compile(Entity&nbsp;<span class="keyword">it</span>)&nbsp;<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">val</span>&nbsp;importManager&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ImportManager(true)<span class="string">&raquo;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">val</span>&nbsp;body&nbsp;=&nbsp;body(importManager)<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">IF</span>&nbsp;eContainer&nbsp;!=&nbsp;null<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;package&nbsp;&laquo;</span>eContainer.fullyQualifiedName<span class="string">&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">ENDIF</span><span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">FOR</span>&nbsp;i:importManager.imports<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;&laquo;</span>i<span class="string">&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">ENDFOR</span><span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span>body<span class="string">&raquo;<br/>
&nbsp;&nbsp;&apos;&apos;&apos;</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;body(Entity&nbsp;<span class="keyword">it</span>,&nbsp;ImportManager&nbsp;importManager)&nbsp;<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;&laquo;</span>name<span class="string">&raquo;&nbsp;&laquo;</span><span class="keyword">IF</span>&nbsp;superType&nbsp;!=&nbsp;null<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;&laquo;</span>superType.shortName(importManager)<span class="string">&raquo;&nbsp;&laquo;</span><span class="keyword">ENDIF</span><span class="string">&raquo;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">FOR</span>&nbsp;f&nbsp;:&nbsp;features<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span>f.compile(importManager)<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">ENDFOR</span><span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&apos;&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compile(Feature&nbsp;<span class="keyword">it</span>,&nbsp;ImportManager&nbsp;importManager)&nbsp;<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;&laquo;</span>type.shortName(importManager)<span class="string">&raquo;&nbsp;&laquo;</span>name<span class="string">&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&laquo;</span>type.shortName(importManager)<span class="string">&raquo;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&laquo;</span>name.toFirstUpper<span class="string">&raquo;()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&laquo;</span>name<span class="string">&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;set&laquo;</span>name.toFirstUpper<span class="string">&raquo;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span>type.shortName(importManager)<span class="string">&raquo;&nbsp;&laquo;</span>name<span class="string">&raquo;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.&laquo;</span>name<span class="string">&raquo;&nbsp;=&nbsp;&laquo;</span>name<span class="string">&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&apos;&apos;&apos;</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;shortName(JvmTypeReference&nbsp;ref,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImportManager&nbsp;importManager)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;result&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;StringBuilderBasedAppendable(importManager)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ref.serialize(ref.eContainer,&nbsp;result);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.toString<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
Please note that when <em>org.eclipse.xtext.xbase.Xbase</em> is used the default binding for the interface 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IGenerator" >IGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/generator/IGenerator.java" title="View Source Code" >(src)</a> is <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.JvmModelGenerator" >JvmModelGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.java" title="View Source Code" >(src)</a>.
To use a custom one we have to bind our own implementation in <em>org.example.domainmodel.DomainmodelRuntimeModule</em>
like this:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelRuntimeModule&nbsp;<span class="keyword">extends</span>&nbsp;org.example.domainmodel.AbstractDomainmodelRuntimeModule&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;org.eclipse.xtext.generator.IGenerator&gt;&nbsp;bindIGenerator()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;org.example.domainmodel.generator.DomainmodelGenerator.<span class="keyword">class</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<a name="xbaseInferredType"></a>
<h2>Inferring a JVM Model</h2>
<p>
In many cases, you will want your DSLs concepts to be usable as Java elements, e.g. an <em>Entity</em> will
become a Java class and should be usable as such. In the domain model example, you can write  
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">entity</span>&nbsp;Employee&nbsp;<span class="keyword">extends</span>&nbsp;Person&nbsp;{<br/>
&nbsp;&nbsp;boss:&nbsp;Person<br/>
...<br/>
<br/>
<span class="keyword">entity</span>&nbsp;Person&nbsp;{<br/>
&nbsp;&nbsp;friends:&nbsp;List&lt;Person&gt;<br/>
...
</p>
</div>
</div>
</p>
<p>
You can use entities instead of Java types or even mix Java types as <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html" title="View JavaDoc"><abbr title="java.util.List" >List</abbr></a> with entities such as <em>Person</em>.
One way to achieve this is to let your concepts inherit from a corresponding JVM type, e.g. let <em>Entity</em>
inherit from <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericType</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a>. But this would result in a lot of 
accidentally inherited properties in your domain model. In Xbase there is an alternative: You can simply define how
to derive a JVM model from your model. This <em>inferred JVM model</em> is the representation of your concepts
in the type system of Xbase.  
</p>
<p>
The main component for the inferred JVM model is the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a>.
It has a single method that takes the root model element as an argument and produces a number of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmDeclaredType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmDeclaredType" >JvmDeclaredTypes</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java" title="View Source Code" >(src)</a>. As Xbase cannot guess how you
would like to map your concepts to JVM elements, you have to implement this component yourself. This
usually boils down to using an injected <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder" >JvmTypesBuilder</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java" title="View Source Code" >(src)</a> to create
a hierarchy of JVM elements. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder" >builder</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java" title="View Source Code" >(src)</a> helps
to initialize the produced types with sensible defaults and encapsulates the logic that associates the
source elements with the derived JVM concepts. As this kind of transformation can be elegantly implemented 
using polymorphic dispatch functions and extension methods, it is a good choice to write the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> in Xtend. It becomes even simpler if you
inherit from the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer" >AbstractModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.java" title="View Source Code" >(src)</a> which traverses the
input model and dispatches to its contents until you decide which elements to handle. 
</p>
<p>
The inference runs in two phases: In the first phase all the types are created with empty bodies. This way you
make sure all types exist and are referable when you create their members in the second phase. 
Use <span class="inlinecode">acceptor.accept(JvmDeclaredType)</span> for the first phase and provide the initialization
code for the second phase. You have to pass a <a href="199-xtext-and-java.html#Xbase_Expressions_Lambda" title="Go to &quot;Lambda Expressions&quot;">lambda expression</a> to the method
<span class="inlinecode">initializeLater()</span> on the return type of the <span class="inlinecode">acceptor.accept()</span> method.
     
For our domain model example, we implement a polymorphic dispatch function <em>infer</em> for
<em>Entities</em> to transform them into a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericType</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a> in the first phase. 
In the second phase, we add a  
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmField.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmField" >JvmField</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmField.java" title="View Source Code" >(src)</a> and corresponding accessors for each <em>Property</em>. The final 
<em>DomainmodelJvmModelInferrer</em> looks like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelJvmModelInferrer&nbsp;<span class="keyword">extends</span>&nbsp;AbstractModelInferrer&nbsp;{<br/>
<br/>
&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;JvmTypesBuilder<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;IQualifiedNameProvider<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;<span class="keyword">void</span>&nbsp;infer(Entity&nbsp;element,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IJvmDeclaredTypeAcceptor&nbsp;acceptor,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span>&nbsp;isPrelinkingPhase)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;acceptor.accept(element.toClass(element.fullyQualifiedName)).initializeLater&nbsp;[<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;documentation&nbsp;=&nbsp;element.documentation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(feature&nbsp;:&nbsp;element.features)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;members&nbsp;+=&nbsp;feature.toField(feature.name,&nbsp;feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;members&nbsp;+=&nbsp;feature.toSetter(feature.name,&nbsp;feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;members&nbsp;+=&nbsp;feature.toGetter(feature.name,&nbsp;feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
Out of the inferred model the corresponding Java class gets generated. To ensure that this will work
make sure that the binding in the rumtime module for <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IGenerator" >IGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/generator/IGenerator.java" title="View Source Code" >(src)</a>
is pointing to <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.JvmModelGenerator" >JvmModelGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.java" title="View Source Code" >(src)</a>. This is the default case, but as we
dealt with a custom implementation in the last section this may lead to problems.
</p>
<a name="xbaseInferredType_8"></a>
<h3>Linking and Indexing</h3>
<p>
As Java elements and your concepts are now represented as JVM model elements, other models can now transparently
link to Java or your DSL. In other words, you can use a mapped element of your DSL in the same places
as the corresponding Java type.
</p>
<p>
The Xbase framework will automatically switch between the JVM element or the DSL element when needed, e.g. when 
following hyperlinks. The component allowing to navigate between the source model and the JVM model is
called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations" >IJvmModelAssociations</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java" title="View Source Code" >(src)</a>, the read-only antagonist of the
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator" >IJvmModelAssociator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.java" title="View Source Code" >(src)</a> that is used by the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder" >JvmTypesBuilder</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java" title="View Source Code" >(src)</a>.
</p>
<p>
By default, the inferred model is <a href="050-heading-runtime.html#global_scopes" title="Go to &quot;Global Scopes and Resource Descriptions&quot;">indexed</a>, so it can be cross referenced from other
models.
</p>
<a name="xbaseExpressions"></a>
<h2>Using Xbase Expressions</h2>
<p>
Xbase is an expression language that can be embedded into Xtext languages. Its syntax is close to Java,
but it additionally offers type inference, lambda expressions, a powerful switch expression and a lot more. For details
on this expression language, please consult the <a href="199-xtext-and-java.html#xbaseLanguageRef_Introduction" title="Go to &quot;Xbase Language Reference&quot;">reference documentation</a> and the 
Xbase tutorial <em>(File &gt; New &gt; Example &gt; Xtext Examples &gt; Xbase Tutorial)</em>. 
</p>
<p>
Xbase ships with an interpreter and a compiler that produces Java code. Thus, it is easy to add  
behavior to your DSLs and make them executable. As Xbase integrates tightly with Java, there is usually no additional code needed to run 
your DSL as part of a Java application. 
</p>
<a name="xbaseExpressions_3"></a>
<h3>Making Your Grammar Refer To Xbase</h3>
<p>
If you want to refer to <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EClassifier.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EClassifier" >EClassifiers</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java" title="View Source Code" >(src)</a> from the Xbase model, you need
to import Xbase first:
</p>
<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;<span class="string">"http://www.eclipse.org/xtext/xbase/Xbase"</span>&nbsp;<span class="keyword">as</span>&nbsp;xbase</span>
</p>
<p>
Now identify the location in your grammar where you want references to Java types and Xbase expressions to appear
and call the appropriate rules of the super grammar. Adding Xbase expression to the domainmodel example leads to the
additional concept <em>Operation</em>: An <em>Operation</em>&apos;s 
parameters are <em>FullJvmFormalParameters</em>. The production rule for <em>FullJvmFormalParameters</em> expects
both the name and the type here. That is reasonable since the type of parameters should not be inferred. 
The operation&apos;s return type is a <em>JvmTypeReference</em> and its <em>body</em> is
an <em>XBlockExpression</em>. The final parser rule reads as:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Operation:<br/>
&nbsp;&nbsp;<span class="string">&apos;op&apos;</span>&nbsp;name=ValidID&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;(params+=FullJvmFormalParameter&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;params+=FullJvmFormalParameter)*)?&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type=JvmTypeReference&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;body=XBlockExpression;
</p>
</div>
</div>
</p>
<p>
If you are unsure which entry point to choose for your expressions, consider the <em>XBlockExpression</em>.
</p>
<p>
To integrate <em>Operations</em> in our models, we have to call this rule. We copy the previous <em>Feature</em>
to a new rule <em>Property</em> and let <em>Feature</em> become the super type of <em>Property</em> and <em>Operation</em>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Feature:<br/>
&nbsp;&nbsp;Property&nbsp;|&nbsp;Operation<br/>
;<br/>
&nbsp;<br/>
Property:<br/>
&nbsp;&nbsp;name&nbsp;=&nbsp;ID&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type&nbsp;=&nbsp;JvmTypeReference<br/>
;
</p>
</div>
</div>
</p>
<p>
Note: You will have to adapt the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> to these
changes, i.e. rename <em>Feature</em> to <em>Property</em> and create a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmOperation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmOperation" >JvmOperation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java" title="View Source Code" >(src)</a>
for each <em>Operation</em>. We leave that as an exercise :-) 
</p>
<p>
If you are done with that, everything will work out of the box. Since each expression is now logically
contained in an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmOperation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmOperation" >operation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java" title="View Source Code" >(src)</a>, all the scoping rules and
visibility constraints are implied from that context. The framework will take care that the operation&apos;s
parameters are visible inside the operation&apos;s body and that the declared return types are validated against the actual
expression types.
</p>
<p>
There is yet another aspect of the JVM model that can be explored. Since all the coarse grained concepts
such as <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmType" >types</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmType.java" title="View Source Code" >(src)</a> and <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/types/JvmOperation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmOperation" >operations</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java" title="View Source Code" >(src)</a>
were already derived from the model, a generator can be used to serialize that information to Java code.
There is no need to write a code generator on top of that. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.JvmModelGenerator" >JvmModelGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.java" title="View Source Code" >(src)</a>
knows how to generate operation bodies properly. 
</p>
<a name="xbaseExpressions_4"></a>
<h3>Using the Xbase Interpreter</h3>
<p>
Sometimes it is more convenient to interpret a model that uses Xbase than to generate code from it.  
Xbase ships with the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a> which makes this
rather easy.
</p>
<p>
An interpreter is essentially an external visitor, that recursively processes a model based on the model
element&apos;s types. In the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a>, the method
<em>doEvaluate(XExpression, IEvaluationContext, CancelIndicator)</em> delegates to more specialised implementations e.g.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">protected</span>&nbsp;Object&nbsp;_doEvaluate(XBlockExpression&nbsp;literal,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEvaluationContext&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CancelIndicator&nbsp;indicator)
</p>
</div>
</div>
</p>
<p>
The <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IEvaluationContext.html" title="View JavaDoc"><abbr title="org.eclipse.core.expressions.IEvaluationContext" >IEvaluationContext</abbr></a> keeps the state of the running application,
i.e. the local variables and their values. Additionally, it can be <em>fork</em>ed, thus allowing to shadow the 
elements of the original context. Here is an example code snippet how to call the
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;<span class="keyword">private</span>&nbsp;XbaseInterpreter&nbsp;xbaseInterpreter;<br/>
<br/>
@Inject&nbsp;<span class="keyword">private</span>&nbsp;Provider&lt;IEvaluationContext&gt;&nbsp;contextProvider;<br/>
<br/>
...<br/>
<span class="keyword">public</span>&nbsp;Object&nbsp;evaluate(XExpression&nbsp;expression,&nbsp;Object&nbsp;thisElement)&nbsp;{<br/>
&nbsp;&nbsp;IEvaluationContext&nbsp;evaluationContext&nbsp;=&nbsp;contextProvider.get();<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;provide&nbsp;initial&nbsp;context&nbsp;and&nbsp;implicit&nbsp;variables<br/>
</span>&nbsp;&nbsp;evaluationContext.newValue(XbaseScopeProvider.THIS,&nbsp;thisElement);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;IEvaluationResult&nbsp;result&nbsp;=&nbsp;xbaseInterpreter.evaluate(expression,&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;evaluationContext,&nbsp;CancelIndicator.NullImpl);<br/>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(result.getException()&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;handle&nbsp;exception<br/>
</span>&nbsp;&nbsp;}&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;result.getResult();<br/>
}
</p>
</div>
</div>
</p>
<a name="xbaseLanguageRef_Introduction"></a>
<h2>Xbase Language Reference</h2>
<p>
This document describes the expression language library Xbase. Xbase is a partial programming language
implemented in Xtext and is meant to be embedded and extended within other programming languages and 
domain-specific languages (DSL) written in Xtext. Xtext is a highly extendible language development 
framework covering all aspects of language infrastructure such as parsers, linkers, compilers, 
interpreters and even full-blown IDE support based on Eclipse.  
</p>
<p>
Developing DSLs has become incredibly easy with Xtext. Structural languages which introduce new 
coarse-grained concepts, such as services, entities, value objects or state-machines can be developed 
in minutes. However, software systems do not consist of structures solely. At some point a system needs 
to have some behavior, which is usually specified using so called <em>expressions</em>. Expressions are the 
heart of every programming language and are not easy to get right. On the other hand, expressions are 
well understood and many programming languages share a common set and understanding of expressions.
</p>
<p>
That is why most people do not add support for expressions in their DSL but try to solve this 
differently. The most often used workaround is to define only the structural information in the DSL 
and add behavior by modifying or extending the generated code. It is not only unpleasant to write, 
read and maintain information which closely belongs together in two different places, abstraction levels 
and languages. Also, modifying the generated source code comes with a lot of additional problems. 
This has long time been the preferred solution since adding support for expressions (and a corresponding 
execution environment) for your language has been hard - even with Xtext.
</p>
<p>
Xbase serves as a language library providing a common expression language bound to the Java platform 
(i.e. Java Virtual Machine). It consists of an Xtext grammar, as well as reusable and adaptable 
implementations for the different aspects of a language infrastructure such as an AST structure, a 
compiler, an interpreter, a linker, and a static analyzer. In addition it comes with implementations to 
integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects
like content assistance, syntax coloring, hovering, folding and navigation can be easily integrated and 
reused within any Xtext based language. 
</p>
<p>
Conceptually and syntactically, Xbase is very close to Java statements and expressions, but with a few 
differences:
<ul>
	<li>
		No checked exceptions
	</li>
	<li>
		Everything is an expression, there are no statements
	</li>
	<li>
		Lambda expressions
	</li>
	<li>
		Type inference
	</li>
	<li>
		Properties
	</li>
	<li>
		Simple operator overloading
	</li>
	<li>
		Powerful switch expressions
	</li>
</ul>
</p>
<a name="xbaseLanguageRef_Syntax"></a>
<h3>Lexical Syntax</h3>
<p>
Xbase comes with a small set of terminal rules, which can be overridden and hence changed by users. 
However the default implementation is carefully chosen and it is recommended to stick with the 
lexical syntax described in the following.
</p>
<a name="Xbase_Syntax_Identifiers"></a>
<h4>Identifiers</h4>
<p>
Identifiers are used to name all constructs, such as types, methods and variables. Xbase uses the default
identifier-syntax from Xtext - compared to Java, they are slightly simplified to match the common cases
while having less ambiguities. They start with a letter <em>a</em>-<em>z</em>, <em>A</em>-<em>Z</em> or an underscore followed
by more of these characters or any digit <em>0</em>-<em>9</em>. 
</p>
<a name="Xbase_Syntax_EscapedIdentifiers"></a>
<h5>Escaped Identifiers</h5>
<p>
Identifiers must not have the same spelling as any reserved keyword. 
However, this limitation can be avoided by escaping identifiers with the prefix <span class="inlinecode">^</span>. Escaped identifiers 
are used in cases when there is a conflict with a reserved keyword. Imagine you have introduced a 
keyword <span class="inlinecode">service</span> in your language but want to call a Java property <em>service</em>. 
In such cases you can use the escaped identifier <span class="inlinecode">^service</span> to reference the Java property.
</p>
<a name="Xbase_Syntax_Identifiers_3"></a>
<h5>Syntax</h5>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;ID:&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;^&apos;</span>?&nbsp;(<span class="string">&apos;a&apos;</span>..<span class="string">&apos;z&apos;</span>|<span class="string">&apos;A&apos;</span>..<span class="string">&apos;Z&apos;</span>|<span class="string">&apos;_&apos;</span>|<span class="string">&apos;$&apos;</span>)&nbsp;(<span class="string">&apos;a&apos;</span>..<span class="string">&apos;z&apos;</span>|<span class="string">&apos;A&apos;</span>..<span class="string">&apos;Z&apos;</span>|<span class="string">&apos;_&apos;</span>|<span class="string">&apos;$&apos;</span>|<span class="string">&apos;0&apos;</span>..<span class="string">&apos;9&apos;</span>)*<br/>
;
</p>
</div>
</div>
</p>
<a name="Xbase_Syntax_Identifiers_4"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">Foo</span>
	</li>
	<li>
		<span class="inlinecode">Foo42</span>
	</li>
	<li>
		<span class="inlinecode">FOO</span>
	</li>
	<li>
		<span class="inlinecode">_42</span>
	</li>
	<li>
		<span class="inlinecode">_foo</span>
	</li>
	<li>
		<span class="inlinecode">$$foo$$</span>
	</li>
	<li>
		<span class="inlinecode">^extends</span>
	</li>
</ul>
</p>
<a name="Xbase_Syntax_Comments"></a>
<h4>Comments</h4>
<p>
Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
The syntax is the same as the one known from Java (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.7">§ 3.7 Comments</a>).
</p>
<a name="Xbase_Syntax_Whitespace"></a>
<h4>White Space</h4>
<p>
The white space characters <span class="inlinecode"><span class="string">&apos;&nbsp;&apos;</span></span>, <span class="inlinecode"><span class="string">&apos;\t&apos;</span></span>, <span class="inlinecode"><span class="string">&apos;\n&apos;</span></span>, and <span class="inlinecode"><span class="string">&apos;\r&apos;</span></span> are allowed to occur anywhere between the other syntactic elements. 
</p>
<a name="Xbase_Syntax_Keywords"></a>
<h4>Reserved Keywords</h4>
<p>
The following list of words are reserved keywords, thus reducing the set of possible identifiers:
<ol>
	<li>
		<span class="inlinecode"><span class="keyword">as</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">case</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">catch</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">default</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">do</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">else</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">extends</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">extension</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">false</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">finally</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">for</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">import</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">instanceof</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">new</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">null</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">return</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">static</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">super</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">switch</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">throw</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">true</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">try</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">typeof</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">val</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">var</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">while</span></span>
	</li>
</ol>
</p>
<p>
The four keywords <span class="inlinecode"><span class="keyword">extends</span>,&nbsp;<span class="keyword">static</span>,&nbsp;<span class="keyword">import</span>,&nbsp;<span class="keyword">extension</span></span> can be used when invoking operations.
In case some of the other keywords have to be used as identifiers, the escape character for 
<a href="199-xtext-and-java.html#Xbase_Syntax_EscapedIdentifiers" title="Go to &quot;Escaped Identifiers&quot;">identifiers</a> comes in handy. 
</p>
<a name="xbaseLanguageRef_Types"></a>
<h3>Types</h3>
<p>
Basically all kinds of JVM types are available and referable. 
</p>
<a name="Xbase_Types_TypeReferences"></a>
<h4>Simple Type References</h4>
<p>
A simple type reference only consists of a <em>qualified name</em>. A qualified name is a name made up of identifiers which are separated by a dot 
(like in Java).
</p>
<p>
There is no parser rule for a simple type reference, as it is expressed as a parameterized type references without parameters.
</p>
<a name="Xbase_Types_TypeReferences_3"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">java.lang.String</span>
	</li>
	<li>
		<span class="inlinecode">String</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_ParameterizedTypeReference"></a>
<h4>Parameterized Type References</h4>
<p>
The general syntax for type references allows to take any number of type arguments. The semantics as well
as the syntax is almost the same as in Java, so please refer to the third edition of the 
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html">Java Language Specification</a>.
</p>
<p>
The only difference is that in Xbase a type reference can also be a function type. In the following the full syntax of type references is shown, including function types and
type arguments.
</p>
<a name="Xbase_Types_ParameterizedTypeReference_3"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">String</span>
	</li>
	<li>
		<span class="inlinecode">java.lang.String</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;Comparable&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;FooBar&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;<span class="keyword">super</span>&nbsp;MyLowerBound&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;=&gt;Boolean&gt;</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_Primitives"></a>
<h4>Primitives</h4>
<p>
Xbase supports all Java primitives. The conformance rules (e.g. boxing and unboxing) are also exactly like defined
in the Java Language Specification.
</p>
<a name="Xbase_Types_Arrays"></a>
<h4>Arrays</h4>
<p>
Arrays cannot be instantiated arbitrarily, but there are a couple of useful library functions that
allow to create arrays with a fixed length or an initial value set.
Besides this restriction, they can be passed around and they are transparently converted to a List of the component type on demand.
</p>
<p>
In other words, the return type of a Java method that returns an array of ints (<span class="inlinecode"><span class="keyword">int</span>[]</span>) can be directly assigned to 
a variable of type <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html" title="View JavaDoc"><abbr title="java.util.List" >List&lt;Integer&gt;</abbr></a>. Due to type inference
this conversion happens implicitly. The conversion is bi-directional: Any method that takes an array as argument can be invoked 
with an argument that has the type <span class="inlinecode">List&lt;ComponentType&gt;</span> instead.
</p>
<a name="Xbase_Types_FunctionTypes"></a>
<h4>Function Types</h4>
<p>
Xbase introduces <em>lambda expressions</em>, and therefore an additional function type signature. On the JVM-Level a lambda
expression (or more generally any function object) is just an instance of one of the types in 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Functions" >Functions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java" title="View Source Code" >(src)</a>, 
depending on the number of arguments. However, as lambda expressions are a very important language feature, 
a special sugared syntax for function types has been introduced.  
So instead of writing <span class="inlinecode">Function1&lt;String,&nbsp;Boolean&gt;</span> one can write <span class="inlinecode">(String)=&gt;<span class="keyword">boolean</span></span>.
</p>
<p>
For more information on lambda expressions see <a href="199-xtext-and-java.html#Xbase_Expressions_Lambda" title="Go to &quot;Lambda Expressions&quot;" >section Xbase_Expressions_Lambda</a>.
</p>
<a name="Xbase_Types_FunctionTypes_3"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">=&gt;Boolean&nbsp;<span class="comment">//&nbsp;predicate&nbsp;without&nbsp;parameters</span></span>
	</li>
	<li>
		<span class="inlinecode">()=&gt;String&nbsp;<span class="comment">//&nbsp;provider&nbsp;of&nbsp;string</span></span>
	</li>
	<li>
		<span class="inlinecode">(String)=&gt;<span class="keyword">boolean</span>&nbsp;<span class="comment">//&nbsp;One&nbsp;argument&nbsp;predicate</span></span>
	</li>
	<li>
		<span class="inlinecode">(Mutable)=&gt;<span class="keyword">void</span>&nbsp;<span class="comment">//&nbsp;A&nbsp;procedure&nbsp;doing&nbsp;side&nbsp;effects&nbsp;only</span></span>
	</li>
	<li>
		<span class="inlinecode">(List&lt;String&gt;,&nbsp;Integer)=&gt;String</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_ConformanceRules"></a>
<h4>Conformance and Conversion</h4>
<p>
Type conformance rules are used in order to find out whether some expression can be used in a certain situation.
For instance when assigning a value to a variable, 
the type of the right hand expression needs to conform to the type of the variable.
</p>
<p>
As Xbase implements the type system of Java it also fully supports the conformance rules defined
in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html">Java Language Specification</a>.
</p>
<p>
Some types in Xbase can be used synonymously even if they do not conform to each other in Java. An example for this are arrays and lists 
or function types with compatible function parameters. Objects of these types are implicitly converted by Xbase on demand.   
</p>
<a name="Xbase_Types_CommonSuperType"></a>
<h4>Common Super Type</h4>
<p>
Because of type inference Xbase sometimes needs to compute the most common super type of a given set
of types. 
</p>
<p>
For a set <em>[T1,T2,...Tn]</em> of types the common super type is computed by using the linear type inheritance sequence of <em>T1</em> and is iterated until one type
conforms to each <em>T2,..,Tn</em>. The linear type inheritance sequence of <em>T1</em> is computed by ordering all types which are part if the type hierarchy of <em>T1</em>
by their specificity. A type <em>T1</em> is considered more specific than <em>T2</em> if <em>T1</em> is a subtype of <em>T2</em>. Any types with equal specificity will be sorted by
the maximal distance to the originating subtype. <em>CharSequence</em> has distance 2 to <em>StringBuilder</em> because
the super type <em>AbstractStringBuilder</em> implements the interface, too. Even if <em>StringBuilder</em> implements
<em>CharSequence</em> directly, the interface gets distance 2 in the ordering because it is not the most general class
in the type hierarchy that implements the interface. If the distances for two classes are the same in
the hierarchy, their qualified name is used as the compare-key to ensure deterministic results. 
</p>
<a name="xbaseLanguageRef_Expressions"></a>
<h3>Expressions</h3>
<p>
Expressions are the main language constructs which are used to express behavior and compute values. The concept of 
statements is not supported, but instead powerful expressions are used to handle situations in which the imperative nature of statements would
be helpful. An expression always results in a value (it might be the value <span class="inlinecode"><span class="keyword">null</span></span> or of type <span class="inlinecode"><span class="keyword">void</span></span> though). In addition, every resolved expression is
of a static type.
</p>
<a name="Xbase_Expressions_Literals"></a>
<h4>Literals</h4>
<p>
A literal denotes a fixed unchangeable value. Literals for strings, numbers, booleans,
<span class="inlinecode"><span class="keyword">null</span></span> and Java types are supported. Additionally, there exists a literal syntax for
collections and arrays.
</p>
<a name="Xbase_Expressions_StringLiteral"></a>
<h5>String Literals</h5>
<p>
String literals can either use <span class="inlinecode"><span class="string">&apos;single&nbsp;quotes&apos;</span></span> or <span class="inlinecode"><span class="string">"double&nbsp;quotes"</span></span> as their terminating characters. When using
double quotes all literals allowed by Java string literals are supported. In addition new line 
characters are allowed, i.e. in Xbase string literals can span multiple lines. When using single 
quotes the only difference is that single quotes within the literal have to be escaped and double quotes 
do not.
</p>
<p>
See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.5">§ 3.10.5 String Literals</a>
</p>
<p>
In contrast to Java, equal string literals within the same class do not necessarily refer to the same
instance at runtime, especially in the interpreted mode.
</p>
<a name="Xbase_Expressions_Literals_3"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="string">&apos;Foo&nbsp;Bar&nbsp;Baz&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Foo&nbsp;Bar&nbsp;Baz"</span></span>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="string">"the&nbsp;quick&nbsp;brown&nbsp;fox<br/>
		&nbsp;&nbsp;&nbsp;jumps&nbsp;over&nbsp;the&nbsp;lazy&nbsp;dog."</span>
		</p>
		</div>
		</div>
	</li>
	<li>
		<span class="inlinecode"><span class="string">&apos;Escapes&nbsp;:&nbsp;\&apos;&nbsp;&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Escapes&nbsp;:&nbsp;\"&nbsp;"</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_NumberLiteral"></a>
<h5>Number Literals</h5>
<p>
Xbase supports roughly the same number literals as Java with a few notable differences.   
As in Java 7, you can separate digits using <span class="inlinecode">_</span> for better readability
of large numbers.
 
An integer literal represents an <span class="inlinecode"><span class="keyword">int</span></span>, a <span class="inlinecode"><span class="keyword">long</span></span> (suffix <span class="inlinecode">L</span>) or even a
<a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigInteger.html" title="View JavaDoc"><abbr title="java.math.BigInteger" >BigInteger</abbr></a> (suffix <span class="inlinecode">BI</span>). There are no octal number literals.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
42<br/>
1_234_567_890&nbsp;<br/>
0xbeef&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;hexadecimal<br/>
</span>077&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;decimal&nbsp;77&nbsp;(*NOT*&nbsp;octal)<br/>
</span>42L<br/>
0xbeef#L&nbsp;<span class="comment">//&nbsp;hexadecimal,&nbsp;mind&nbsp;the&nbsp;&apos;#&apos;<br/>
</span>0xbeef_beef_beef_beef_beef#BI&nbsp;<span class="comment">//&nbsp;BigInteger</span>
</p>
</div>
</div>
</p>
<p>
A floating-point literal creates a <span class="inlinecode"><span class="keyword">double</span></span> (suffix <span class="inlinecode">D</span> or omitted), a <span class="inlinecode"><span class="keyword">float</span></span> 
(suffix <span class="inlinecode">F</span>) or a <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html" title="View JavaDoc"><abbr title="java.math.BigDecimal" >BigDecimal</abbr></a> (suffix <span class="inlinecode">BD</span>). If you use a <span class="inlinecode">.</span> sign you have to 
specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
literals.  
<div class="literallayout">
<div class="incode">
<p class="code">
42d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;double<br/>
</span>0.42e2&nbsp;&nbsp;<span class="comment">//&nbsp;implicit&nbsp;double<br/>
</span>0.42e2f&nbsp;<span class="comment">//&nbsp;float<br/>
</span>4.2f&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;float<br/>
</span>0.123_456_789_123_456_789_123_456_789e2000bd&nbsp;<span class="comment">//&nbsp;BigDecimal</span>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_BooleanLiteral"></a>
<h5>Boolean Literals</h5>
<p>
There are two boolean literals, <span class="inlinecode"><span class="keyword">true</span></span> and <span class="inlinecode"><span class="keyword">false</span></span> which correspond to their Java counterpart of type <em>boolean</em>. 
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">true</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">false</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_NullLiteral"></a>
<h5>Null Literal</h5>
<p>
The null literal is, as in Java, <span class="inlinecode"><span class="keyword">null</span></span>. 
It is compatible to any reference type and therefore always of the null type.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">null</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_TypeLiteral"></a>
<h5>Type Literals</h5>
<p>
The syntax for type literals is generally the plain name of the type, e.g. the Xbase snippet <span class="inlinecode">String</span>
is equivalent to the Java code <span class="inlinecode">String.<span class="keyword">class</span></span>. Nested types use the delimiter <span class="inlinecode"><span class="string">&apos;.&apos;</span></span>.
</p>
<p>
To disambiguate the expression, type literals may also be specified using the keyword <span class="inlinecode"><span class="keyword">typeof</span></span>.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">Map.Entry</span> is equivalent to <span class="inlinecode">Map.Entry.<span class="keyword">class</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">typeof</span>(StringBuilder)</span> yields <span class="inlinecode">StringBuilder.<span class="keyword">class</span></span>
	</li>
</ul>
</p>
<p>
Consequently it is possible to access the members of a type reflectively by using its plain name <span class="inlinecode">String.getDeclaredFields</span>.
</p>
<p>
Previous versions of Xbase used the dollar as the delimiter character for nested types:
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">typeof</span>(Map$Entry)</span> yields <span class="inlinecode">Map.Entry.<span class="keyword">class</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_TypeCasts"></a>
<h4>Type Casts</h4>
<p>
Type cast behave the same as in Java, but have a more readable syntax.
Type casts bind stronger than any other operator but weaker than feature calls.
</p>
<p>
The conformance rules for casts are defined in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5">Java Language Specification</a>.
</p>
<a name="Xbase_Expressions_TypeCasts_3"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;<span class="keyword">as</span>&nbsp;MyType</span>
	</li>
	<li>
		<span class="inlinecode">(1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23))&nbsp;<span class="keyword">as</span>&nbsp;BigInteger</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Operators"></a>
<h4>Infix Operators / Operator Overloading</h4>
<p>
There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.
</p>
<p>
<table>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_add(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_remove(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;||&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_or(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&amp;&amp;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_and(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;==&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_equals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;!=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_notEquals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;===&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_tripleEquals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;!==&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_tripleNotEquals(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_lessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_greaterThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_lessEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_greaterEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_mappedTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;..&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_upTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;..&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_greaterThanDoubleDot(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;..&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_doubleDotLessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;=&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_doubleArrow(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_doubleLessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_doubleGreaterThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&lt;&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_tripleLessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&gt;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_tripleGreaterThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_diamond(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;?:&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_elvis(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;=&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_spaceship(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_plus(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_minus(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;*&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_multiply(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;/&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_divide(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;%&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_modulo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;**&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1.operator_power(e2)</span>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">!&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1.operator_not()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">-&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1.operator_minus()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">+&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1.operator_plus()</span>
</td>
</tr>
</table>

    
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The assignment operator <span class="inlinecode">+=</span> is right-to-left associative in the same way as the plain assignment
operator <span class="inlinecode">=</span> is. Consequently, <span class="inlinecode">a&nbsp;=&nbsp;b&nbsp;=&nbsp;c</span> is executed as <span class="inlinecode">a&nbsp;=&nbsp;(b&nbsp;=&nbsp;c)</span>. All other
operators are left-to-right associative. Parentheses can be used to adjust the default precedence and associativity. 
</p>
<a name="Xbase_Expressions_Operators_3"></a>
<h5>Short-Circuit Boolean Operators</h5>
<p>
If the operators <span class="inlinecode">||</span> and <span class="inlinecode">&amp;&amp;</span> are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand is not evaluated at all in the following cases: 
<ol>
	<li>
		in the case of <span class="inlinecode">||</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">true</span></span>.
	</li>
	<li>
		in the case of <span class="inlinecode">&amp;&amp;</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">false</span></span>.
	</li>
</ol>
</p>
<a name="Xbase_Expressions_Operators_4"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">myList&nbsp;+=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&gt;&nbsp;23&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</span>
	</li>
	<li>
		<span class="inlinecode">1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23)</span>
	</li>
	<li>
		<span class="inlinecode">!(x)</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Operators_5"></a>
<h5>Assignment Operators</h5>
<p>
Compound assignment operators can be used as a shorthand for the assignment of a binary expression.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">var</span>&nbsp;BigDecimal&nbsp;bd&nbsp;=&nbsp;45bd<br/>
bd&nbsp;+=&nbsp;12bd&nbsp;<span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;bd&nbsp;=&nbsp;bd&nbsp;+&nbsp;12bd<br/>
</span>bd&nbsp;-=&nbsp;12bd&nbsp;<span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;bd&nbsp;=&nbsp;bd&nbsp;-&nbsp;12bd<br/>
</span>bd&nbsp;/=&nbsp;12bd&nbsp;<span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;bd&nbsp;=&nbsp;bd&nbsp;/&nbsp;12bd<br/>
</span>bd&nbsp;*=&nbsp;12bd&nbsp;<span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;bd&nbsp;=&nbsp;bd&nbsp;*&nbsp;12bd</span>
</p>
</div>
</div>
</p>
<p>
Compound assignments work automatically if the binary operator is declared. The following compound assignment operators 
are supported:
</p>
<p>
<table>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">+</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">-</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;*=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">*</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;/=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">/</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;%=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">%</span>
</td>
</tr>
</table>
</p>
<a name="Xbase_Expressions_Operators_6"></a>
<h5>Postfix Operators</h5>
<p>
The two postfix operators <span class="inlinecode">++</span> and <span class="inlinecode">--</span> use the following method mapping:
</p>
<p>
<table>
<tr>
<td>
<span class="inlinecode">e1++</span>
</td>
<td>
<span class="inlinecode">e1.operator_plusPlus()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1--</span>
</td>
<td>
<span class="inlinecode">e1.operator_minusMinus()</span>
</td>
</tr>
</table>
</p>
<a name="Xbase_Expressions_Operators_7"></a>
<h5>With Operator</h5>
<p>
The <em>with</em> operator <span class="inlinecode">=&gt;</span> executes the <a href="199-xtext-and-java.html#Xbase_Expressions_Lambda" title="Go to &quot;Lambda Expressions&quot;">lambda expression</a> with a single parameter on the right-hand
 side with a given argument on its left-hand side. The result is the left operand after applying the lambda expression. In 
combination with the  <a href="199-xtext-and-java.html#Xbase_Expressions_implicit_parameter" title="Go to &quot;Implicit Parameter it&quot;">implicit parameter</a> <span class="inlinecode"><span class="keyword">it</span></span> this allows very convenient
initialization of newly created objects. Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">val</span>&nbsp;person&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Person&nbsp;=&gt;&nbsp;[<br/>
&nbsp;&nbsp;firstName&nbsp;=&nbsp;<span class="string">&apos;John&apos;</span><br/>
&nbsp;&nbsp;lastName&nbsp;=&nbsp;<span class="string">&apos;Coltrane&apos;</span><br/>
]<br/>
<span class="comment">//&nbsp;equivalent&nbsp;to<br/>
</span><span class="keyword">val</span>&nbsp;person&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Person<br/>
person.firstName&nbsp;=&nbsp;<span class="string">&apos;John&apos;</span><br/>
person.lastName&nbsp;=&nbsp;<span class="string">&apos;Coltrane&apos;</span>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_PropertyAssignment"></a>
<h4>Assignments</h4>
<p>
<a href="199-xtext-and-java.html#Xbase_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Local variables</a> can be reassigned using the <span class="inlinecode">=</span> operator. Also properties can be set using 
that operator:
Given the expression 
</p>
<p>
<span class="inlinecode">myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span></span>
</p>
<p>
The compiler first looks for an accessible Java Field called <span class="inlinecode">myProperty</span> on the declared or inferred type of <span class="inlinecode">myObj</span>. If such
a field can be found, the expressions translates to
the following Java code:
</p>
<p>
<span class="inlinecode">myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span>;</span>
</p>
<p>
Remember, in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.
</p>
<p>
If there is no accessible field on the left operand&apos;s type, a method called <span class="inlinecode">setMyProperty(OneArg)</span> (JavaBeans
setter method) is looked up. It has to take one argument of the type (or a super type) of the right hand operand. The return value of the assignment will be the 
return value of the setter method (which is usually of type <span class="inlinecode"><span class="keyword">void</span></span> and therefore the value <span class="inlinecode"><span class="keyword">null</span></span>). 
As a result the compiler translates to :
</p>
<p>
<span class="inlinecode">myObj.setMyProperty(<span class="string">"foo"</span>)</span>
</p>
<a name="Xbase_Expressions_FeatureCalls"></a>
<h4>Feature Calls</h4>
<p>
A feature call is used to access members of objects, such as fields and methods, but it can also refer to local variables and parameters, 
which are made available by the current expression&apos;s scope. 
</p>
<a name="Xbase_Expressions_PropertyAccess"></a>
<h5>Property Access</h5>
<p>
Feature calls are directly translated to their Java equivalent with the exception, that access to properties follows similar rules as 
described in <a href="199-xtext-and-java.html#Xbase_Expressions_PropertyAssignment" title="Go to &quot;Assignments&quot;" >section Xbase_Expressions_PropertyAssignment</a>. 
That is, for the expression
</p>
<p>
<span class="inlinecode">myObj.myProperty</span>
</p>
<p>
the compiler first looks for an accessible field <span class="inlinecode">myProperty</span> in the type of <span class="inlinecode">myObj</span>. If no such field exists it 
tries to find a method called <span class="inlinecode">myProperty()</span> before it looks 
for the getter methods <span class="inlinecode">getMyProperty()</span>. If none of these members can be found, the expression is unbound and a compilation error is indicated.
</p>
<a name="Xbase_Expressions_NullSafeFeatureCalls"></a>
<h5>Null-Safe Feature Call</h5>
<p>
Checking for null references can make code very unreadable. In many situations it is ok for an expression to return <span class="inlinecode"><span class="keyword">null</span></span> if a receiver was <span class="inlinecode"><span class="keyword">null</span></span>.
Xbase supports the safe navigation operator <span class="inlinecode">?.</span> to make such code more readable.
</p>
<p>
Instead of writing 
</p>
<p>
<span class="inlinecode"><span class="keyword">if</span>&nbsp;(&nbsp;myRef&nbsp;!=&nbsp;<span class="keyword">null</span>&nbsp;)&nbsp;myRef.doStuff()</span>
</p>
<p>
one can write
</p>
<p>
<span class="inlinecode">myRef?.doStuff()</span>
</p>
<a name="Xbase_Expressions_staticFeatureCalls"></a>
<h5>Static Feature Calls</h5>
<p>
Static feature calls use the same notation as in Java, e.g. it is possible write <span class="inlinecode">Collections.emptyList()</span>
in Xbase. To make the static invocation more explicit, the double colon can be used as the delimiter.
The following snippets are fully equivalent:
</p>
<p>
<span class="inlinecode">java.util.Collections::emptyList</span>
</p>
<p>
<span class="inlinecode">java.util.Collections.emptyList</span>
</p>
<p>
Prior to Xbase 2.4.2, this more verbose variant was the only supported syntax to invoke static methods:
</p>
<p>
<span class="inlinecode">java::util::Collections::emptyList</span>
</p>
<a name="Xbase_Expressions_ImplicitThis"></a>
<h4>Implicit variables 'this' and 'it'</h4>
<p>
If the current scope contains a variable named <span class="inlinecode"><span class="keyword">this</span></span> or <span class="inlinecode"><span class="keyword">it</span></span>, the compiler will make all its members available implicitly.
That is if one of 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">it</span>.myProperty<br/>
<span class="keyword">this</span>.myProperty
</p>
</div>
</div>

is a valid expression
<span class="inlinecode">myProperty</span>
is valid as well. It resolves to the same feature as long as there is no local variable <span class="inlinecode">myProperty</span> declared,
which would have higher precedence. 
</p>
<p>
As <span class="inlinecode"><span class="keyword">this</span></span> is bound to the surrounding object in Java, <span class="inlinecode"><span class="keyword">it</span></span> can be used
in finer-grained constructs such as function parameters. That is why <span class="inlinecode"><span class="keyword">it</span>.myProperty</span> has 
higher precedence than <span class="inlinecode"><span class="keyword">this</span>.myProperty</span>. <span class="inlinecode"><span class="keyword">it</span></span> is also the 
<a href="199-xtext-and-java.html#Xbase_Expressions_implicit_parameter" title="Go to &quot;Implicit Parameter it&quot;">default parameter name in lambda expressions</a>. 
</p>
<a name="Xbase_Expressions_ConstructorCall"></a>
<h4>Constructor Call</h4>
<p>
Construction of objects is done by invoking Java constructors. The syntax is exactly as in Java.
</p>
<a name="Xbase_Expressions_ConstructorCall_2"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		
		    <span class="inlinecode"><span class="keyword">new</span>&nbsp;String()</span>
	</li>
	<li>
		
		    <span class="inlinecode"><span class="keyword">new</span>&nbsp;java.util.ArrayList&lt;java.math.BigDecimal&gt;()</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Lambda"></a>
<h4>Lambda Expressions</h4>
<p>
A lambda expression is a literal that defines an anonymous function. Xbase&apos; lambda expressions are allowed
to access variables of the declarator. Any final variables and parameters visible at construction 
time can be referred to in the lambda expression&apos;s body. These expressions are also known as closures.
</p>
<p>
Lambda expressions are surrounded by square brackets (\<span class="inlinecode">[]</span>):
</p>
<p>
<span class="inlinecode">myList.findFirst([&nbsp;e&nbsp;|&nbsp;e.name==<span class="keyword">null</span>&nbsp;])</span>
</p>
<p>
When a function object is expected to be the last parameter of a feature call, you may declare the lambda expression after the parentheses: 
</p>
<p>
<span class="inlinecode">myList.findFirst()&nbsp;[&nbsp;e&nbsp;|&nbsp;e.name==<span class="keyword">null</span>&nbsp;]</span>
</p>
<p>
Since in Xbase parentheses are optional for method calls, the same can be written as:
</p>
<p>
<span class="inlinecode">myList.findFirst[&nbsp;e&nbsp;|&nbsp;e.name==<span class="keyword">null</span>&nbsp;]</span>
</p>
<p>
This example can be further simplified since the lambda&apos;s parameter is available as the implicit variable <span class="inlinecode"><span class="keyword">it</span></span>, 
if the parameter is not declared explicitly: 
</p>
<p>
<span class="inlinecode">myList.findFirst[&nbsp;<span class="keyword">it</span>.name==<span class="keyword">null</span>&nbsp;]</span>
</p>
<p>
Since <span class="inlinecode"><span class="keyword">it</span></span> is implicit, this is the same as:
</p>
<p>
<span class="inlinecode">myList.findFirst[&nbsp;name==<span class="keyword">null</span>&nbsp;]</span>
</p>
<p>
Another use case for lambda expressions is to store function objects in variables:
</p>
<p>
<span class="inlinecode"><span class="keyword">val</span>&nbsp;func&nbsp;=&nbsp;[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.length&gt;3&nbsp;]</span>
</p>
<a name="Xbase_Expressions_LambdaTypeInference"></a>
<h5>Typing</h5>
<p>
Lambda expressions produce function objects. The type is a <a href="199-xtext-and-java.html#Xbase_Types_FunctionTypes" title="Go to &quot;Function Types&quot;">function type</a>, parameterized
with the types of the lambda&apos;s parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the lambda expression is used in a context where this is possible.
</p>
<p>
For instance, given the following Java method signature:
<span class="inlinecode"><span class="keyword">public</span>&nbsp;T&nbsp;&lt;T&gt;getFirst(List&lt;T&gt;&nbsp;list,&nbsp;Function0&lt;T,Boolean&gt;&nbsp;predicate)</span> 
</p>
<p>
the type of the parameter can be inferred. Which allows users to write:
<span class="inlinecode">newArrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst[&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;]</span>
instead of 
<span class="inlinecode">newArrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst[&nbsp;String&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;]</span>
</p>
<a name="Xbase_Expressions_FunctionMapping"></a>
<h5>Function Mapping</h5>
<p>
An Xbase lambda expression is a Java object of one of the <em>Function</em> interfaces that are part of the runtime library of Xbase. There is an interface 
for each number of parameters (up to six parameters). The names of the interfaces are 
<ul>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.Function0.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Functions.Function0" >Function0&lt;ReturnType&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java" title="View Source Code" >(src)</a> for zero parameters, 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.Function1.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Functions.Function1" >Function1&lt;Param1Type, ReturnType&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java" title="View Source Code" >(src)</a> for one parameters, 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.Function2.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Functions.Function2" >Function2&lt;Param1Type, Param2Type, ReturnType&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java" title="View Source Code" >(src)</a> for two parameters, 
	</li>
	<li>
		... 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.Function6.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Functions.Function6" >Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java" title="View Source Code" >(src)</a> for six parameters, 
	</li>
</ul>

or
<ul>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.Procedure0.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Procedures.Procedure0" >Procedure0</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java" title="View Source Code" >(src)</a> for zero parameters, 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.Procedure1.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Procedures.Procedure1" >Procedure1&lt;Param1Type&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java" title="View Source Code" >(src)</a> for one parameters, 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.Procedure2.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Procedures.Procedure2" >Procedure2&lt;Param1Type, Param2Type&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java" title="View Source Code" >(src)</a> for two parameters, 
	</li>
	<li>
		... 
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.Procedure6.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.lib.Procedures.Procedure6" >Procedure6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type&gt;</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java" title="View Source Code" >(src)</a> for six parameters, 
	</li>
</ul>

if the return type is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<p>
In order to allow seamless integration with existing Java libraries such as the JDK or Google Guava 
(formerly known as Google Collect) lambda expressions are auto coerced to expected types if those 
types declare only one abstract method (methods from <span class="inlinecode">java.lang.Object</span> don&apos;t count).
</p>
<p>
As a result given the method <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html" title="View JavaDoc"><abbr title="java.util.Collections" >Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;)</abbr></a> is available
as an extension method, it can be invoked like this
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
newArrayList(&nbsp;<span class="string">&apos;aaa&apos;</span>,&nbsp;<span class="string">&apos;bb&apos;</span>,&nbsp;<span class="string">&apos;c&apos;</span>&nbsp;).sort&nbsp;[<br/>
&nbsp;&nbsp;e1,&nbsp;e2&nbsp;|&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&gt;&nbsp;e2.length&nbsp;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&lt;&nbsp;e2.length&nbsp;)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
]
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_implicit_parameter"></a>
<h5>Implicit Parameter <em>it</em></h5>
<p>
If a lambda expression has a single parameter whose type can be inferred, the declaration of the parameter can
be omitted. Use <span class="inlinecode"><span class="keyword">it</span></span> to refer to the parameter inside the lambda expression&apos;s body.
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">val</span>&nbsp;(String&nbsp;s)=&gt;String&nbsp;function&nbsp;=&nbsp;[&nbsp;toUpperCase&nbsp;]&nbsp;<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;[it&nbsp;| it.toUpperCase]</span>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Lambda_17"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode">[&nbsp;|&nbsp;<span class="string">"foo"</span>&nbsp;]&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;lambda&nbsp;expression&nbsp;without&nbsp;parameters</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.toUpperCase()&nbsp;]&nbsp;<span class="comment">//&nbsp;explicit&nbsp;argument&nbsp;type</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;a,&nbsp;b,&nbsp;c&nbsp;|&nbsp;a+b+c&nbsp;]&nbsp;<span class="comment">//&nbsp;inferred&nbsp;argument&nbsp;types</span></span>
	</li>
</ul>
</p>
<a name="Xbase_lambda_self"></a>
<h5>Refering the current function</h5>
<p>
If a lambda expressions implements an abstract SAM type that offers additional methods, those can be
accessed on the receiver <span class="inlinecode"><span class="keyword">self</span></span>:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">val</span>&nbsp;AbstractIterator&lt;String&gt;&nbsp;emptyIterator&nbsp;=&nbsp;[<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">self</span>.endOfData<br/>
]
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_IfExpression"></a>
<h4>If Expression</h4>
<p>
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java&apos;s if statement it behaves  
like Java&apos;s ternary operator (<span class="inlinecode">predicate&nbsp;?&nbsp;thenPart&nbsp;:&nbsp;elsePart</span>), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within other expressions.
</p>
<p>
An expression <span class="inlinecode"><span class="keyword">if</span>&nbsp;(p)&nbsp;e1&nbsp;<span class="keyword">else</span>&nbsp;e2</span> results in either the value <span class="inlinecode">e1</span> or <span class="inlinecode">e2</span> depending on whether the predicate <span class="inlinecode">p</span> 
evaluates to <span class="inlinecode"><span class="keyword">true</span></span> or <span class="inlinecode"><span class="keyword">false</span></span>. The else part is optional which is a shorthand for a default value, e.g <span class="inlinecode"><span class="keyword">else</span>&nbsp;<span class="keyword">null</span></span>
if the type of the <span class="inlinecode"><span class="keyword">if</span></span> expression is a reference type. If the type is a primitive type, its default
value is assumed accordingly, e.g. <span class="inlinecode"><span class="keyword">else</span>&nbsp;<span class="keyword">false</span></span> for <span class="inlinecode"><span class="keyword">boolean</span></span> or <span class="inlinecode"><span class="keyword">else</span>&nbsp;1</span> for numbers. 
</p>
<p>
That means 
</p>
<p>
<span class="inlinecode"><span class="keyword">if</span>&nbsp;(foo)&nbsp;x</span>
</p>
<p>
is the a short hand for
</p>
<p>
<span class="inlinecode"><span class="keyword">if</span>&nbsp;(foo)&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">null</span></span>
</p>
<a name="Xbase_Expressions_IfTypeInference"></a>
<h5>Typing</h5>
<p>
The type of an <span class="inlinecode"><span class="keyword">if</span></span> expression is calculated from the types <span class="inlinecode">T1</span> and <span class="inlinecode">T2</span> of the two expression <span class="inlinecode">e1</span> and <span class="inlinecode">e2</span>.
It uses the rules defined in <a href="199-xtext-and-java.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;" >section Xbase_Types_CommonSuperType</a>, if an explicit <span class="inlinecode"><span class="keyword">else</span></span> branch is given. If it is ommitted,
the type of the <span class="inlinecode"><span class="keyword">if</span></span> expression is the type <span class="inlinecode">T</span> of the expression <span class="inlinecode">e</span> of the form <span class="inlinecode"><span class="keyword">if</span>&nbsp;(b)&nbsp;e</span>.
</p>
<a name="Xbase_Expressions_IfExpression_8"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span>&nbsp;<span class="keyword">else</span>&nbsp;that</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;{&nbsp;<span class="keyword">this</span>&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(thatFoo)&nbsp;{&nbsp;that&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;other&nbsp;}</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_SwitchExpression"></a>
<h4>Switch Expression</h4>
<p>
The switch expression is a bit different from Java&apos;s, as the use of switch is not limited to certain values but can be used for any object reference instead.
 
For a switch expression 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;e&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e1&nbsp;:&nbsp;er1<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e2&nbsp;:&nbsp;er2<br/>
&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;en&nbsp;:&nbsp;ern<br/>
&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;er<br/>
}
</p>
</div>
</div>
</p>
<p>
the main expression <span class="inlinecode">e</span> is evaluated first and then each case sequentially. If the switch expression
contains a variable declaration using the syntax known from <a href="199-xtext-and-java.html#Xbase_Expressions_ForLoop" title="Go to &quot;For Loop&quot;">for loops</a>, the value is bound to the given name.
Expressions of type <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Boolean.html" title="View JavaDoc"><abbr title="java.lang.Boolean" >Boolean</abbr></a> or <span class="inlinecode"><span class="keyword">boolean</span></span> are not allowed in a switch expression.
</p>
<p>
The guard of each case clause is evaluated until the switch value equals the result of the case&apos;s guard expression or if the case&apos;s guard
expression evaluates to <span class="inlinecode"><span class="keyword">true</span></span>.
Then the right hand expression of the case evaluated and the result is returned.
</p>
<p>
If none of the guards matches the default expression is evaluated and returned. If no default expression
is specified the expression evaluates to the default value of the common type of all available case expressions. 
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;myString&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;myString.length&gt;5&nbsp;:&nbsp;<span class="string">&apos;a&nbsp;long&nbsp;string.&apos;</span><br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;:&nbsp;<span class="string">"It&apos;s&nbsp;a&nbsp;foo."</span><br/>
&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;<span class="string">"It&apos;s&nbsp;a&nbsp;short&nbsp;non-foo&nbsp;string."</span><br/>
}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_SwitchExpression_7"></a>
<h5>Type guards</h5>
<p>
In addition to the case guards one can add a so called <em>Type Guard</em> which is syntactically just a <a href="199-xtext-and-java.html#Xbase_Types_TypeReferences" title="Go to &quot;Simple Type References&quot;">type reference</a> preceding
the than optional case keyword. The compiler will use that type for the switch expression in subsequent expressions.
Example:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">var</span>&nbsp;Object&nbsp;x&nbsp;=&nbsp;...;<br/>
<span class="keyword">switch</span>&nbsp;x&nbsp;{<br/>
&nbsp;&nbsp;String&nbsp;<span class="keyword">case</span>&nbsp;x.length()&gt;0&nbsp;:&nbsp;x.length()<br/>
&nbsp;&nbsp;List&lt;?&gt;&nbsp;:&nbsp;x.size()<br/>
&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;-1<br/>
}
</p>
</div>
</div>
</p>
<p>
Only if the switch value passes a type guard, i.e. an <span class="inlinecode"><span class="keyword">instanceof</span></span> test succeeds, the case&apos;s guard expression is executed
using the same semantics as explained above. 
If the switch expression contains an explicit declaration of a local variable or the expression references a local variable,
the type guard works like an automated cast. All subsequent references to the switch value will be of the type specified in the type guard,
unless it is reassigned to a new value.
</p>
<a name="Xbase_Expressions_SwitchExpression_8"></a>
<h5>Fall Through</h5>
<p>
One can have multiple <em>type guards</em> and <em>cases</em> separated with a comma, to have all of them share the same <em>then-expression</em>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">def</span>&nbsp;isMale(String&nbsp;salutation)&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">switch</span>&nbsp;salutation&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">"Mr."</span>,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">"Sir"</span>&nbsp;:&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;false<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_SwitchExpression_9"></a>
<h5>Typing</h5>
<p>
The type of a switch expression is computed using the rules defined in the
section on <a href="199-xtext-and-java.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;">common super types</a>. The set of types from which the common 
super type is computed corresponds to the types of each case expression.
</p>
<a name="Xbase_Expressions_SwitchExpression_10"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		
		    <div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;foo&nbsp;{<br/>
		&nbsp;&nbsp;Entity&nbsp;:&nbsp;foo.superType.name<br/>
		&nbsp;&nbsp;Datatype&nbsp;:&nbsp;foo.name<br/>
		&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalStateException<br/>
		}
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
		    <div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;x&nbsp;:&nbsp;foo.bar.complicated(<span class="string">&apos;hello&apos;</span>,&nbsp;42)&nbsp;{<br/>
		&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">"hello42"</span>&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;x.length&lt;2&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;...<br/>
		}
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xbase_Expressions_VariableDeclaration"></a>
<h4>Variable Declarations</h4>
<p>
Variable declarations are only allowed within <a href="199-xtext-and-java.html#Xbase_Expressions_Blocks" title="Go to &quot;Blocks&quot;">blocks</a>. They are visible in any
subsequent expressions in the block. Generally, overriding or shadowing variables from outer scopes is not allowed.
However, it can be used to overload the <a href="199-xtext-and-java.html#Xbase_Expressions_ImplicitThis" title="Go to &quot;Implicit variables 'this' and 'it'&quot;">implicit variable</a> 
<span class="inlinecode"><span class="keyword">it</span></span>, in order to subsequently access an object&apos;s features in an unqualified manner.
</p>
<p>
A variable declaration starting with the keyword <span class="inlinecode"><span class="keyword">val</span></span> denotes an unchangeable value, which is essentially 
a final variable. In rare cases, one needs to update the value of a reference. In such situations
the variable needs to be declared with the keyword <span class="inlinecode"><span class="keyword">var</span></span>, which stands for variable.
</p>
<p>
A typical example for using <span class="inlinecode"><span class="keyword">var</span></span> is a counter in a loop. 
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;max&nbsp;=&nbsp;100<br/>
&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;i&nbsp;=&nbsp;0<br/>
&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(i&nbsp;&gt;&nbsp;max)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;println(<span class="string">"Hi&nbsp;there!"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+1<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
Variables declared outside a lambda expression using the <span class="inlinecode"><span class="keyword">var</span></span> keyword are not accessible from within a
the lambda expression.
</p>
<a name="Xbase_Expressions_VariableDeclaration_5"></a>
<h5>Typing</h5>
<p>
The type of a variable declaration expression is always <span class="inlinecode"><span class="keyword">void</span></span>. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:
<span class="inlinecode"><span class="keyword">var</span>&nbsp;List&lt;String&gt;&nbsp;msg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;String&gt;();</span>
In such cases, the right hand expression&apos;s type must <a href="199-xtext-and-java.html#Xbase_Types_ConformanceRules" title="Go to &quot;Conformance and Conversion&quot;">conform</a> to the type on the left hand side. 
</p>
<p>
Alternatively the type can be left out and will be inferred from the initialization expression:  
<span class="inlinecode"><span class="keyword">var</span>&nbsp;msg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;String&gt;&nbsp;<span class="comment">//&nbsp;-&gt;&nbsp;type&nbsp;ArrayList&lt;String&gt;</span></span>
</p>
<a name="Xbase_Expressions_Blocks"></a>
<h4>Blocks</h4>
<p>
The block expression allows to have imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The type of a block is also the type of the last expression. Empty blocks return <span class="inlinecode"><span class="keyword">null</span></span>. 
<a href="199-xtext-and-java.html#Xbase_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Variable declarations</a> are only allowed within blocks and cannot be used as a block&apos;s last expression.
</p>
<p>
A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.
</p>
<a name="Xbase_Expressions_Blocks_3"></a>
<h5>Examples</h5>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>)<br/>
&nbsp;&nbsp;result<br/>
}
</p>
</div>
</div>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;x&nbsp;=&nbsp;greeting();<br/>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x.equals(<span class="string">"Hello&nbsp;"</span>))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x+<span class="string">"World!"</span>;&nbsp;<br/>
&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x;<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_ForLoop"></a>
<h4>For Loop</h4>
<p>
The for loop <span class="inlinecode"><span class="keyword">for</span>&nbsp;(T1&nbsp;variable&nbsp;:&nbsp;iterableOfT1)&nbsp;expression</span> is used to execute a certain expression for each element of an
array of an instance of <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html" title="View JavaDoc"><abbr title="java.lang.Iterable" >Iterable</abbr></a>.
The local <span class="inlinecode">variable</span> is final, hence cannot be updated. 
</p>
<p>
The type of a for loop is <span class="inlinecode"><span class="keyword">void</span></span>.
The type of the local variable can optionally be inferred from the type of the array
or the element type of the <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html" title="View JavaDoc"><abbr title="java.lang.Iterable" >Iterable</abbr></a> returned by the iterable expression.
</p>
<p>
<ul>
	<li>
		
		    <div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">for</span>&nbsp;(String&nbsp;s&nbsp;:&nbsp;myStrings)&nbsp;{<br/>
		&nbsp;&nbsp;doSideEffect(s);<br/>
		}
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
		    <div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">for</span>&nbsp;(s&nbsp;:&nbsp;myStrings)<br/>
		&nbsp;&nbsp;doSideEffect(s)
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="xbase_Expressions_BasicForLoop"></a>
<h4>Basic For Loop</h4>
<p>
The traditional for loop is very similar to the one known from Java, or even C. 
</p>
<p>
<span class="inlinecode"><span class="keyword">for</span>&nbsp;(&lt;init-expression&gt;&nbsp;;&nbsp;&nbsp;&lt;predicate&gt;&nbsp;;&nbsp;&lt;update-expression&gt;)&nbsp;body-expression</span> 
</p>
<p>
When executed, it first executes the <span class="inlinecode">init-expression</span>, where local variables can be declared. Next the <span class="inlinecode">predicate</span> is executed and if it evaluates to <span class="inlinecode">true</span>, 
the <span class="inlinecode">body-expression</span> is executed. On any subsequent iterations the <span class="inlinecode">update-expressio</span> is executed instead of the init-expression. 
This happens until the <span class="inlinecode">predicate</span> returns <span class="inlinecode">false</span>.
</p>
<p>
The type of a for loop is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">for</span>&nbsp;(<span class="keyword">val</span>&nbsp;i&nbsp;=&nbsp;0&nbsp;;&nbsp;i&nbsp;&lt;&nbsp;s.length&nbsp;;&nbsp;i++)&nbsp;{<br/>
&nbsp;&nbsp;println(s.subString(0,i)<br/>
}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_WhileExpression"></a>
<h4>While Loop</h4>
<p>
A while loop <span class="inlinecode"><span class="keyword">while</span>&nbsp;(predicate)&nbsp;expression</span> is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The type of a while loop is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<a name="Xbase_Expressions_WhileExpression_2"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">while</span>&nbsp;(<span class="keyword">true</span>)&nbsp;{<br/>
		&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}
		</p>
		</div>
		</div>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">while</span>&nbsp;(&nbsp;(&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;&nbsp;max&nbsp;)&nbsp;<br/>
		&nbsp;&nbsp;doSideEffect(&nbsp;<span class="string">"foo"</span>&nbsp;)
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_DoWhileExpression"></a>
<h4>Do-While Loop</h4>
<p>
A do-while loop <span class="inlinecode"><span class="keyword">do</span>&nbsp;expression&nbsp;<span class="keyword">while</span>&nbsp;(predicate)</span> is used to execute a certain expression until the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The difference to the <a href="199-xtext-and-java.html#Xbase_Expressions_WhileExpression" title="Go to &quot;While Loop&quot;">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
The type of a do-while loop is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<a name="Xbase_Expressions_DoWhileExpression_2"></a>
<h5>Examples</h5>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">do</span>&nbsp;{<br/>
		&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}&nbsp;<span class="keyword">while</span>&nbsp;(<span class="keyword">true</span>)
		</p>
		</div>
		</div>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">do</span>&nbsp;doSideEffect(<span class="string">"foo"</span>)&nbsp;<span class="keyword">while</span>&nbsp;((i=i+1)&lt;max)</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Return"></a>
<h4>Return Expression</h4>
<p>
Although an explicit return is often not necessary, it is supported.
In a lambda expression for instance a return expression is always implied if the expression itself is not of type
<span class="inlinecode"><span class="keyword">void</span></span>. Anyway you can make it explicit:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
listOfStrings.map&nbsp;[&nbsp;e&nbsp;|<br/>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(e==<span class="keyword">null</span>)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"NULL"</span><br/>
&nbsp;&nbsp;e.toUpperCase<br/>
]
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Throw"></a>
<h4>Throwing Exceptions</h4>
<p>
It is possible to throw <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Throwable.html" title="View JavaDoc"><abbr title="java.lang.Throwable" >Throwable</abbr></a>. The syntax is exactly the same as in Java.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(myList.isEmpty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<span class="string">"the&nbsp;list&nbsp;must&nbsp;not&nbsp;be&nbsp;empty"</span>)<br/>
&nbsp;&nbsp;...<br/>
}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_TryCatch"></a>
<h4>Try, Catch, Finally</h4>
<p>
The try-catch-finally expression is used to handle exceptional situations.
You are not forced to declare checked exceptions. If you don&apos;t catch checked exceptions, they are thrown in a way the compiler
does not complain about a missing throws clause, using the sneaky-throw technique introduced by 
<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">try</span>&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;RuntimeException()<br/>
}&nbsp;<span class="keyword">catch</span>&nbsp;(NullPointerException&nbsp;e)&nbsp;{<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;handle&nbsp;e<br/>
</span>}&nbsp;<span class="keyword">finally</span>&nbsp;{<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;do&nbsp;stuff<br/>
</span>}
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Synchronized"></a>
<h4>Synchronized</h4>
<p>
The synchonized expression does the same as it does in Java (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19">Java Language Specification</a>).
The only difference is that in Xtend it is an expression and can therefore be used at more places.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">synchronized</span>(lock)&nbsp;{<br/>
&nbsp;&nbsp;println(<span class="string">"Hello"</span>)<br/>
}
</p>
</div>
</div>
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">val</span>&nbsp;name&nbsp;=&nbsp;<span class="keyword">synchronized</span>(lock)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;doStuff()&nbsp;<br/>
}
</p>
</div>
</div>

</p>
<a name="xbaseLanguageRef_LibraryExtension"></a>
<h3>Extension Methods</h3>
<p>
Languages extending Xbase might want to contribute to the feature scope. Besides that, one can of course
change the whole implementation as it seems fit. There is a special hook, which can be used to add 
so-called extension methods to existing types. 
</p>
<p>
Xbase itself comes with a standard library of such extension methods adding support for various operators
for the common types, such as <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html" title="View JavaDoc"><abbr title="java.lang.String" >String</abbr></a>, <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html" title="View JavaDoc"><abbr title="java.util.List" >List</abbr></a>, etc.
</p>
<p>
These extension methods are declared in separate Java classes. There are various ways how extension methods
can be added. In the simplest case the language designer predefines which extension methods are available.
Language users cannot add additional library functions using this mechanism.
</p>
<p>
Another alternative is to have them looked up by a certain naming convention. Also for more general languages
it is possible to let users add extension methods using imports or similar mechanisms. This approach can be seen in the
language <a href="http://www.xtend-lang.org">Xtend</a>, where extension methods are lexically imported through static
imports and/or dependency injection.
</p>
<p>
The precedence of extension methods is always lower than real member methods, i.e. you cannot override
member features. Also the extension members are not invoked polymorphic. If you have two extension methods
on the scope (<span class="inlinecode">foo(Object)</span> and <span class="inlinecode">foo(String)</span>) the expression <span class="inlinecode">(foo&nbsp;<span class="keyword">as</span>&nbsp;Object).foo</span> would
bind and invoke <span class="inlinecode">foo(Object)</span>.
</p>
<a name="xbaseLanguageRef_LibraryExtension_6"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">foo</span>
	</li>
	<li>
		<span class="inlinecode">my.foo</span>
	</li>
	<li>
		<span class="inlinecode">my.foo(x)</span>
	</li>
	<li>
		<span class="inlinecode">oh.my.foo(bar)</span>
	</li>
</ul>
</p>
<a name="XbaseLanguageRef_builderSyntax"></a>
<h4>Builder Syntax</h4>
<p>
If the last argument of a method call is a lambda expression, it can be appended to the method call. Thus,
</p>
<p>
<span class="inlinecode">foo(42)&nbsp;[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.toUpperCase&nbsp;]</span>
</p>
<p>
will call a Java method with the signature
</p>
<p>
<span class="inlinecode"><span class="keyword">void</span>&nbsp;foo(<span class="keyword">int</span>,&nbsp;Function1&lt;String,&nbsp;String&gt;)</span> 
</p>
<p>
Used in combination with the <a href="199-xtext-and-java.html#Xbase_Expressions_implicit_parameter" title="Go to &quot;Implicit Parameter it&quot;">implicit parameter name in lambda
expressions</a>
you can write <a href="199-xtext-and-java.html#xbaseLanguageRef_LibraryExtension" title="Go to &quot;Extension Methods&quot;">extension libraries</a> to create and initialize graphs of
objects in a concise builder syntax like in Groovy. Consider you have a set of library methods 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
HtmlNode&nbsp;html(Function1&lt;HtmlNode,&nbsp;Void&gt;&nbsp;initializer)<br/>
HeadNode&nbsp;head(HtmlNode&nbsp;parent,&nbsp;Function1&lt;HeadNode,&nbsp;Void&gt;&nbsp;initializer)<br/>
...
</p>
</div>
</div>
</p>
<p>
that create DOM elements for HTML pages inside their respective parent elements. You can then create a DOM
using the following Xbase code:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
html([&nbsp;html&nbsp;| <br/>
&nbsp;&nbsp;head(html,&nbsp;[&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;initialize&nbsp;head<br/>
</span>&nbsp;&nbsp;])&nbsp;<br/>
]&nbsp;)
</p>
</div>
</div>
</p>
<p>
Appending the lambda expression parameters and prepending the parent parameters using extension syntax yields
<div class="literallayout">
<div class="incode">
<p class="code">
html()&nbsp;[&nbsp;html&nbsp;| <br/>
&nbsp;&nbsp;html.head()&nbsp;[&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;initialize&nbsp;head<br/>
</span>&nbsp;&nbsp;]&nbsp;&nbsp;<br/>
]
</p>
</div>
</div>
</p>
<p>
Using implicit parameter <span class="inlinecode"><span class="keyword">it</span></span> and skipping empty parentheses you can simplify this to 
<div class="literallayout">
<div class="incode">
<p class="code">
html&nbsp;[&nbsp;<br/>
&nbsp;&nbsp;head&nbsp;[&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;initialize&nbsp;head<br/>
</span>&nbsp;&nbsp;]&nbsp;&nbsp;<br/>
]
</p>
</div>
</div>

</p>
</body>
</html>
