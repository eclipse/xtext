<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Getting Started</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="getting_started"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Getting Started</h1>

<p>
In this mini-tutorial we will implement a small domain-specific language and a 
corresponding Eclipse IDE integration with Xtext. Later, we will create a code generator 
that is capable of reading the models you create with the DSL editor and process them, i.e. 
generate some Java code from it.
</p>


<a name="getting_started_xtext"></a>

<a name="getting_started_xtext"></a>
<div class="section" title="Creating a DSL">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Creating a DSL
</h2>
</div>
</div>
</div>



<p>
<a href="http://www.eclipse.org/Xtext/download/">Download and install the latest version of Xtext</a> and 
set up a fresh workspace. We want to develop a small language used to define domain models.
It is a stripped-down version of our <em>Domain-Model Example</em> which is shipped with Xtext 
and can be materialized into your workspace using the example wizard. The following sample 
of a domain model should give you an idea about the language.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">datatype</span>&nbsp;String<br /><span class="keyword">datatype</span>&nbsp;Bool<br /><br /><span class="keyword">entity</span>&nbsp;Session&nbsp;{<br />&nbsp;&nbsp;title:&nbsp;String<br />&nbsp;&nbsp;isTutorial&nbsp;:&nbsp;Bool<br />}<br /><br /><span class="keyword">entity</span>&nbsp;Conference&nbsp;{<br />&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />&nbsp;&nbsp;attendees&nbsp;:&nbsp;Person*<br />&nbsp;&nbsp;speakers&nbsp;:&nbsp;Speaker*<br />}<br /><br /><span class="keyword">entity</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />}<br /><br /><span class="keyword">entity</span>&nbsp;Speaker&nbsp;<span class="keyword">extends</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;sessions&nbsp;:&nbsp;Session*<br />}<br />
</p>
</div>
</div>


</p>




<a name="getting_started_xtext-3"></a>
<div class="section" title="Create an Xtext Project">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Create an Xtext Project
</h3>
</div>
</div>
</div>



<p>
In order to get started we first need to create some Eclipse projects. Use the Xtext wizard to do so:
</p>

<p>
<em>File -&gt; New -&gt; Project...  -&gt; Xtext -&gt; Xtext project</em>
</p>

<p>
Choose a meaningful project name, language name and file extension, e.g.
</p>

<p>


</p>

<p>
Keep &quot;Create generator project&quot; checked, as we will also create a code generator in a second step.
If you want to materialize the full blown Domainmodel example that ships with Xtext, it is
strongly recommend to use another language name and file extension for this tutorial.
</p>

<p>
Click on <em>Finish</em> to create the projects. 
</p>

<p>
<div class="image" >
<img src="images/getting-started-wizard.png" class=" " />
 
</div>
</p>


</div>



<a name="getting_started_xtext-4"></a>
<div class="section" title="Project Layout">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Project Layout
</h3>
</div>
</div>
</div>



<p>
In the Package Explorer you can see three new projects. In 
<em>org.eclipse.xtext.example.domainmodel</em> the grammar is defined and all runtime 
aspects, such as linking, scoping and validation are developed. The IDE-aspects 
such as the editor, any views, and incremental project builder go into 
<em>org.eclipse.xtext.example.domainmodel.ui</em>. Both projects consist of generated 
classes derived from the grammar and manual code such as the grammar itself and 
further classes to differentiate and adapt from the default behavior. Although
Xtext makes use of code generation, most of the code is actually written as 
libraries, which are referenced by the means of OSGi using the Manifest.MF. 
</p>

<p>
<div class="image" >
<img src="images/getting-started-project-layout.png" class=" " />
 
</div>
</p>

<p>
It is good to be clear and unambiguous whether the code is generated or is to 
be manipulated by the developer. Thus, the generated code should be held 
separately from the manually written code. We follow this pattern by having a 
folder <em>src/</em> and a folder <em>src-gen/</em> in each project. Keep in mind not to 
make changes in the <em>src-gen/</em> folder. They will be overwritten by the generator 
without any further warning.
</p>

<p>
A third project, <em>org.eclipse.xtext.example.domainmodel.generator</em> will later 
contain an Xpand code generator that leverages the model created with the DSL 
editor. This is fully optional and it is also optional to use Xpand. In fact 
you can use any programming language running on the JVM to implement a code 
generator for your Xtext models. Also it is of course perfectly ok, to have no 
code generator at all but use the models dynamically at runtime. We call these 
kind of model processors <em>interpreters</em>.
</p>


</div>



<a name="getting_started_xtext-5"></a>
<div class="section" title="Build Your Own Grammar">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Build Your Own Grammar
</h3>
</div>
</div>
</div>



<p>
<em>_Please note_</em>: If you encounter strange errors while copying and pasting
a snippet from this document to your Eclipse editor, your documentation
viewer most likely has inserted characters different from {space} into your 
clipboard. Reenter the &quot;whitespace&quot; or type the text by hand to be sure everything
works fine. 
</p>

<p>
The wizard will automatically open the example grammar file 
<em>Domainmodel.xtext</em> from the first project in the editor. A grammar has two 
purposes: First, it is used to describe the concrete syntax of your language. 
Second, it contains information about how the parser shall create a model during 
parsing.
</p>

<p>
The first line of the grammar is the grammar declaration:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<br />&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br />
</p>
</div>
</div>


</p>

<p>
In Xtext each grammar has a unique name, which like public Java classes 
needs to reflect the location of the file within the Java classpath. In our 
case the grammar file is located in 
<em>/org/eclipse/xtext/example/Domainmodel.xtext</em> therefore the name of the 
grammar is <em>org.eclipse.xtext.example.Domainmodel</em>. The second part of that 
statement (_with org.eclipse.xtext.common.Terminals_) states, that this grammar 
reuses and overrides rules from the specified grammar. The 
<em>org.eclipse.xtext.common.Terminals</em> is a library grammar shipped with Xtext 
and predefines the most common terminal rules, such as <em>ID</em>, <em>STRING</em> and <em>INT</em>. 
It also introduces single-line and multi-line comments as well as rules for 
whitespace, which may occur everywhere by default. You can open that grammar in the 
editor to have a look at these rules. It turns out that these set of rules are often 
the same and often used, so that most Xtext languages extend this grammar. 
However, it is just a library, so you won&apos;t use it if it doesn&apos;t fit your needs. 
Also you can use the grammar inheritance mechanism for your own grammar libraries, 
of course.
</p>

<p>
The next statement declares an EMF Ecore package, aka <em>EPackage</em>, to be derived from the grammar:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">generate</span>&nbsp;domainmodel&nbsp;&quot;http://www.eclipse.org/xtext/example/Domainmodel&quot;<br />
</p>
</div>
</div>


</p>

<p>
Ecore <em>EPackages</em> are effectively a set of classes (in EMF they are called 
<em>EClass</em>) which are used to represent the in-memory-model of a text file. Instead
of <em>model</em> we also sometimes refer to it as <em>semantic model</em> or _Abstract Syntax 
Tree (AST)_. Note, that in the case of Xtext it&apos;s actually a graph rather than a 
tree, since it also contains crosslinks. But as the term AST is so commonly 
used and well known we are ignoring this minor detail. 
</p>

<p>
In order to tell the parser which <em>EClasses</em> to use when creating the AST, we 
need to make them available by either importing existing Ecore packages or like 
in our example let Xtext derive a package from the grammar. An <em>EPackage</em> has a 
mandatory name and namespace URI (short: <em>nsURI</em>), so we have to declare these two values 
in that statement. 
</p>

<p>
That&apos;s all for the prelude, now we have to define the parser rules which 
effectively define a bi-directional mapping from text to a constructed AST. 
It is bi-directional because Xtext not only derives a parser from the grammar but also 
a serializer. Anyway, we will mostly talk about parsing in this chapter.
</p>

<p>
Ignore and delete the parser rules generated by the wizard and start by 
declaring an entry rule for our language. The entry rule for the parser will be 
called <em>DomainModel</em>. Xtext is fine with any name, it just picks the first rule 
in a grammar and interprets it as the entry rule.
</p>

<p>
As a <em>DomainModel</em> consists of one or more <em>Entity</em> entries, this rule delegates 
to another rule named <em>Entity</em>, which will be defined later on. As we can have an 
arbitrary number of entities within a model, the cardinality is &apos;_*_&apos;. There are 
four different cardinalities available.
</p>

<p>


</p>

<p>
Each rule ends with a semicolon. So our first rule reads for now as
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;:<br />&nbsp;&nbsp;Entity*;&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
An Xtext grammar does not only describe rules for the parser but also the 
structure of the resulting AST. Usually, each parser rule will create a new object 
in that tree. The type of that element can be specified after the rule name using 
the keyword <em>returns</em>. If the type&apos;s name is the same as the rule&apos;s name, it can 
be omitted as in our case. Which effectively means that
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;<span class="keyword">returns</span>&nbsp;DomainModel:&nbsp;...<br />
</p>
</div>
</div>


</p>

<p>
is the same as
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;:&nbsp;...<br />
</p>
</div>
</div>


</p>

<p>
In order to connect the different objects together, we have to assign the 
elements returned by called rules to some feature of the current rule&apos;s object. 
This is done by using so called assignments. 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;:<br />&nbsp;&nbsp;(elements+=Entity)*;<br />
</p>
</div>
</div>


</p>

<p>
The assignment with the &apos;_+=_&apos; operator adds every object returned by the 
<em>Entity</em> rule to the <em>elements</em> referenced of the AST type <em>Model</em>. If you use &apos;_+=_&apos; 
as opposed to &apos;_=_&apos; the feature needs to be a list - the upperBound has to be -1. In addition to the 
two mentioned assignment operators there is a third one &apos;_?=_&apos; which is called boolean 
assignment and which sets a certain feature to true, if the part on the right hand 
side was parsed successfully. Here&apos;s the list of available assignment operators:
</p>

<p>


</p>

<p>
The next rule on our list is the rule <em>Entity</em>. Looking at our target syntax, 
each entity begins with the keyword <em>&apos;entity&apos;</em> followed by the entity&apos;s name and an 
opening curly brace (we will handle the <em>extends</em> clause in a second step). Then, 
an entity defines a number of features and ends with a closing curly brace. The 
rule looks like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Entity&nbsp;:<br />&nbsp;&nbsp;&apos;entity&apos;&nbsp;name=ID&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(features+=Feature)*<br />&nbsp;&nbsp;&apos;}&apos;;<br />&nbsp;&nbsp;
</p>
</div>
</div>


</p>

<p>
Keywords are simply declared as string literals within the rules. The name 
uses the <em>ID</em> rule from the mixed-in grammar <em>org.eclipse.xtext.common.Terminals</em>. 
The <em>ID</em> rule is a so called terminal rule which always returns simple data types, 
such as <em>String</em>, <em>Date</em>, or <em>Integer</em>. Actually any Java class can be a simple 
EMF <em>EDataType</em>. The <em>ID</em> rule recognizes alphanumeric words similar to identifiers 
in Java and returns the value as a <em>String</em>. You can navigate to its declaration 
using <em>F3</em>. As mentioned before the assignment operator &apos;_=_&apos; denotes a single
valued feature.
</p>

<p>
We want to allow inheritance for entities and therefore now add an optional 
&apos;_extends_&apos; part.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Entity&nbsp;:<br />&nbsp;&nbsp;&apos;entity&apos;&nbsp;name=ID&nbsp;(&apos;extends&apos;&nbsp;superType=[Entity])?&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(features+=Feature)*<br />&nbsp;&nbsp;&apos;}&apos;;<br />
</p>
</div>
</div>


</p>

<p>
The question mark marks an element or as in this case an entire group of elements as optional.
The other new thing is the right hand side of of the assignment <em>superType=[Entity]</em>.
This is a cross-reference literal and states, that a cross-reference to an elsewhere 
declared <em>Entity</em> should be established. So in this case <em>Entity</em> does not point to 
the corresponding rule but to the <em>EClass</em>. As both are named equally this might 
cause a little confusion at first. The full syntax for a cross-reference is 
<em>[TypeName|RuleCall]</em> where <em>RuleCall</em> defaults to <em>ID</em>. This means that 
<em>(&apos;extends&apos; superType=[Entity|ID])?</em> would work equally well. The parser only parses 
the name of the cross-referenced element using the <em>ID</em> rule and stores it 
internally. Later on the linker establishes the cross-reference using the name, the 
defined cross-reference&apos;s type (_Entity_ in this case) and the defined scoping rules. 
Scoping is not covered in this tutorial since the domain model DSL works with 
the default scoping semantics. By default a namespace-based scoping is applied, which 
means that all entities living in the same namespace are possible candidates for a 
cross-reference. We talk a bit about this later on in this chapter when we introduce 
namespaces.
</p>

<p>
In our introductory example model we had not only defined entities but also two 
data types. So the <em>DomainModel</em> rule needs to be able to parse data types as well. 
As both entities and data types will be referenced from the yet to be defined <em>Feature</em> 
rule, we should introduce a common super type for them.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;:<br />&nbsp;&nbsp;(elements+=Type)*;<br /><br />Type:<br />&nbsp;&nbsp;DataType&nbsp;|&nbsp;Entity;<br />&nbsp;&nbsp;<br />DataType:<br />&nbsp;&nbsp;&apos;datatype&apos;&nbsp;name=ID;<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
A <em>DomainModel</em> now consists of types where a <em>Type</em> can either be a <em>DataType</em> or 
an <em>Entity</em>. Our rule <em>Type</em> will just delegate to either of them, using the &apos;_|_&apos; 
alternatives operator. Now that we have a common super type for <em>Entity</em> and <em>DataType</em> 
we are able to refer to both types of elements with a single cross-reference.
</p>

<p>
Next up we need to define the syntax of <em>Feature</em>, which shouldn&apos;t be surprising to 
you, as we do not use any new concepts here.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Feature:<br />&nbsp;&nbsp;name=ID&nbsp;&apos;:&apos;&nbsp;type=TypeRef;<br />
</p>
</div>
</div>


</p>

<p>
In many target platforms there is a difference between the notion of a simple 
attribute and a reference. In relational databases, for instance, a table contains 
the values of attributes directly, but references are &quot;modeled&quot; by the means of 
foreign keys. In object-relational persistence technologies such as JPA or Hibernate 
references can have additional life-cycle semantics, which define what to do with 
referenced objects in certain circumstances. Therefore you typically make a distinction 
between the two concepts, as we do in the <em>Domain Model Example</em> you can create using 
the wizard. However, in this small scenario we do not need a separation therefore we 
stick with one single concept for features.
</p>

<p>
As the type reference has an additional property for the multiplicity (many or one), 
we make it a separate model element and parser rule <em>TypeRef</em>. The presence of the 
postfix &apos;*&apos; in an input file should set the boolean flag to &apos;true&apos; that indicates a multi-value
type reference in the AST model. 
This is the purpose of the assignment operator &apos;_?=_&apos;. The parser rule looks like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
TypeRef&nbsp;:<br />&nbsp;&nbsp;referenced=[Type]&nbsp;(multi?=&apos;*&apos;)?;<br />
</p>
</div>
</div>


</p>

<p>
Again we have specified a cross-reference, which this time not only allows to 
reference entities but all instances of type. So far this only includes data type and entities, but 
you may want to introduce additional concepts in a future version, like for instance a 
Value Object as proposed in Eric Evan&apos;s great book <em>Domain Driven Design</em>.
</p>

<p>
In the end your grammar editor should look like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<br />&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br />&nbsp;&nbsp;<br /><span class="keyword">generate</span>&nbsp;domainmodel&nbsp;&quot;http://www.eclipse.org/xtext/example/Domainmodel&quot;&nbsp;&nbsp;<br /><br />DomainModel&nbsp;:<br />&nbsp;&nbsp;(elements+=Type)*;<br />&nbsp;&nbsp;<br />Type:<br />&nbsp;&nbsp;DataType&nbsp;|&nbsp;Entity;<br />&nbsp;&nbsp;<br />DataType:<br />&nbsp;&nbsp;&apos;datatype&apos;&nbsp;name=ID;<br />&nbsp;<br />Entity:<br />&nbsp;&nbsp;&apos;entity&apos;&nbsp;name=ID&nbsp;(&apos;extends&apos;&nbsp;superType=[Entity])?&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(features+=Feature)*<br />&nbsp;&nbsp;&apos;}&apos;;<br />&nbsp;<br />Feature:<br />&nbsp;&nbsp;name=ID&nbsp;&apos;:&apos;&nbsp;type=TypeRef;<br />&nbsp;&nbsp;<br />TypeRef:<br />&nbsp;&nbsp;referenced=[Type]&nbsp;(multi?=&apos;*&apos;)?;<br />&nbsp;&nbsp;
</p>
</div>
</div>


</p>


</div>



<a name="getting_started_xtext-6"></a>
<div class="section" title="Generate Language Artifacts">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Generate Language Artifacts
</h3>
</div>
</div>
</div>



<p>
Now that we have the grammar in place and defined we need to run the generator that will derive the
various language components. 
To do so locate the file <em>GenerateDomainmodel.mwe2</em> file next to the grammar 
file in the package explorer view. From its context menu, choose
</p>

<p>
<em>Run As -&gt; MWE2 Workflow</em>.
</p>

<p>
That will trigger the Xtext language generator. It generates the parser and 
serializer and some additional infrastructure code. You will see its logging 
messages in the Console View. 
</p>


</div>



<a name="getting_started_xtext-7"></a>
<div class="section" title="Run the Generated IDE Plug-in">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Run the Generated IDE Plug-in
</h3>
</div>
</div>
</div>



<p>
If the code generation succeeded, we are now able to test the IDE integration. 
Right-click on the Xtext project and choose
</p>

<p>
<em>Run As -&gt; Eclipse Application</em>.
</p>

<p>
This will spawn a new Eclipse workbench with your projects as plug-ins installed. 
In the new workbench, create a new project 
(_File -&gt; New -&gt; Project...  -&gt; General -&gt; Project_) and therein a new file 
with the file extension you chose in the beginning (_*.dmodel_). This will open
the generated entity editor. Try it a bit and discover the default 
functionality for code completion (_CTRL SPACE_ even for cross-references), 
syntax highlighting, syntactic validation, linking errors, outline, find
references etc.
</p>

<p>
<div class="image" >
<img src="images/getting-started-editor.png" class=" width:50%" />
 
</div>
</p>


</div>



<a name="getting_started_xtext-8"></a>
<div class="section" title="Adding a Namespace Concept">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Adding a Namespace Concept
</h3>
</div>
</div>
</div>



<p>
At the current stage, our language puts all types into the same scope. As 
cross-references are specified by means of names, this can easily yield collisions 
as the model size increases. Avoiding such name clashes is why most programming 
languages invent concepts like namespaces or modules. We will now introduce the 
concept of a <em>Package</em>, which effectively is a namespace. 
</p>

<p>
Our languages&apos;s definition of a <em>Package</em> is as follows: A package has a name and 
contains other named elements and namespace-imports. A named element is either another 
<em>Package</em> or a <em>Type</em>. Within a package, elements must have unique names. The 
<em>fully qualified name</em> (FQN) of a named element consists of the FQN of its package, 
a separator &apos;_._&apos; and its own simple name. Elements refer to each other using their 
<em>qualified names</em> which may be relative to their common namespaces or absolute. By means 
of import statements, these names can be further abbreviated. 
</p>

<p>
That might sound a bit complicated at first but the good thing is that Xtext 
comes with exactly such a default semantic for namespaces, which feels very 
natural in practice. Although all aspects of this semantic are adaptable, we 
will stick to the defaults within this tutorial.
</p>

<p>
Before we extend the grammar, let&apos;s have a look how an example model would
look like when using the newly introduced concepts:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;my.types&nbsp;{<br />&nbsp;&nbsp;<span class="keyword">datatype</span>&nbsp;String<br />&nbsp;&nbsp;<span class="keyword">datatype</span>&nbsp;Boolean<br />}<br /><br /><span class="keyword">package</span>&nbsp;my.entities&nbsp;{<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">import</span>&nbsp;my.types.*<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Session&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;String<br />&nbsp;&nbsp;&nbsp;&nbsp;isTutorial&nbsp;:&nbsp;Boolean<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Conference&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />&nbsp;&nbsp;&nbsp;&nbsp;attendees&nbsp;:&nbsp;Person*<br />&nbsp;&nbsp;&nbsp;&nbsp;speakers&nbsp;:&nbsp;Speaker*<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Speaker&nbsp;<span class="keyword">extends</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;sessions&nbsp;:&nbsp;Session*<br />&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
Let&apos;s start to modify our grammar now. First we introduce the rule <em>AbstractElement</em>:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
AbstractElement:<br />&nbsp;&nbsp;PackageDeclaration&nbsp;|&nbsp;Type;<br />
</p>
</div>
</div>


</p>

<p>
<em>DomainModel</em> should now call <em>AbstractElement</em> instead of <em>Type</em>:  
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel:<br />&nbsp;&nbsp;(elements+=AbstractElement)*;<br />
</p>
</div>
</div>


</p>

<p>
To allow qualified names, we need a new rule <em>QualifiedName</em>. This rule 
returns a string. But we do not want this to be a <em>terminal rule</em>, as terminal 
rules have special semantics (they are used context-less in the lexer, which 
often causes problems). Instead we want it to be a parser rule, but one which
doesn&apos;t return an instance of an <em>EClass</em> from the referenced <em>EPackage</em> but 
just a plain String. Such rules are called <em>data type rules</em>, because they return 
instances of <em>EDataType</em> as opposed to instances of <em>EClass</em>. String is the most 
often used <em>EDataType</em> in this context and is therefore the default return 
type for data type rules. The rule looks like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedName:<br />&nbsp;&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID)*;<br />
</p>
</div>
</div>


</p>

<p>
Note, that Xtext automatically figures out that the rule is a <em>data type rule</em> 
rather then a normal parser rule, because it doesn&apos;t contain any assignments 
and all rule calls go to either other <em>data type rules</em> or <em>terminal rules</em>. 
For a <em>data type rule</em> the parser simply concatenates the consumed text and returns 
it as a string. The transformation to a user defined data type is done by so 
called 
<a href="090-valueconverter.xdoc.html#valueconverter">ValueConverters</a>. But as we use strings we don&apos;t need to care about 
<em>ValueConverters</em> here.
</p>

<p>
Next up we need to define the syntax of <em>PackageDeclarations</em>, which makes use of 
the <em>QualifiedName</em> rule but doesn&apos;t make use of anything we haven&apos;t yet talked about.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
PackageDeclaration:<br />&nbsp;&nbsp;&apos;package&apos;&nbsp;name=QualifiedName&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(elements+=AbstractElement)*<br />&nbsp;&nbsp;&apos;}&apos;;<br />&nbsp;&nbsp;
</p>
</div>
</div>


</p>

<p>
Having qualified names at hand, we want to specify cross-references that 
way, too. As mentioned by default, Xtext assumes the rule <em>ID</em> as the syntax 
for cross-references, which has been fully sufficient so far. But now we want 
to allow fully qualified names as well, so we explicitly specify the syntax rule 
after a delimiter &apos;_|_&apos;:
</p>

<p>
fn.. Note, that the &apos;_|_&apos; has nothing to do with the previously introduced 
alternative operator. In the context of a cross-reference it is simply a delimiter.  
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Entity:<br />&nbsp;&nbsp;&apos;entity&apos;&nbsp;name=ID&nbsp;(&apos;extends&apos;&nbsp;superType=[Entity|QualifiedName])?&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(features+=Feature)*<br />&nbsp;&nbsp;&apos;}&apos;;<br />
</p>
</div>
</div>


</p>

<p>
and
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
TypeRef:<br />&nbsp;&nbsp;referenced=[Type|QualifiedName]&nbsp;(multi?=&apos;*&apos;)?;<br />
</p>
</div>
</div>


</p>

<p>
As the last step, we introduce imports. An <em>Import</em> is an instance of 
<em>AbstractElement</em>, too, so that it can occur as a child of <em>DomainModel</em> as 
well as of <em>PackageDeclaration</em>.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
AbstractElement:<br />&nbsp;&nbsp;PackageDeclaration&nbsp;|&nbsp;Type&nbsp;|&nbsp;Import;<br />
</p>
</div>
</div>


</p>

<p>
An imported namespace is not just a qualified name but it also allows an 
optional wildcard character &apos;_*_&apos; at the end, so that multiple names can be 
imported with one statement. That requires a new data type rule which we 
name <em>QualifiedNameWithWildCard</em>:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedNameWithWildCard:<br />&nbsp;&nbsp;QualifiedName&nbsp;&apos;.*&apos;?;<br />
</p>
</div>
</div>


</p>

<p>
The declaration of the <em>Import</em> rule should look familiar by now:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Import:<br />&nbsp;&nbsp;&apos;<span class="keyword">import</span>&apos;&nbsp;importedNamespace=QualifiedNameWithWildCard;<br />
</p>
</div>
</div>


</p>

<p>
The default scoping implementation is based on naming conventions. First 
everything which has a name is referenceable. By default something has a name 
if it has a property <em>&apos;name&apos;</em>. If such an <em>EAttribute</em> is available, the default 
implementation computes a qualified name by asking the container for its name 
and concatenates the two names separated by a dot. The computation of qualified
names can be arbitrarily changed by implementing an <em>IQualifedNameProvider</em>. 
The other naming convention is that if some element has an EAttribute 
&apos;importedNamespace&apos; that value is used as a namespace import and is automatically 
prefixed to any simple names used within that namespace. Also the asterisk &apos;_*_&apos; 
is used as a wildcard by default.
</p>

<p>
That&apos;s all for the grammar. It should now read as 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<br />&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br /><br /><span class="keyword">generate</span>&nbsp;domainmodel&nbsp;&quot;http://www.eclipse.org/xtext/example/Domainmodel&quot;<br /><br />DomainModel:<br />&nbsp;&nbsp;(elements+=AbstractElement)*;<br /><br />AbstractElement:<br />&nbsp;&nbsp;PackageDeclaration&nbsp;|&nbsp;Type&nbsp;|&nbsp;Import;<br />&nbsp;&nbsp;<br />Import:<br />&nbsp;&nbsp;&apos;<span class="keyword">import</span>&apos;&nbsp;importedNamespace=QualifiedNameWithWildCard;<br /><br />PackageDeclaration:<br />&nbsp;&nbsp;&apos;package&apos;&nbsp;name=QualifiedName&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(elements+=AbstractElement)*<br />&nbsp;&nbsp;&apos;}&apos;;<br /><br />Type:<br />&nbsp;&nbsp;Entity&nbsp;|&nbsp;DataType;<br /><br />DataType:<br />&nbsp;&nbsp;&apos;datatype&apos;&nbsp;name=ID;<br /><br />Entity:<br />&nbsp;&nbsp;&apos;entity&apos;&nbsp;name=ID&nbsp;(&apos;extends&apos;&nbsp;superType=[Entity|QualifiedName])?&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(features+=Feature)*<br />&nbsp;&nbsp;&apos;}&apos;;<br /><br />Feature:<br />&nbsp;&nbsp;name=ID&nbsp;&apos;:&apos;&nbsp;type=TypeRef;<br /><br />TypeRef:<br />&nbsp;&nbsp;referenced=[Type|QualifiedName]&nbsp;(multi?=&apos;*&apos;)?;<br /><br />QualifiedName:<br />&nbsp;&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID)*;<br />&nbsp;&nbsp;<br />QualifiedNameWithWildCard:<br />&nbsp;&nbsp;QualifiedName&nbsp;&apos;.*&apos;?;<br />
</p>
</div>
</div>


</p>

<p>
Now you should regenerate the language infrastructure as described in the 
previous section, and give the editor a try. You can even split up your model 
into smaller parts and have cross-references across file boundaries, as long 
as the referenced models are on the classpath.
</p>


</div>

</div>



<a name="getting_started-3"></a>
<div class="section" title="Processing Xtext Models">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Processing Xtext Models
</h2>
</div>
</div>
</div>



<p>
Now that we know how to create a language we should talk about processing the parsed models somehow. 
There are typically two useful things one can do with
Xtext models: One is translating them to another programming language, i.e. writing a code generator, 
the other is loading them at runtime and use them
dynamically. We&apos;ll talk about code generation later. In this chapter we want to see how to interact with 
Xtext models programmatically. 
</p>

<p>
Text files parsed by Xtext are represented as object graphs in memory. We call these object graphs <em>Abstract Syntax Tree (AST)</em>, <em>semantic model</em> or 
simply <em>model</em> interchangeably. In Xtext models are implemented using the <em>Eclipse Modeling Framework (EMF)</em>, which can be seen as a very powerful version 
of JavaBeans. It not only provides the typical getter and setter methods for the different features of a model element but also comes with an long list of 
advanced concepts and semantics, which are extremely useful in the context of Xtext.
</p>


<a name="resource"></a>

<a name="resource"></a>
<div class="section" title="Loading a Resource">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Loading a <em>Resource</em>
</h3>
</div>
</div>
</div>



<p>
EMF models can be persisted by the means of a so called <em>Resource</em>. Xtext languages implement the <em>Resource</em> interface which is why you can use the EMF API to
load a model into memory (and also save them):
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">new</span>&nbsp;DomainmodelStandaloneSetup().createInjectorAndDoEMFRegistration();<br /><br />ResourceSet&nbsp;rs&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ResourceSetImpl();<br />Resource&nbsp;resource&nbsp;=&nbsp;rs.getResource(URI.createURI(&quot;./mymodel.dmodel&quot;),&nbsp;true);<br />EObject&nbsp;eobject&nbsp;=&nbsp;resource.getContents().get(0);<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
The first line initializes the language infrastructure to run in <em>standalone</em> mode. That is EMF is designed to work in Eclipse and therefore makes use of 
Equinox extension points in order to register factories and the like. In a vanilla Java project there is no Equinox, hence we do the registration programmaticly.
The generated <em>MyLanguageStandaloneSetup</em> class does just that. You don&apos;t have to do this kind of initialization when you run your plug-ins within Eclipse, since in that case 
the extension point declarations are used.
</p>

<p>
The other thing the <em>StandaloneSetup</em> takes care of is creating a Guice <em>injector</em>. The use of Guice and Dependency Injection is explained 
<a href="040-dependency-injection.xdoc.html#dependencyInjection">here</a>. 
</p>

<p>
Now that the language infrastructure is initialized and the different contributions to EMF are registered, we want to load a <em>Resource</em>. To do so we first create a 
<em>ResourceSet</em>, which as the name suggests represents a set of Resources. If one <em>Resource</em> references another <em>Resource</em>, EMF will automatically load that other <em>Resource</em>
into the same <em>ResourceSet</em> as soon as the cross-reference is resolved. Resolution of cross-references is done lazy, i.e. on first access.
</p>

<p>
The 4th line loads the <em>Resource</em> using the resource set. We pass in a URI which points to the file in the file system. 
EMF&apos;s URI is a powerful concept. It supports a lot of different schemes to load resources from file system, web sites, jars, OSGi bundles or even 
from Java&apos;s classpath. And if that is not enough you can come up with your own schemes. Also a URI can not only point to a resource but also to any <em>EObject</em> in a resource.
This is done by appending a so called <em>URI fragment</em> to the URI. 
</p>

<p>
The second parameter denotes whether the resource should automatically be loaded if it wasn&apos;t already before. Alternatively we could have written
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;rs.getResource(URI.createURI(&quot;./mymodel.dmodel&quot;),&nbsp;false);<br />resource.load(null);<br />
</p>
</div>
</div>


</p>

<p>
The load method optionally takes a map of properties, which allows to define a contract between a client and the specific implementation. In Xtext, for instance, we use 
the map to state whether cross-references should be eagerly resolved. In order to find out what properties are supported, it&apos;s usually best to look into 
the concrete implementations. That said, in most cases you don&apos;t need to pass any properties at all.
</p>

<p>
The last line 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
EObject&nbsp;eobject&nbsp;=&nbsp;resource.getContents().get(0);<br />
</p>
</div>
</div>


</p>

<p>
assigns the root element to a local variable.
Actually it is the first element from the contents list of a <em>Resource</em>, but in Xtext a <em>Resource</em> always has just one root element.
</p>


</div>

<a name="programmatic_EMF"></a>

<a name="programmatic_EMF"></a>
<div class="section" title="Working with EMF Models">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Working with EMF Models
</h3>
</div>
</div>
</div>



<p>
We have previously talked about Ecore models, which effectively is an <em>EPackage</em> containing a any number of <em>EClasses</em> with <em>EAttributes</em> and <em>EReferences</em>. 
Ecore defines additional concepts but they are not so important here. An <em>EObject</em> is an instance of an <em>EClass</em>. For instance, the root element
of a domain model would be an instance of the EClass <em>DomainModel</em>, as defined in the grammar in the last chapter. EMF provides a reflection layer to work
with EObjects in a generic way. 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
assertEquals(&quot;DomainModel&quot;,&nbsp;eobject.eClass().getName());<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
It is also possible to create new instances or get and set values using the reflection layer. That reflection layer is very helpful when creating generic 
libraries for EMF models, however if you know what kind of model you are working with it&apos;s much nicer to program against the generated Java classes. 
As we know that the root element is an instance of DomainModel we can just cast it to the Java interface generated by EMF:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;domainModel&nbsp;=&nbsp;(DomainModel)&nbsp;eobject;<br />
</p>
</div>
</div>


</p>

<p>
The generated Java types provide getter and setter methods for each <em>EAttribute</em> and <em>EReference</em>, so that you can easily navigate the model using Java:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
EList&lt;AbstractElement&gt;&nbsp;elements&nbsp;=&nbsp;domainModel.getElements();<br /><span class="keyword">for</span>&nbsp;(AbstractElement&nbsp;abstractElement&nbsp;:&nbsp;elements)&nbsp;{<br />&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(abstractElement&nbsp;<span class="keyword">instanceof</span>&nbsp;Entity)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;Entity&nbsp;entity&nbsp;=&nbsp;((Entity)abstractElement);<br />&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;entity&nbsp;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;entity.getName()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&quot;&nbsp;<span class="keyword">extends</span>&nbsp;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;entity.getSuperType().getName());<br />&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(abstractElement&nbsp;<span class="keyword">instanceof</span>&nbsp;PackageDeclaration)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PackageDeclaration&nbsp;pkgDecl&nbsp;=&nbsp;(PackageDeclaration)&nbsp;abstractElement;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;<span class="keyword">package</span>&nbsp;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;pkgDecl.getName());<br />&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
Note that you&apos;ll find a lot of convenience API in EMF&apos;s <em>EcoreUtil</em> and Xtext&apos;s 
<em>org.eclipse.xtext.EcoreUtil2</em>
. 
</p>


</div>

<a name="node_model"></a>

<a name="node_model"></a>
<div class="section" title="Working with the Parse Tree (aka Node Model)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Working with the Parse Tree (aka Node Model)
</h3>
</div>
</div>
</div>



<p>
In many situations the information from the <em>AST</em> is sufficient, but in some situations you need additional syntactical information. In Xtext not only
an <em>AST</em> is constructed while parsing but also a so called <em>parse tree</em>, which contains all the textual information chunked in so called tokens. The <em>parse tree</em>, also 
called <em>node model</em>, consists of two different kinds of nodes. 
</p>

<p>
<em>LeafNodes</em> as the name suggests represent the leafs of the parse tree. Each leaf node represents one 
token. If you go through all leaf nodes of a parse tree and concatenate all the tokens to one string, you&apos;ll end up with the whole textual representation 
of the model, including all hidden tokens such as whitespace and comments. The following code does exactly that:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
CompositeNode&nbsp;node&nbsp;=&nbsp;NodeUtil.getNode(domainModel);<br />Iterable&lt;AbstractNode&gt;&nbsp;contents&nbsp;=&nbsp;NodeUtil.getAllContents(node);<br />StringBuffer&nbsp;text&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;StringBuffer();<br /><span class="keyword">for</span>&nbsp;(AbstractNode&nbsp;abstractNode&nbsp;:&nbsp;contents)&nbsp;{<br />&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(abstractNode&nbsp;<span class="keyword">instanceof</span>&nbsp;LeafNode)<br />&nbsp;&nbsp;&nbsp;&nbsp;text.append(((LeafNode)abstractNode).getText());<br />}<br />System.out.println(text);<br />
</p>
</div>
</div>


</p>

<p>
In addition to the text <em>LeafNodes</em> also hold information about the line, the offset and the length of that token.
</p>

<p>
The other node type is called <em>CompositeNode</em> and is created for almost each grammar element. A composite node can contain other composite nodes and leaf nodes.
The super type of both node types is <em>AbstractNode</em>. One can find a couple of convenience methods in 
<em>org.eclipse.xtext.parsetree.NodeUtil</em>
 and 
<em>org.eclipse.xtext.parsetree.ParseTreeUtil</em>
.
</p>


</div>

<a name="working_with_grammar_model"></a>

<a name="working_with_grammar_model"></a>
<div class="section" title="Working with the Grammar">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Working with the Grammar
</h3>
</div>
</div>
</div>



<p>
Also the grammar is represented as an EMF model and can be used in Java. In fact each node of the <em>node model</em> references
the element from the grammar which was responsible for parsing or lexing that node:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
DomainModel&nbsp;domainModel&nbsp;=&nbsp;(DomainModel)&nbsp;eObject;<br />CompositeNode&nbsp;node&nbsp;=&nbsp;NodeUtil.getNode(domainModel);<br />ParserRule&nbsp;parserRule&nbsp;=&nbsp;(ParserRule)&nbsp;node.getGrammarElement();<br />assertEquals(&quot;DomainModel&quot;,&nbsp;parserRule.getName());<br />
</p>
</div>
</div>


</p>


</div>



<a name="processing_Xtext_models-7"></a>
<div class="section" title="Working with Live Models">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Working with Live Models
</h3>
</div>
</div>
</div>



<p>
In a running Xtext Workbench, there are a number of components which access the semantic model of an open editor, i.e. the parser, the linker, the validator, the outline, the index builder etc. While some of these components are executed by the display thread, others like the parser or the indexer use different concurrent threads to not deteriorate the editing experience. If you for example want to have a consistent outline of your model, it is essential to keep other threads from modifying the model while the outline component reads it.
</p>

<p>
Many of the prominent locations where users can hook in their own code in Xtext are already called from within a thread safe context, e.g. the API for 
<a href="155-quickfix.xdoc.html#quickfixes">quick fixes</a>. Consequently, the following usually applies only if you add additional functionality on top of Xtext, e.g. custom UI actions.
</p>

<p>
Each 
<em>org.eclipse.xtext.ui.editor.XtextEditor</em>
 uses an 
<em>org.eclipse.xtext.ui.editor.model.IXtextDocument</em>
 to store its model. To avoid synchronization trouble, neither of them provides direct access to the 
<em>org.eclipse.xtext.resource.XtextResource</em>
 storing the semantic model. Instead, the <em>IXtextDocument</em> has two methods <em>readOnly()</em> and <em>modify()</em>. Both take an argument of type 
<em>org.eclipse.xtext.util.concurrent.IUnitOfWork</em>
_(==&amp;lt;T&amp;gt;==, IXtextResource)_ which defines a method <em>==&amp;lt;T&amp;gt;== exec(IXtextResource)</em> that contains what you want to do with the model and allows to deliver a result of arbitrary type.
</p>

<p>
So here is an example of safely reading a model:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
IXtextDocument&nbsp;myDocument&nbsp;=&nbsp;...;<br />String&nbsp;rootElementName&nbsp;=&nbsp;&nbsp;myDocument.readOnly(<br />&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;IUnitOfWork(){<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;String&nbsp;exec(IXtextResource&nbsp;resource)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyType&nbsp;type&nbsp;=&nbsp;(MyType)resource.getContents().get(0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;myType.getName();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;});<br />
</p>
</div>
</div>


</p>

<p>
Direct write-access on the document is usually only performed inside the framework. If you want to change a document by means of its semantic model, you should rather use an <em>org.eclipse.xtext.ui.editor.model.edit.IDocumentEditor</em> which uses the <em>modify()</em> method internally but takes care of synchronizing the 
<a href="016-working-with-Xtext-models.xdoc.html#node_model">node model</a>, too:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
@Inject<br /><span class="keyword">private</span>&nbsp;IDocumentEditor&nbsp;documentEditor;<br /><br /><span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;setRootName(IXtextDocument&nbsp;myDocument,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">final</span>&nbsp;String&nbsp;newName)&nbsp;{<br />&nbsp;documentEditor.process(<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;IUnitOfWork.Void()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;process(IXtextResource&nbsp;resource)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyType&nbsp;type&nbsp;=&nbsp;(MyType)resource.getContents().get(0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myType.setName(newName);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;myDocument);<br />}<br />
</p>
</div>
</div>


</p>


</div>



<a name="processing_Xtext_models-8"></a>
<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Summary
</h3>
</div>
</div>
</div>



<p>
Let&apos;s summarize what we have learned: An Xtext model is loaded by an EMF Resource. The main model is represented as an instance of so called <em>EClasses</em> which are themselves
declared within Ecore models. A <em>parse tree</em> is created as well, which effectively acts as a tracing model between the text, the <em>AST</em> and the grammar. The following
diagram illustrates the four different kinds of models.
</p>

<p>
<div class="image" >
<img src="images/xtext_data_structures.png" class=" width:50%" />
 
</div>
</p>


</div>

</div>



<a name="getting_started-4"></a>
<div class="section" title="Writing a Code Generator">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Writing a Code Generator
</h2>
</div>
</div>
</div>



<p>
In the previous section we&apos;ve seen how to process Xtext files in general (e.g. with Java). 
If you need late binding, loading models dynamically and interpreting them is a good idea. 
If you do not need late binding, code generation is a viable option which is widely used to make models executable. 
</p>

<p>
You could of course use Java to do the code generation, but unfortunately Java doesn&apos;t support this task very well.
Therefore we use a language specialized on code generation: M2T Xpand.
</p>




<a name="getting_started_xpand-3"></a>
<div class="section" title="Xpand and MWE2">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Xpand and MWE2
</h3>
</div>
</div>
</div>



<p>
Xpand is also part of Eclipse and ships with its own documentation, so we don&apos;t need to explain all the details here, but
rather want to point you to the existing documentation. Instead this chapter is about providing some information about how to
use Xtext and Xpand together. 
</p>

<p>
The other technology we are going to use here is the 
<a href="118-mwe-in-depth.xdoc.html#MWE2">Modeling Workflow Engine 2</a>. It is used to describe the generation workflow,
that is how and which models should be loaded, how they should be validated post-processed and where and how code generation should take place.
</p>

<p>
This section is based on the 
<a href="015-getting-started.xdoc.html#getting_started_xtext">Getting Started</a> section and uses the code generator project which is created by Xtext&apos;s project wizard.
</p>


</div>



<a name="getting_started_xpand-4"></a>
<div class="section" title="The Empty Generator Project">
<div class="titlepage">
<div>
<div>
<h3 class="title">
The Empty Generator Project
</h3>
</div>
</div>
</div>



<p>
Previously when we created the projects to develop the domain model language, we had checked the option <em>Create a generator project</em> in the wizard, which as 
a result created a third project for us in the workspace. If you&apos;ve followed along you should have a project called 
&apos;org.eclipse.xtext.example.domainmodel.generator&apos; in your workspace. It should look like shown in the following screenshot:
</p>

<p>
<div class="image" >
<img src="images/generator-project.png" class=" width:50%" />
 
</div>
</p>


</div>



<a name="getting_started_xpand-5"></a>
<div class="section" title="Replacing the Example Model File (1)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Replacing the Example Model File (1)
</h3>
</div>
</div>
</div>



<p>
The four files shown in the image above are very simple stubs generated for the &apos;Hello World&apos;-language the wizard creates as a starting point. 
We&apos;ll have to adapt them to match the domain model language we have developed in the 
<a href="015-getting-started.xdoc.html#getting_started_xtext">getting started section</a>. The first 
thing we should do is open up the example model file (1) and replace its contents with an instance of the domain model language. To do so 
copy and paste the following into the editor:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;java.lang&nbsp;{<br />&nbsp;&nbsp;datatype&nbsp;String<br />&nbsp;&nbsp;datatype&nbsp;Boolean<br />}<br /><br /><span class="keyword">package</span>&nbsp;my.entities&nbsp;{<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">import</span>&nbsp;java.lang.*<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;entity&nbsp;Session&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;String<br />&nbsp;&nbsp;&nbsp;&nbsp;isTutorial&nbsp;:&nbsp;Boolean<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;entity&nbsp;Conference&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />&nbsp;&nbsp;&nbsp;&nbsp;attendees&nbsp;:&nbsp;Person*<br />&nbsp;&nbsp;&nbsp;&nbsp;speakers&nbsp;:&nbsp;Speaker*<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;entity&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:&nbsp;String<br />&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;entity&nbsp;Speaker&nbsp;<span class="keyword">extends</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;sessions&nbsp;:&nbsp;Session*<br />&nbsp;&nbsp;}<br />}&nbsp;<br />
</p>
</div>
</div>


</p>


</div>



<a name="getting_started_xpand-6"></a>
<div class="section" title="The Modeling Workflow Engine File (2)">
<div class="titlepage">
<div>
<div>
<h3 class="title">
The Modeling Workflow Engine File (2)
</h3>
</div>
</div>
</div>



<p>
As mentioned MWE2 is used to define and configure the generation process. Actually, it is much more general and can be useful for a lot of other things as well.
Let&apos;s have a look at the MWE2 file as generated by the wizard:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">module</span>&nbsp;workflow.DomainmodelGenerator<br /><br /><span class="keyword">import</span>&nbsp;org.eclipse.emf.mwe.utils.*<br /><br /><span class="keyword">var</span>&nbsp;targetDir&nbsp;=&nbsp;&quot;src-gen&quot;<br /><span class="keyword">var</span>&nbsp;fileEncoding&nbsp;=&nbsp;&quot;ISO-8859-1&quot;<br /><span class="keyword">var</span>&nbsp;modelPath&nbsp;=&nbsp;&quot;src/model&quot;<br /><br />Workflow&nbsp;{<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;org.eclipse.xtext.mwe.Reader&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lookup&nbsp;all&nbsp;resources&nbsp;on&nbsp;the&nbsp;classpath<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;useJavaClassPath&nbsp;=&nbsp;<span class="keyword">true</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;or&nbsp;define&nbsp;search&nbsp;scope&nbsp;explicitly<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;modelPath<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;class&nbsp;will&nbsp;be&nbsp;generated&nbsp;by&nbsp;the&nbsp;xtext&nbsp;generator&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;=&nbsp;org.eclipse.xtext.example.DomainmodelStandaloneSetup&nbsp;{}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot&nbsp;=&nbsp;&quot;greetings&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;&quot;Greeting&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;org.eclipse.xpand2.Generator&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expand&nbsp;=&nbsp;&quot;templates::Template::main&nbsp;FOREACH&nbsp;greetings&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outlet&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;targetDir<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileEncoding&nbsp;=&nbsp;fileEncoding<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
The first line just declares a name for this workflow file. Any qualified Java identifier is allowed, but it should 
match the file name of the MWE2 file (and in future versions we might make this mandatory). It is followed by an <em>import</em> statement.
MWE2 references Java classes and to make that convenient, you can specify imports after the module declaration. Next up we 
see a couple of <em>vars</em> are declared. Such <em>vars</em> can be overridden when invoking a workflow file. 
</p>

<p>
The important part is the <em>Workflow</em> part. There we declare an instance of <em>org.eclipse.emf.mwe.utils.Workflow</em> and add two instances to the <em>component</em>
property. The first one is a <em>Reader</em> which is used to initialize Xtext languages, read in Xtext files, and fetch specific elements from those models in order to
make them available to following workflow components (such as the declared <em>Generator</em>). 
</p>

<p>
Xtext language initialization is done by specifying any number of 
<em>org.eclipse.xtext.ISetup</em>
 implementations. In our case the generated <em>DomainModelStandaloneSetup</em> is
registered, which makes sure that the infrastructure of your domain model language is set up properly. If you have multiple languages just add additional assignments for each language.
</p>

<p>
You have to tell the <em>Reader</em> which paths to scan for model files. In this particular case we just specified one path. Another convenient option is to reuse the Java classpath, as suggested in the comments.
</p>

<p>
The <em>load</em> section specifies which elements to fetch from the loaded resources. In this case we state that we want all elements of type <em>Greeting</em>.
Note that this is completely file agnostic, it will provide you with all elements from all files the <em>Reader</em> could find on the specified paths.
The slot name is the name by which other workflow components can access the stored elements.
</p>

<p>
The second workflow component is an instance of <em>org.eclipse.xpand2.Generator</em>, which is the MWE2 facade to the Xpand template language. 
The Xpand generator needs to know which template to invoke for which models. Qualified names in Xpand are separated by a double colon <em>&apos;::&apos;</em>. That
is the name <em>&apos;templates::Template::main&apos;</em> points to the definition <em>main</em> in the file <em>templates/Template.xpt</em> on the Java classpath. The second part
<em>FOREACH greetings</em> references the <em>greetings</em> slot which has previously been populated by the reader component.
</p>

<p>
An <em>Outlet</em> describes where to put the generated sources. In Xpand there is a file-statement which refers to outlets. If you only have one outlet 
you don&apos;t have to give it a name, but you need to declare where the root folder for that outlet can be found in the file system. I.e. you specifiy where the generated code should go.
Oulets allow you to specify a couple of other things as well. As MWE2 just instantiates Java objects, you can go to the Java code of <em>org.eclipse.xpand2.output.Outlet</em>
 in order to find out (see the adder and setter methods). 
about the different options.
</p>

<p>
Now that we understood the most important things in the workflow we have to adapt it to match our domain model language. We only have to change the type
which is used to fetch and filter the elements in the load section. We want to generate code for entities, therefore we change it to Entity. We should change the slot&apos;s 
name, too:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">module</span>&nbsp;workflow.DomainmodelGenerator<br /><br /><span class="keyword">import</span>&nbsp;org.eclipse.emf.mwe.utils.*<br /><br /><span class="keyword">var</span>&nbsp;targetDir&nbsp;=&nbsp;&quot;src-gen&quot;<br /><span class="keyword">var</span>&nbsp;fileEncoding&nbsp;=&nbsp;&quot;ISO-8859-1&quot;<br /><span class="keyword">var</span>&nbsp;modelPath&nbsp;=&nbsp;&quot;src/model&quot;<br /><br />Workflow&nbsp;{<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;org.eclipse.xtext.mwe.Reader&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lookup&nbsp;all&nbsp;resources&nbsp;on&nbsp;the&nbsp;classpath<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;useJavaClassPath&nbsp;=&nbsp;<span class="keyword">true</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;or&nbsp;define&nbsp;search&nbsp;scope&nbsp;explicitly<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;modelPath<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;class&nbsp;will&nbsp;be&nbsp;generated&nbsp;by&nbsp;the&nbsp;xtext&nbsp;generator&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;=&nbsp;org.eclipse.xtext.example.DomainmodelStandaloneSetup&nbsp;{}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot&nbsp;=&nbsp;&quot;entities&quot;&nbsp;//changed&nbsp;to&nbsp;entities<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;&quot;Entity&quot;&nbsp;&nbsp;&nbsp;//changed&nbsp;to&nbsp;Entity<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;org.eclipse.xpand2.Generator&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expand&nbsp;=&nbsp;&quot;templates::Template::main&nbsp;FOREACH&nbsp;entities&quot;&nbsp;//changed&nbsp;to&nbsp;entities<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outlet&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;targetDir<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileEncoding&nbsp;=&nbsp;fileEncoding<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>


</div>



<a name="getting_started_xpand-7"></a>
<div class="section" title="Using Xpand (3) and Xtend (4) for Code Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Using Xpand (3) and Xtend (4) for Code Generation
</h3>
</div>
</div>
</div>



<p>
The MWE2 file invokes an Xpand definition called <em>main</em> located in <em>templates/Template.xpt</em>. 
Please open that file and replace its contents with the following Xpand code:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">IMPORT</span>&nbsp;org::eclipse::xtext::example::domainmodel<br /><span class="keyword">EXTENSION</span>&nbsp;templates::Extensions<br /><br /><span class="keyword">DEFINE</span>&nbsp;main&nbsp;<span class="keyword">FOR</span>&nbsp;Entity-<br /><span class="keyword">FILE</span>&nbsp;qualifiedName().replaceAll(&quot;\\.&quot;,&quot;/&quot;)+&quot;.java&quot;-<br />package&nbsp;packageName();<br /><br />public&nbsp;class&nbsp;name&nbsp;IF&nbsp;superType&nbsp;!=&nbsp;null&nbsp;extends&nbsp;superType.nameENDIF{<br />&nbsp;&nbsp;<span class="keyword">EXPAND</span>&nbsp;property&nbsp;<span class="keyword">FOREACH</span>&nbsp;features<br />}<br /><span class="keyword">ENDFILE</span><br /><span class="keyword">ENDDEFINE</span><br /><br /><span class="keyword">DEFINE</span>&nbsp;property&nbsp;<span class="keyword">FOR</span>&nbsp;Feature<br />&nbsp;&nbsp;private&nbsp;type.referenced.qualifiedName()&nbsp;name;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;public&nbsp;void&nbsp;setname.toFirstUpper()(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type.referenced.qualifiedName()&nbsp;name)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.name&nbsp;=&nbsp;name;<br />&nbsp;&nbsp;}&nbsp;<br />&nbsp;&nbsp;public&nbsp;type.referenced.qualifiedName()&nbsp;getname.toFirstUpper()()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;<br />&nbsp;&nbsp;}&nbsp;<br /><span class="keyword">ENDDEFINE</span><br />
</p>
</div>
</div>


</p>

<p>
You might get a couple of error markers, because the Xpand file references another file (_Extensions.ext_ (4)) which has not yet been updated. 
Let&apos;s ignore this for a moment and have a look at the general structure of an Xpand template file. In the first line we import the namespace (i.e. Java package)
of the generated AST classes, that is Entity and Feature, we want to refer to in the generator. Next up the previously mentioned Xtend file is imported. An Xtend file defines 
functions which can be used in Xpand. 
</p>

<p>
The rest of the file contains two so called definitions. A definition in Xpand is similar to a function in that it can be called, it has a name and it is defined
for one or more arguments. The general syntax is as follows:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
&nbsp;<span class="keyword">DEFINE</span>&nbsp;name(ArgType1&nbsp;arg1,&nbsp;ArgType2&nbsp;arg2)&nbsp;<span class="keyword">FOR</span>&nbsp;MainArgType<br />
</p>
</div>
</div>


</p>

<p>
Where <em>MainArgType</em> is bound to the variable name <em>this</em> which can like in Java be omitted when referring to.
</p>

<p>
The first definition <em>main</em> is defined for <em>Entity</em> and is the one invoked from the previously discussed MWE2 file (2). 
The first thing the definition does is opening a file using the <em>qualifiedName()</em> of the given <em>Entity</em>. 
The function <em>qualifiedName()</em> should be declared in the referenced Xtend file (4). To do so open that file and replace its
current contents by the following snippet:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;org::eclipse::xtext::example::domainmodel;<br /><br />packageName(Type&nbsp;<span class="keyword">this</span>)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;qualifiedName(eContainer());<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />packageName(Void&nbsp;<span class="keyword">this</span>)&nbsp;:&nbsp;null;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />String&nbsp;qualifiedName(Object&nbsp;<span class="keyword">this</span>)&nbsp;:&nbsp;null;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />String&nbsp;qualifiedName(Type&nbsp;<span class="keyword">this</span>)&nbsp;:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;packageName()==null?&nbsp;name&nbsp;:&nbsp;packageName()+&quot;.&quot;+name;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />String&nbsp;qualifiedName(PackageDeclaration&nbsp;<span class="keyword">this</span>)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;qualifiedName(eContainer())==null&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">then</span>&nbsp;name<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;qualifiedName(eContainer())+&apos;.&apos;+name;<br />
</p>
</div>
</div>


</p>

<p>
It defines the <em>qualifiedName()</em> function not only for <em>Entity</em> but also generally for types. Note how it computes the qualified name by calling
<em>qualifiedName()</em> recursively on its <em>eContainer()</em>. Both Xpand and Xtend are based on the same expression language, which is statically typed and 
allows for very convenient navigation over object graphs and collections.
</p>

<p>
Back to the Xpand file (3) we see some static text which goes directly into the opened file. The <em>EXPAND</em> statement calls the other definition defined in this file.
It will effectively generate a Java field and two accessor-methods for each <em>Feature</em>. 
</p>

<p>
You&apos;ll now able able to run the generator by opening the context menu on the <em>*.mwe2</em> file (2) and choose <em>Run As-&gt;MWE2 Workflow</em>.
For more information on Xpand and Xtend see the corresponding language documentation (available through Eclipse Help). MWE2 is explained in detail 
in 
<a href="118-mwe-in-depth.xdoc.html#MWE2">a later section</a>. 
</p>


</div>

</div>

</body>
</html>
