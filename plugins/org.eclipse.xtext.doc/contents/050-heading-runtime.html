<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Runtime Concepts</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="xtext.html" title="">
</head>
<body>
<a name="runtime_concepts"></a>
<h1>Runtime Concepts</h1>
<p>
Xtext itself and every language infrastructure developed with Xtext is configured and wired-up using 
<a href="030-generator.html#dependencyInjection" title="Go to &quot;Dependency Injection in Xtext with Google Guice&quot;">dependency injection</a>. Xtext may be used in different environments which introduce 
different constraints. Especially important is the difference between OSGi managed containers and plain 
vanilla Java programs. To honor these differences Xtext uses the concept of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ISetup.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ISetup" >ISetup</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java" title="View Source Code" >(src)</a>-implementations in normal mode and uses Eclipse&apos;s 
extension mechanism when it should be configured in an OSGi environment.   
</p>
<a name="runtimeSetup"></a>
<h2>Runtime Setup (ISetup)</h2>
<p>
For each language there is an implementation of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ISetup.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ISetup" >ISetup</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java" title="View Source Code" >(src)</a> 
generated. It implements a method called <span class="inlinecode">createInjectorAndDoEMFRegistration()</span>, which can be called 
to do the initialization of the language infrastructure. 
</p>
<p>
<em>Caveat</em>: The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ISetup.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ISetup" >ISetup</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java" title="View Source Code" >(src)</a> class is intended to be used for runtime and for unit 
testing, only. if you use it in a Equinox scenario, you will very likely break the running application 
because entries to the global registries will be overwritten.
</p>
<p>
The setup method returns an <a class="jdoc" href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Injector.html" title="View JavaDoc"><abbr title="com.google.inject.Injector" >Injector</abbr></a>, which can further be used to obtain a 
parser, etc. It also registers the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.Factory.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource.Factory" >Resource.Factory</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a> and generated 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EPackage.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EPackage" >EPackages</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java" title="View Source Code" >(src)</a> to the respective global registries provided 
by EMF. So basically after having run the setup and you can start using EMF API to load and store models
of your language.
</p>
<a name="equinoxSetup"></a>
<h2>Setup within Eclipse-Equinox (OSGi)</h2>
<p>
Within Eclipse we have a generated <em>Activator</em>, which creates a Guice <a class="jdoc" href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Injector.html" title="View JavaDoc"><abbr title="com.google.inject.Injector" >Injector</abbr></a>
using the <a href="030-generator.html#guicemodules" title="Go to &quot;The Module API&quot;">modules</a>. In addition an <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtensionFactory.html" title="View JavaDoc"><abbr title="org.eclipse.core.runtime.IExecutableExtensionFactory" >IExecutableExtensionFactory</abbr></a> 
is generated for each language, which is used to create <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtension.html" title="View JavaDoc"><abbr title="org.eclipse.core.runtime.IExecutableExtension" >IExecutableExtensions</abbr></a>.
This means that everything which is created via extension points is managed by Guice as well, i.e. you can 
declare dependencies and get them injected upon creation. 
</p>
<p>
The only thing you have to do in order to use this factory is to prefix the class with the factory 
<em>MyDslExecutableExtensionFactory</em> name followed by a colon.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
&lt;extension&nbsp;point=<span class="string">"org.eclipse.ui.editors"</span>&gt;<br/>
&nbsp;&nbsp;&lt;editor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class=<span class="string">"&lt;MyDsl&gt;ExecutableExtensionFactory:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.eclipse.xtext.ui.editor.XtextEditor"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;contributorClass=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"org.eclipse.ui.editors.text.TextEditorActionContributor"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;default=<span class="string">"true"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;extensions=<span class="string">"mydsl"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;id=<span class="string">"org.eclipse.xtext.example.MyDsl"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;name=<span class="string">"MyDsl&nbsp;Editor"</span>&gt;<br/>
&nbsp;&nbsp;&lt;/editor&gt;<br/>
&lt;/extension&gt;
</p>
</div>
</div>
</p>
<a name="runtime_concepts_4"></a>
<h2>Logging</h2>
<p>
Xtext uses Apache&apos;s log4j for logging. It is configured using files named <em>log4j.properties</em>, which are looked up 
in the root of the Java class path. If you want to change or provide configuration at runtime (i.e. non-OSGi), all 
you have to do is putting such a <em>log4j.properties</em> in place and make sure that it is not overridden by other 
<em>log4j.properties</em> in previous class path entries.
</p>
<p>
In OSGi you provide configuration by creating a fragment for <em>org.apache.log4j</em>. In this case you need to make 
sure that there is not any second fragment contributing a <em>log4j.properties</em> file.
</p>
<a name="codegeneration"></a>
<h2>Code Generation / Compilation</h2>
<p>
Once you have a language you probably want to do something with it. There are two options, you can either
write an interpreter that inspects the AST and does something based on that or you translate your language to another programming language or configuration files.
 
In this section we&apos;re going to show how to implement a code generator for an Xtext-based language.
</p>
<a name="codegeneration_2"></a>
<h3>IGenerator</h3>
<p>
If you go with the default MWE workflow for your language and you haven&apos;t used Xbase, than you&apos;ll be provided with a callback stub that
implements <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IGenerator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IGenerator" >IGenerator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/generator/IGenerator.java" title="View Source Code" >(src)</a>. It has one method that is called from the builder infrastructure whenever a DSL file has 
changed or should be translated otherwise. The two parameters passed in to this method are:
</p>
<p>
<ul>
	<li>
		The resource to be processed
	</li>
	<li>
		An instance of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IFileSystemAccess.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IFileSystemAccess" >IFileSystemAccess</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/IFileSystemAccess.java" title="View Source Code" >(src)</a>
	</li>
</ul>
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IFileSystemAccess.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IFileSystemAccess" >IFileSystemAccess</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/IFileSystemAccess.java" title="View Source Code" >(src)</a> API abstracts over the different file systems the code generator my run over.
These are typically Eclipse&apos;s file system, when the code generator is triggered from within the incremental build infrastructure in Eclipse,
and <span class="inlinecode">java.io.File</span> when the code generator is executed outside Eclipse, say in a headless build.
</p>
<p>
A very simple implementation of a code generator for the <a href="020-grammar-language.html#statemachine" title="Go to &quot;A First Example&quot;">example statemachine language</a> introduced earlier could be the following:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;StatemachineGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;<span class="keyword">void</span>&nbsp;doGenerate(Resource&nbsp;resource,&nbsp;IFileSystemAccess&nbsp;fsa)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fsa.generateFile(<span class="string">"relative/path/AllTheStates.txt"</span>,&nbsp;<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">FOR</span>&nbsp;state&nbsp;:&nbsp;resource.allContents.filter(State).toIterable<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State&nbsp;&laquo;</span>state.name<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;</span><span class="keyword">ENDFOR</span><span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;&apos;&apos;</span>)<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
We use Xtend for implementing code generators as it is much better suited for that task then Java (or any other language on the planet :-)). 
Please refer to the Xtend documentation on <a href="http://www.xtend-lang.org">xtend-lang.org</a> for further details. For Java developers it&apos;s extremely easy to learn,
as the basics are similar and you only need to learn the additional powerful concepts.
</p>
<a name="codegeneration_3"></a>
<h3>Output Configurations</h3>
<p>
You don&apos;t want to deal with platform or even installation dependent paths in your code generator, rather you want to be able to configure the code generator
with some basic outlet roots where the different generated files should be placed under. This is what output configurations are made for.
</p>
<p>
By default every language will have a single outlet, that points to <span class="inlinecode">&lt;project-root&gt;/src-gen/</span>. The files that go here are treated as fully derived and will be erased
by the compiler automatically when a new file should be generated. If you need additional outlets or want to have a different default configuration, you need to implement the
interface <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/IOutputConfigurationProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.IOutputConfigurationProvider" >IOutputConfigurationProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/IOutputConfigurationProvider.java" title="View Source Code" >(src)</a>. It&apos;s straight forward to understand and the default implementation gives you a good idea about how to implement it.
</p>
<p>
With this implementation you lay out the basic defaults which can be changed by users on a workspace or per project level using the preferences.
</p>
<a name="validation"></a>
<h2>Validation</h2>
<p>
Static analysis or validation is one of the most interesting aspects when developing a programming
language. The users of your languages will be grateful if they get informative feedback as they type. 
In Xtext there are basically three different kinds of validation.
</p>
<a name="validation_2"></a>
<h3>Automatic Validation</h3>
<p>
Some implementation aspects (e.g. the grammar, scoping) of a language have an impact on what is required 
for a document or semantic model to be valid. Xtext automatically takes care of this. 
</p>
<a name="syntactical_validation"></a>
<h4>Lexer/Parser: Syntactical Validation</h4>
<p>
The syntactical correctness of any textual input is validated automatically by the parser. The error 
messages are generated by the underlying parser technology. One can use the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parser.antlr.ISyntaxErrorMessageProvider" >ISyntaxErrorMessageProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java" title="View Source Code" >(src)</a>-API to customize this messages.
Any syntax errors can be retrieved from the Resource using the common EMF API:
</p>
<p>
<ul>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource" ><span class="inlinecode">Resource.getErrors()</span></abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a>
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource" ><span class="inlinecode">Resource.getWarnings()</span></abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a>
	</li>
</ul>
</p>
<a name="linking_validation"></a>
<h4>Linker: Cross-link Validation</h4>
<p>
Any broken cross-links can be checked generically. As cross-link resolution is done lazily 
(see <a href="050-heading-runtime.html#linking" title="Go to &quot;Linking&quot;">linking</a>), any broken links are resolved lazily as well. If you want to validate whether 
all links are valid, you will have to navigate through the model so that all installed EMF proxies 
get resolved. This is done automatically in the editor.
</p>
<p>
Similar to syntax errors, any unresolvable cross-links will be reported and can be obtained through:
</p>
<p>
<ul>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource" ><span class="inlinecode">Resource.getErrors()</span></abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a>
	</li>
	<li>
		<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource" ><span class="inlinecode">Resource.getWarnings()</span></abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a>
	</li>
</ul>
</p>
<a name="concrete_syntax_validation"></a>
<h4>Serializer: Concrete Syntax Validation</h4>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/IConcreteSyntaxValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.IConcreteSyntaxValidator" >IConcreteSyntaxValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java" title="View Source Code" >(src)</a> validates all constraints that are 
implied by a grammar. Meeting these constraints for a model is mandatory to be serialized.
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
MyRule:<br/>
&nbsp;&nbsp;({MySubRule}&nbsp;<span class="string">"sub"</span>)?&nbsp;(strVal+=ID&nbsp;intVal+=INT)*;
</p>
</div>
</div>
</p>
<p>
This implies several constraints:
<ol>
	<li>
		Types: only instances of <em>MyRule</em> and <em>MySubRule</em> are allowed for this rule. Subtypes are 
		    prohibited, since the parser never instantiates unknown subtypes.
	</li>
	<li>
		Features: In case the <em>MyRule</em> and <em>MySubRule</em> have <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EStructuralFeature" >EStructuralFeatures</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EStructuralFeature.java" title="View Source Code" >(src)</a> 
		    besides <em>strVal</em> and <em>intVal</em>, only <em>strVal</em> and <em>intVal</em> may have 
		    <a href="050-heading-runtime.html#transientvalues" title="Go to &quot;Transient Values&quot;">non-transient values</a>.
	</li>
	<li>
		Quantities: The following condition must be true: <span class="inlinecode">strVal.size()&nbsp;==&nbsp;intVal.size()</span>.
	</li>
	<li>
		Values: It must be possible to <a href="050-heading-runtime.html#valueconverter" title="Go to &quot;Value Converter&quot;">convert all values</a> to valid tokens for 
		    terminal rule <em>STRING</em>.  The same is true for <em>intVal</em> and <em>INT</em>.
	</li>
</ol>
</p>
<p>
The typical use case for the concrete syntax validator is validation in non-Xtext-editors that, 
however, use an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/XtextResource.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.XtextResource" >XtextResource</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java" title="View Source Code" >(src)</a>. This is, for example, the case 
when combining GMF and Xtext. Another use case is when the semantic model is modified "manually" 
(not by the parser) and then serialized again. Since it is very difficult for the serializer to provide 
<a href="050-heading-runtime.html#parsetreeconstructor" title="Go to &quot;Parse Tree Constructor&quot;">meaningful error messages</a>, the concrete syntax validator is executed by default
before serialization. A textual Xtext editor itself is <em>not</em> a valid use case. Here, the parser ensures 
that all syntactical constraints are met. Therefore, there is no value in additionally running the 
concrete syntax validator.  
</p>
<p>
There are some limitations to the concrete syntax validator which result from the fact that it treats 
the grammar as declarative, which is something the parser doesn&apos;t always do.
</p>
<p>
<ul>
	<li>
		Grammar rules containing assigned actions (e.g. <span class="inlinecode">{MyType.myFeature=<span class="keyword">current</span>}</span> are ignored. 
		  Unassigned actions (e.g. <span class="inlinecode">{MyType}</span>), however, are supported. 
	</li>
	<li>
		Grammar rules that delegate to one or more rules containing assigned actions via unassigned rule 
		  calls are ignored.
	</li>
	<li>
		Orders within list-features can not be validated. e.g. <span class="inlinecode">Rule:&nbsp;(foo+=R1&nbsp;foo+=R2)*</span> implies 
		  that <em>foo</em> is expected to contain instances of <em>R1</em> and <em>R2</em> in an alternating order.
	</li>
</ul>
</p>
<p>
To use concrete syntax validation you can let Guice inject an instance of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/IConcreteSyntaxValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.IConcreteSyntaxValidator" >IConcreteSyntaxValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java" title="View Source Code" >(src)</a> and use it directly. 
Furthermore, there is an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/impl/ConcreteSyntaxEValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.impl.ConcreteSyntaxEValidator" >adapter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxEValidator.java" title="View Source Code" >(src)</a> which
allows to use the concrete syntax validator as an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator" >EValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a>. 
You can, for example, enable it in your runtime module, by adding:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@SingletonBinding(eager&nbsp;=&nbsp;<span class="keyword">true</span>)<br/>
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;ConcreteSyntaxEValidator&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bindConcreteSyntaxEValidator()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;ConcreteSyntaxEValidator.<span class="keyword">class</span>;<br/>
}
</p>
</div>
</div>
</p>
<p>
To customize error messages please see 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/IConcreteSyntaxDiagnosticProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.IConcreteSyntaxDiagnosticProvider" >IConcreteSyntaxDiagnosticProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxDiagnosticProvider.java" title="View Source Code" >(src)</a> and subclass 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/impl/ConcreteSyntaxDiagnosticProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.impl.ConcreteSyntaxDiagnosticProvider" >ConcreteSyntaxDiagnosticProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxDiagnosticProvider.java" title="View Source Code" >(src)</a>.
</p>
<a name="custom_validation"></a>
<h3>Custom Validation</h3>
<p>
In addition to the afore mentioned kinds of validation, which are more or less done automatically, 
you can specify additional constraints specific for your Ecore model. We leverage existing 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator" >EMF API</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a> and have put some convenience stuff on top. 
Basically all you need to do is to make sure that an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator" >EValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a> is 
registered for your <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EPackage.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EPackage" >EPackage</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java" title="View Source Code" >(src)</a>. The  
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.Registry.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator.Registry" >EValidator.Registry</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a> can only be filled 
programmatically. That means contrary to the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EPackage.Registry.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EPackage.Registry" >EPackage.Registry</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java" title="View Source Code" >(src)</a> and the 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.Factory.Registry.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource.Factory.Registry" >Resource.Factory.Registry</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a> there is no Equinox extension 
point to populate the validator registry.
</p>
<p>
For Xtext we provide a <a href="030-generator.html#generator_fragment" title="Go to &quot;Generator Fragments&quot;">generator fragment</a> for the convenient Java-based 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator" >EValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a> API. Just add the following fragment to your generator 
configuration and you are good to go:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
fragment&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;org.eclipse.xtext.generator.validation.JavaValidatorFragment&nbsp;{}
</p>
</div>
</div>
</p>
<p>
The generator will provide you with two Java classes. An abstract class generated to <em>src-gen/</em> which 
extends the library class <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/AbstractDeclarativeValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.AbstractDeclarativeValidator" >AbstractDeclarativeValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java" title="View Source Code" >(src)</a>. This 
one just registers the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EPackage.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EPackage" >EPackages</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java" title="View Source Code" >(src)</a> for which this validator introduces constraints.
The other class is a subclass of that abstract class and is generated to the <em>src/</em> folder in order 
to be edited by you. That is where you put the constraints in.
</p>
<p>
The purpose of the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/AbstractDeclarativeValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.AbstractDeclarativeValidator" >AbstractDeclarativeValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java" title="View Source Code" >(src)</a> is to allow you to 
write constraints in a declarative way - as the class name already suggests. That is instead of writing 
exhaustive if-else constructs or extending the generated EMF switch you just have to add the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> annotation to any method and it will be invoked automatically
when validation takes place. Moreover you can state for what type the respective constraint method is, just 
by declaring a typed parameter. This also lets you avoid any type casts. In addition to the reflective 
invocation of validation methods the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/AbstractDeclarativeValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.AbstractDeclarativeValidator" >AbstractDeclarativeValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java" title="View Source Code" >(src)</a> 
provides a couple of convenient assertions.
</p>
<p>
All in all this is very similar to how JUnit 4 works. Here is an example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelJavaValidator&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">extends</span>&nbsp;AbstractDomainmodelJavaValidator&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;@Check<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;checkTypeNameStartsWithCapital(Type&nbsp;type)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(!Character.isUpperCase(type.getName().charAt(0)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning(<span class="string">"Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital"</span>,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DomainmodelPackage.TYPE__NAME);<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
You can also implement quick fixes for individual validation errors and warnings. See the 
<a href="120-heading-UI.html#quickfixes" title="Go to &quot;Quick Fixes&quot;">chapter on quick fixes</a> for details.
</p>
<a name="validation_4"></a>
<h3>Validating Manually</h3>
<p>
As noted above, Xtext uses EMF&apos;s <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EValidator.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EValidator" >EValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java" title="View Source Code" >(src)</a> API to register validators. 
You can run the validators on your model programmatically using EMF&apos;s 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/util/Diagnostician.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.util.Diagnostician" >Diagnostician</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/util/Diagnostician.java" title="View Source Code" >(src)</a>, e.g.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
EObject&nbsp;myModel&nbsp;=&nbsp;myResource.getContents().get(0);<br/>
Diagnostic&nbsp;diagnostic&nbsp;=&nbsp;Diagnostician.INSTANCE.validate(myModel);<br/>
<span class="keyword">switch</span>&nbsp;(diagnostic.getSeverity())&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;Diagnostic.ERROR:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(<span class="string">"Model&nbsp;has&nbsp;errors:&nbsp;"</span>,diagnostic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span>;<br/>
&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;Diagnostic.WARNING:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(<span class="string">"Model&nbsp;has&nbsp;warnings:&nbsp;"</span>,diagnostic);<br/>
}
</p>
</div>
</div>
</p>
<a name="test_validators"></a>
<h3>Test Validators</h3>
<p>
If you have implemented your validators by extending 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/AbstractDeclarativeValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.AbstractDeclarativeValidator" >AbstractDeclarativeValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java" title="View Source Code" >(src)</a>, there are helper classes which
assist you when testing your validators.
</p>
<p>
Testing validators typically works as follows: 
<ol>
	<li>
		The test creates some models which intentionally violate some constraints.
	</li>
	<li>
		The test runs some chosen <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> from the validator.
	</li>
	<li>
		The test asserts whether the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> have raised the expected warnings and errors.
	</li>
</ol>
</p>
<p>
To create models, you can either use EMF&apos;s <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/ResourceSet.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.ResourceSet" >ResourceSet</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/ResourceSet.java" title="View Source Code" >(src)</a> to 
load models from your hard disk or you can utilize the <em>MyDslFactory</em> that EMF generates 
for each <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EPackage.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EPackage" >EPackage</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java" title="View Source Code" >(src)</a>, to construct the tested model elements manually. 
While the first option has the advantages that you can edit your models in your textual concrete syntax, 
the second option has the advantage that you can create partial models.
</p>
<p>
To run the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> and ensure they raise the intended errors and warnings, you can utilize 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/validation/ValidatorTester.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.validation.ValidatorTester" >ValidatorTester</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/validation/ValidatorTester.java" title="View Source Code" >(src)</a> as shown by the following example:
</p>
<p>
Validator:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;MyLanguageValidator&nbsp;<span class="keyword">extends</span>&nbsp;AbstractDeclarativeValidator&nbsp;{<br/>
&nbsp;&nbsp;@Check<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;checkFooElement(FooElement&nbsp;element)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(element.getBarAttribute().contains(<span class="string">"foo"</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<span class="string">"Only&nbsp;Foos&nbsp;allowed"</span>,&nbsp;element,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE,&nbsp;101);<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
JUnit-Test:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;MyLanguageValidatorTest&nbsp;<span class="keyword">extends</span>&nbsp;AbstractXtextTests&nbsp;{<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;ValidatorTester&lt;MyLanguageValidator&gt;&nbsp;tester;<br/>
<br/>
&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;setUp()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;with(MyLanguageStandaloneSetup.<span class="keyword">class</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MyLanguageValidator&nbsp;validator&nbsp;=&nbsp;get(MyLanguageValidator.<span class="keyword">class</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tester&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ValidatorTester&lt;TestingValidator&gt;(validator);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;testError()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute(<span class="string">"barbarbarbarfoo"</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validator().checkFooElement(model);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tester.diagnose().assertError(101);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;testError2()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute(<span class="string">"barbarbarbarfoo"</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validate(model).assertError(101);<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit 
whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the <span class="inlinecode">setUp()</span>-method 
before each test case and thereby helps to create some common state. In this example, the validator 
is instantiated by means of Google Guice. As we inherit from the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/AbstractXtextTests.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.AbstractXtextTests" >AbstractXtextTests</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/AbstractXtextTests.java" title="View Source Code" >(src)</a>
there are a plenty of useful methods available and the state of the global EMF singletons will be restored in the
method <span class="inlinecode">tearDown()</span>. Afterwards, the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/validation/ValidatorTester.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.validation.ValidatorTester" >ValidatorTester</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/validation/ValidatorTester.java" title="View Source Code" >(src)</a> 
is created and parameterized with the actual validator. It acts as a wrapper for the validator, 
ensures that the validator has a valid state and provides convenient access to the validator itself 
(<span class="inlinecode">tester.validator()</span>) as well as to the utility classes which assert diagnostics created by the validator 
(<span class="inlinecode">tester.diagnose()</span>). Please be aware that you have to call <span class="inlinecode">validator()</span> before you can call <span class="inlinecode">diagnose()</span>. 
However, you can call <span class="inlinecode">validator()</span> multiple times in a row.
</p>
<p>
While <span class="inlinecode">validator()</span> allows to call the validator&apos;s <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> directly, 
<span class="inlinecode">validate(model)</span> leaves it to the framework to call the applicable <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a>. However, to avoid 
side-effects between tests, it is recommended to call the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/Check.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.Check" >@Check-methods</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java" title="View Source Code" >(src)</a> directly.
</p>
<p>
<span class="inlinecode">diagnose()</span> and <span class="inlinecode">validate(model)</span> return an object of type 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.validation.AssertableDiagnostics" >AssertableDiagnostics</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.java" title="View Source Code" >(src)</a> which provides 
several <em>assert</em>-methods to verify whether the expected diagnostics are present:
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">assertError(<span class="keyword">int</span>&nbsp;code)</span>: There must be one diagnostic with severity ERROR and the supplied error code.
	</li>
	<li>
		<span class="inlinecode">assertErrorContains(String&nbsp;messageFragment)</span>: There must be one diagnostic with severity ERROR and 
		    its message must contain <em>messageFragment</em>.
	</li>
	<li>
		<span class="inlinecode">assertError(<span class="keyword">int</span>&nbsp;code,&nbsp;String&nbsp;messageFragment)</span>: Verifies severity, error code and messageFragment.
	</li>
	<li>
		<span class="inlinecode">assertWarning(...)</span>: This method is available for the same combination of parameters as <span class="inlinecode">assertError()</span>.
	</li>
	<li>
		<span class="inlinecode">assertOK()</span>: Expects that no diagnostics (errors, warnings etc.) have been raised.   
	</li>
	<li>
		<span class="inlinecode">assertDiagnostics(<span class="keyword">int</span>&nbsp;severity,&nbsp;<span class="keyword">int</span>&nbsp;code,&nbsp;String&nbsp;messageFragment)</span>: Verifies severity, 
		    error code and messageFragment.
	</li>
	<li>
		<span class="inlinecode">assertAll(DiagnosticPredicate...&nbsp;predicates)</span>: Allows to describe multiple diagnostics at the 
		    same time and verifies that all of them are present. Class 
		    <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.validation.AssertableDiagnostics" >AssertableDiagnostics</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.java" title="View Source Code" >(src)</a> contains static <span class="inlinecode">error()</span> and 
		    <span class="inlinecode">warning()</span> methods which help to create the needed 
		    <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.DiagnosticPredicate.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.validation.AssertableDiagnostics.DiagnosticPredicate" >AssertableDiagnostics.DiagnosticPredicate</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/validation/AssertableDiagnostics.java" title="View Source Code" >(src)</a>. Example: 
		    <span class="inlinecode">assertAll(error(123),&nbsp;warning(<span class="string">"some&nbsp;part&nbsp;of&nbsp;the&nbsp;message"</span>))</span>. 
	</li>
	<li>
		<span class="inlinecode">assertAny(DiagnosticPredicate&nbsp;predicate)</span>: Asserts that a diagnostic exists which matches the predicate.
	</li>
</ul>
</p>
<a name="linking"></a>
<h2>Linking</h2>
<p>
The linking feature allows for specification of cross-references within an Xtext grammar.
The following things are needed for the linking:
</p>
<p>
<ol>
	<li>
		declaration of a cross-link in the grammar (at least in the Ecore model)
	</li>
	<li>
		specification of linking semantics (usually provided via the <a href="050-heading-runtime.html#scoping" title="Go to &quot;Scoping&quot;">scoping API</a>)
	</li>
</ol>
</p>
<a name="linking_3"></a>
<h3>Declaration of Cross-links</h3>
<p>
In the grammar a cross-reference is specified using square brackets.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
CrossReference&nbsp;:<br/>
&nbsp;&nbsp;<span class="string">&apos;[&apos;</span>&nbsp;type=ReferencedEClass&nbsp;(<span class="string">&apos;|&apos;</span>&nbsp;<span class="keyword">terminal</span>=CrossReferenceTerminal)?&nbsp;<span class="string">&apos;]&apos;</span><br/>
;
</p>
</div>
</div>
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
ReferringType&nbsp;:<br/>
&nbsp;&nbsp;<span class="string">&apos;ref&apos;</span>&nbsp;referencedObject=[Entity|STRING]<br/>
;
</p>
</div>
</div>
</p>
<p>
The <a href="020-grammar-language.html#metamodelInference" title="Go to &quot;Ecore Model Inference&quot;">Ecore model inference</a> would create an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EClass.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EClass" >EClass</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java" title="View Source Code" >(src)</a> 
<em>ReferringType</em> with an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a> <em>referencedObject</em> of type <em>Entity</em>
with its containment property set to <span class="inlinecode"><span class="keyword">false</span></span>. The referenced object would be identified 
either by a <em>STRING</em> and the surrounding
information in the current context (see <a href="050-heading-runtime.html#scoping" title="Go to &quot;Scoping&quot;">scoping</a>). If you do not use <span class="inlinecode"><span class="keyword">generate</span></span> but <span class="inlinecode"><span class="keyword">import</span></span> 
an existing Ecore model, the class <em>ReferringType</em> (or one of its super types) would need to have an 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a> of type <em>Entity</em> (or one of its super types) declared. Also the 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference&apos;s</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a> containment and container properties needs to be set to <span class="inlinecode"><span class="keyword">false</span></span>. 
</p>
<a name="linking_4"></a>
<h3>Default Runtime Behavior (Lazy Linking)</h3>
<p>
Xtext uses lazy linking by default and we encourage users to stick to this because it provides  
many advantages. One of which is improved performance in all scenarios where you don&apos;t have to load 
the whole closure of all transitively referenced resources. Furthermore it automatically solves 
situations where one link relies on other links. Though cyclic linking dependencies are not 
supported by Xtext at all. 
</p>
<p>
When parsing a given input string, say
</p>
<p>
<span class="inlinecode"><span class="keyword">ref</span>&nbsp;Entity01</span>
</p>
<p>
the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/linking/lazy/LazyLinker.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.linking.lazy.LazyLinker" >LazyLinker</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/lazy/LazyLinker.java" title="View Source Code" >(src)</a> first creates an EMF proxy and 
assigns it to the corresponding <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a>. In EMF a proxy is described by a 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URI</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a>, which points to the real <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. 
In the case of lazy linking the stored <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URI</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a> comprises of the context 
information given at parse time, which is the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> containing the cross-reference, 
the actual <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a>, the index (in case it&apos;s a multi-valued cross-reference) 
and the string which represented the cross-link in the concrete syntax. The latter usually corresponds to 
the name of the referenced <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. In EMF a <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URI</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a>
consists of information about the resource the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> is contained in as well as a so 
called fragment part, which is used to find the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> within that resource. When an  
EMF proxy is resolved, the current <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/ResourceSet.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.ResourceSet" >ResourceSet</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/ResourceSet.java" title="View Source Code" >(src)</a> is asked. The resource set 
uses the first part to obtain (i.e. load if it is not already loaded) the resource. Then the resource is asked to 
return the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> based on the fragment in the URI. The actual cross-reference resolution 
is done by <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/linking/lazy/LazyLinkingResource.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.linking.lazy.LazyLinkingResource" >LazyLinkingResource.getEObject(String)</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/lazy/LazyLinkingResource.java" title="View Source Code" >(src)</a> which receives the 
fragment and delegates to the implementation of the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/linking/ILinkingService.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.linking.ILinkingService" >ILinkingService</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/ILinkingService.java" title="View Source Code" >(src)</a>. The default 
implementation in turn delegates to the <a href="050-heading-runtime.html#scoping" title="Go to &quot;Scoping&quot;">scoping API</a>.
</p>
<p>
A <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/linking/impl/DefaultLinkingService.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.linking.impl.DefaultLinkingService" >simple implementation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/impl/DefaultLinkingService.java" title="View Source Code" >(src)</a> of the linking service is shipped with Xtext 
and used for any grammar per default. Usually any necessary customization of the linking behavior 
can best be described using the <a href="050-heading-runtime.html#scoping" title="Go to &quot;Scoping&quot;">scoping API</a>.
</p>
<a name="scoping"></a>
<h2>Scoping</h2>
<p>
Using the scoping API one defines which elements are referable by a certain reference. For instance, 
using the introductory example (Fowler&apos;s state machine language)
a transition contains two cross-references: One to a declared event and one to a declared state.
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">events</span><br/>
&nbsp;&nbsp;nothingImportant&nbsp;&nbsp;MYEV<br/>
<span class="keyword">end</span><br/>
&nbsp;<br/>
<span class="keyword">state</span>&nbsp;idle<br/>
&nbsp;&nbsp;nothingImportant&nbsp;=&gt;&nbsp;idle<br/>
<span class="keyword">end</span>
</p>
</div>
</div>
</p>
<p>
The grammar rule for transitions looks like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Transition&nbsp;:<br/>
&nbsp;&nbsp;event=[Event]&nbsp;<span class="string">&apos;=&gt;&apos;</span>&nbsp;state=[State];
</p>
</div>
</div>
</p>
<p>
The grammar states that for the reference <em>event</em> only instances of the type <em>Event</em> are allowed and 
that for the EReference <em>state</em> only instances of type <em>State</em> can be referenced. However, this simple 
declaration doesn&apos;t say anything about where to find the states or events. That is the duty of scopes.  
</p>
<p>
An <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IScopeProvider" >IScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java" title="View Source Code" >(src)</a> is responsible for providing 
an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IScope.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IScope" >IScope</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java" title="View Source Code" >(src)</a> for a given context <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> and 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a>. The returned <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IScope.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IScope" >IScope</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java" title="View Source Code" >(src)</a> should 
contain all target candidates for the given object and cross-reference.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;IScopeProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;<span class="comment">/**<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;the&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;provides&nbsp;access&nbsp;to&nbsp;the&nbsp;compatible&nbsp;visible&nbsp;EObjects&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;for&nbsp;a&nbsp;given&nbsp;reference.<br/>
&nbsp;&nbsp;&nbsp;*<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;an&nbsp;element&nbsp;shall&nbsp;be&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;referenced<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference&nbsp;the&nbsp;reference&nbsp;to&nbsp;be&nbsp;used&nbsp;to&nbsp;filter&nbsp;the&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements.<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@link&nbsp;IScope}&nbsp;for&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;reference.&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note&nbsp;for&nbsp;implementors:&nbsp;The&nbsp;result&nbsp;may&nbsp;not&nbsp;be&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;code&gt;null&lt;/code&gt;.&nbsp;Return&nbsp;<br/>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;code&gt;IScope.NULLSCOPE&lt;/code&gt;&nbsp;instead.<br/>
&nbsp;&nbsp;&nbsp;*/</span><br/>
&nbsp;&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EReference&nbsp;reference);<br/>
<br/>
}
</p>
</div>
</div>
</p>
<p>
A single <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IScope.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IScope" >IScope</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java" title="View Source Code" >(src)</a> represents an element of a linked list of scopes. 
That means that a scope can be nested within an outer scope. Each scope works like a symbol table or a 
map where the keys are strings and the values are so called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a>, 
which is effectively an abstract description of a real <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. 
</p>
<a name="global_scopes"></a>
<h3>Global Scopes and Resource Descriptions</h3>
<p>
In the state machine example we don&apos;t have references across model files. Neither is there a concept like 
a namespace which would make scoping a bit more complicated. Basically, every <em>State</em> and every <em>Event</em> 
declared in the same resource is visible by their name. However, in the real world things are most likely 
not that simple: What if you want to reuse certain declared states and events across different 
state machines and you want to share those as library between different users? You would want to introduce 
some kind of cross resource reference. 
</p>
<p>
Defining what is visible from outside the current resource is the responsibility of global scopes. 
As the name suggests, global scopes are provided by instances of the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IGlobalScopeProvider" >IGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java" title="View Source Code" >(src)</a>. The data structures used to 
store its elements are described in the next section.
</p>
<a name="resourcedescriptions"></a>
<h4>Resource and EObject Descriptions</h4>
<p>
In order to make states and events of one file referable from another file you need to export them as 
part of a so called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>. 
</p>
<p>
A <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> contains information about the resource itself 
which primarily its <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URI</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a>, a list 
of exported <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObjects</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> in the form of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a>
as well as information about outgoing cross-references and qualified names it references. The cross 
references contain only resolved references, while the list of imported qualified names also contain 
those names, which couldn&apos;t be resolved. This information is leveraged by Xtext&apos;s indexing infrastructure
in order to compute the transitive hull of dependent resources. 
</p>
<p>
For users and especially in the context of scoping the most important information is the list of 
exported <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObjects</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. An <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> 
stores the <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URI</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a> of the actual <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>,
its <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/QualifiedName.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.QualifiedName" >QualifiedName</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/QualifiedName.java" title="View Source Code" >(src)</a>, as well as its <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EClass.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EClass" >EClass</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java" title="View Source Code" >(src)</a>. 
In addition one can export arbitrary information using the <em>user data</em> map. The following diagram gives 
an overview on the description classes and their relationships.
</p>
<p>
<div class="image" >
<img src="images/index_datamodel.png" class=" " 
 style=" " />
<div class="caption">
The data model of Xtext&apos;s index
</div>
</div>
</p>
<p>
A language is configured with a default implementation of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> 
which computes the list of exported <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> by iterating 
the whole EMF model and applying the <span class="inlinecode">getQualifiedName(EObject&nbsp;obj)</span> from 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/IQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider" >IQualifiedNameProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java" title="View Source Code" >(src)</a> 
on each <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. If the object has a qualified name an 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> is created and exported 
(i.e. added to the list). If an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> doesn&apos;t have a qualified name, the 
element is considered to be not referable from outside the resource and consequently not indexed. If you 
don&apos;t like this behavior, you can implement and bind your own implementation of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>.  
</p>
<p>
There are also two different default implementations of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/IQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider" >IQualifiedNameProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java" title="View Source Code" >(src)</a>. 
Both work by looking up an <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EAttribute.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EAttribute" >EAttribute</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java" title="View Source Code" >(src)</a> &apos;name&apos;. The
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/SimpleNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.SimpleNameProvider" >SimpleNameProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/SimpleNameProvider.java" title="View Source Code" >(src)</a> simply returns the plain value, while the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider" >DefaultDeclarativeQualifiedNameProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.java" title="View Source Code" >(src)</a> concatenates 
the simple name with the qualified name of its parent exported <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. This
effectively simulates the qualified name computation of most namespace-based languages (like e.g. Java). 
</p>
<p>
As mentioned above, in order to calculate an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> for a 
resource the framework asks the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>. To convert 
between a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/QualifiedName.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.QualifiedName" >QualifiedName</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/QualifiedName.java" title="View Source Code" >(src)</a> and its <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html" title="View JavaDoc"><abbr title="java.lang.String" >String</abbr></a> representation you 
can use the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/IQualifiedNameConverter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.IQualifiedNameConverter" >IQualifiedNameConverter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameConverter.java" title="View Source Code" >(src)</a>. Here is some Java code showing how to do 
that:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;IQualifiedNameConverter&nbsp;converter;<br/>
<br/>
Manager&nbsp;manager&nbsp;=&nbsp;<span class="comment">//&nbsp;obtain&nbsp;an&nbsp;instance&nbsp;of&nbsp;IResourceDescription.Manager<br/>
</span>IResourceDescription&nbsp;description&nbsp;=<br/>
&nbsp;&nbsp;manager.getResourceDescription(resource);<br/>
<span class="keyword">for</span>&nbsp;(IEObjectDescription&nbsp;eod&nbsp;:&nbsp;description.getExportedObjects())&nbsp;{<br/>
&nbsp;&nbsp;System.out.println(converter.toString(eod.getQualifiedName()));<br/>
}
</p>
</div>
</div>
</p>
<p>
In order to obtain an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> it is best to ask the 
corresponding <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceServiceProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceServiceProvider" >IResourceServiceProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java" title="View Source Code" >(src)</a>. That is because each 
language might have a totally different implementation and as you might refer from your language to a 
different language you cannot reuse your language&apos;s <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>. 
One basically asks the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceServiceProvider.Registry.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceServiceProvider.Registry" >IResourceServiceProvider.Registry</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java" title="View Source Code" >(src)</a> (there is usually 
one global instance) for an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceServiceProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceServiceProvider" >IResourceServiceProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java" title="View Source Code" >(src)</a>, which in turn provides 
an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> along other useful services.
</p>
<p>
If you are running in a Guice enabled scenario, the code looks like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;<br/>
<span class="keyword">private</span>&nbsp;IResourceServiceProvider.Registry&nbsp;rspr;<br/>
&nbsp;&nbsp;<br/>
<span class="keyword">private</span>&nbsp;IResourceDescription.Manager&nbsp;getManager(Resource&nbsp;res)&nbsp;{<br/>
&nbsp;&nbsp;IResourceServiceProvider&nbsp;resourceServiceProvider&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rspr.getResourceServiceProvider(res.getURI());<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;resourceServiceProvider.getResourceDescriptionManager();<br/>
}
</p>
</div>
</div>
</p>
<p>
If you don&apos;t run in a Guice enabled context you will likely have to directly access the singleton:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">private</span>&nbsp;IResourceServiceProvider.Registry&nbsp;rspr&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;IResourceServiceProvider.Registry.INSTANCE;
</p>
</div>
</div>
</p>
<p>
However, we strongly encourage you to use dependency injection. Now, that we know how to export elements to be 
referable from other resources, we need to learn how those exported 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> can be made available to the referencing resources. That is 
the responsibility of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IGlobalScopeProvider" >global scoping</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java" title="View Source Code" >(src)</a> which is 
described in the following chapter.
</p>
<a name="import_uri"></a>
<h4>Global Scopes Based On Explicit Imports (ImportURI Mechanism)</h4>
<p>
A simple and straight forward solution is to have explicit references to other resources in your 
file by explicitly listing paths or <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="View JavaDoc"><abbr title="org.eclipse.emf.common.util.URI" >URIs</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java" title="View Source Code" >(src)</a> to all referenced resources 
in your model file. That is for instance what most include mechanisms use. In Xtext we provide a handy 
implementation of an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IGlobalScopeProvider" >IGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java" title="View Source Code" >(src)</a> which is based on a naming convention 
and makes this semantics very easy to use. Talking of the introductory example and given you would want to add 
support for referencing external <em>States</em> and <em>Events</em> from within your state machine, all you had to do is 
add something like the following to the grammar definition:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Statemachine&nbsp;:<br/>
&nbsp;&nbsp;(imports+=Import)*&nbsp;<span class="comment">//&nbsp;allow&nbsp;imports<br/>
</span>&nbsp;&nbsp;<span class="string">&apos;events&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(events+=Event)+<br/>
&nbsp;&nbsp;<span class="string">&apos;end&apos;</span><br/>
&nbsp;&nbsp;(<span class="string">&apos;resetEvents&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(resetEvents+=[Event])+<br/>
&nbsp;&nbsp;<span class="string">&apos;end&apos;</span>)?<br/>
&nbsp;&nbsp;<span class="string">&apos;commands&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(commands+=Command)+<br/>
&nbsp;&nbsp;<span class="string">&apos;end&apos;</span><br/>
&nbsp;&nbsp;(states+=State)+;<br/>
<br/>
Import&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;import&apos;</span>&nbsp;importURI=STRING;&nbsp;<span class="comment">//&nbsp;feature&nbsp;must&nbsp;be&nbsp;named&nbsp;importURI</span>
</p>
</div>
</div>
</p>
<p>
This effectively allows import statements to be declared before the events section. In addition 
you will have to make sure that you have bound the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider" >ImportUriGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.java" title="View Source Code" >(src)</a> for the type 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IGlobalScopeProvider" >IGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java" title="View Source Code" >(src)</a> by the means of <a href="030-generator.html#dependencyInjection" title="Go to &quot;Dependency Injection in Xtext with Google Guice&quot;">Guice</a>. 
That implementation looks up any <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EAttribute.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EAttribute" >EAttributes</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java" title="View Source Code" >(src)</a> named &apos;importURI&apos; in your
model and interprets their values as URIs that point to imported resources. That is it adds the corresponding 
resources to the current resource&apos;s resource set. In addition the scope provider uses the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription.Manager" >IResourceDescription.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> of that 
imported resource to compute all the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> returned 
by the <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IScope.html" title="View JavaDoc"><abbr title="org.eclipse.core.runtime.preferences.IScope" >IScope</abbr></a>.  
</p>
<p>
Global scopes based on import URIs are available if you use the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/generator/scoping/ImportURIScopingFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.scoping.ImportURIScopingFragment" >ImportURIScopingFragment</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/scoping/ImportURIScopingFragment.java" title="View Source Code" >(src)</a> in the workflow of your language.
It will bind an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider" >ImportUriGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.java" title="View Source Code" >(src)</a> that handles 
<em>importURI</em> features.
</p>
<a name="index_based"></a>
<h4>Global Scopes Based On External Configuration (e.g. Class Path Based)</h4>
<p>
Instead of explicitly referring to imported resources, the other possibility is to have some kind of 
external configuration in order to define what is visible from outside a resource. Java for instances 
uses the notion of the class path to define containers (jars and class folders) which contain any 
referenceable elements. In the case of Java also the order of such entries is important. 
</p>
<p>
Since version 1.0.0 Xtext provides support for this kind of global scoping. To enable it, a 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/DefaultGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.DefaultGlobalScopeProvider" >DefaultGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/DefaultGlobalScopeProvider.java" title="View Source Code" >(src)</a> has to be bound to 
the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IGlobalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IGlobalScopeProvider" >IGlobalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java" title="View Source Code" >(src)</a> interface. 
</p>
<p>
By default Xtext leverages the class path mechanism since it is well designed and already understood 
by most of our users. The available tooling provided by JDT and PDE to configure the class path adds 
even more value. However, it is just a default: You can reuse the infrastructure without using Java 
and independent from the JDT.
</p>
<p>
In order to know what is available in the "world" a global scope provider which relies on external 
configuration needs to read that configuration in and be able to find all candidates for a certain 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EReference.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EReference" >EReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java" title="View Source Code" >(src)</a>. If you don&apos;t want to force users to have a folder and file name 
structure reflecting the actual qualified names of the referenceable <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObjects</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>, 
you&apos;ll have to load all resources up front and either keep holding them in memory or remembering all information 
which is needed for the resolution of cross-references. In Xtext that information is provided by a so called 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a>. 
</p>
<a name="containers"></a>
<h5>About the Index, Containers and Their Manager</h5>
<p>
Xtext ships with an index which remembers all <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> and 
their <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> objects. In the IDE-context (i.e. when running 
the editor, etc.) the index is updated by an incremental project builder. As opposed to that, in a non-UI 
context you typically do not have to deal with changes such that the infrastructure can be much simpler. In 
both situations the global index state is held by an implementation of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescriptions.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescriptions" >IResourceDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescriptions.java" title="View Source Code" >(src)</a> 
(Note the plural form!). The bound singleton in the UI scenario is even aware of unsaved editor changes, 
such that all linking happens to the latest maybe unsaved version of the resources. You will find the 
Guice configuration of the global index in the UI scenario in 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ui/shared/internal/SharedModule.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ui.shared.internal.SharedModule" >SharedModule</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.ui.shared/src/org/eclipse/xtext/ui/shared/internal/SharedModule.java" title="View Source Code" >(src)</a>.
</p>
<p>
The index is basically a flat list of instances of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>. 
The index itself doesn&apos;t know about visibility constraints due to class path restriction. Rather than that, 
they are defined by the referencing language by means of so called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer" >IContainers</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a>: 
While Java might load a resource via <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/ClassLoader.html" title="View JavaDoc"><abbr title="java.lang.ClassLoader" >ClassLoader.loadResource()</abbr></a> (i.e. using the class path mechanism), another 
language could load the same resource using the file system paths. 
</p>
<p>
Consequently, the information which container a resource belongs to depends on the referencing 
context. Therefore an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceServiceProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceServiceProvider" >IResourceServiceProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java" title="View Source Code" >(src)</a> provides another interesting 
service, which is called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer.Manager" >IContainer.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a>. For a given 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a>, the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer.Manager" >IContainer.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> 
provides you with the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer" >IContainer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> as well as with a list of all 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer" >IContainers</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> which are visible from there. Note that the  
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescriptions.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescriptions" >index</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescriptions.java" title="View Source Code" >(src)</a> is globally 
shared between all languages while the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer.Manager" >IContainer.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> which adds the semantics of containers, can 
be very different depending on the language. The following method lists all resources visible from a 
given <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.resource.Resource" >Resource</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java" title="View Source Code" >(src)</a>:  
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject<br/>
IContainer.Manager&nbsp;manager;<br/>
<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;listVisibleResources(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;myResource,&nbsp;IResourceDescriptions&nbsp;index)&nbsp;{<br/>
&nbsp;&nbsp;IResourceDescription&nbsp;descr&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index.getResourceDescription(myResource.getURI());<br/>
&nbsp;&nbsp;<span class="keyword">for</span>(IContainer&nbsp;visibleContainer:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manager.getVisibleContainers(descr,&nbsp;index))&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(IResourceDescription&nbsp;visibleResourceDesc:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visibleContainer.getResourceDescriptions())&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(visibleResourceDesc.getURI());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
Xtext ships two implementations of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer.Manager" >IContainer.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> which are 
as usual bound with Guice: The default binding is to 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/impl/SimpleResourceDescriptionsBasedContainerManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.impl.SimpleResourceDescriptionsBasedContainerManager" >SimpleResourceDescriptionsBasedContainerManager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/SimpleResourceDescriptionsBasedContainerManager.java" title="View Source Code" >(src)</a>, 
which assumes all <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IResourceDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IResourceDescription" >IResourceDescription</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java" title="View Source Code" >(src)</a> to be in a single common
container. If you don&apos;t care about container support, you&apos;ll be fine with this one. Alternatively, 
you can bind <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/containers/StateBasedContainerManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.containers.StateBasedContainerManager" >StateBasedContainerManager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/StateBasedContainerManager.java" title="View Source Code" >(src)</a> and an 
additional <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/containers/IAllContainersState.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.containers.IAllContainersState" >IAllContainersState</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/IAllContainersState.java" title="View Source Code" >(src)</a> which 
keeps track of the set of available containers and their visibility relationships.  
</p>
<p>
Xtext offers a couple of strategies for managing containers: If you&apos;re running an Eclipse workbench, 
you can define containers based on Java projects and their class paths or based on plain Eclipse projects. 
Outside Eclipse, you can provide a set of file system paths to be scanned for models. All of these only 
differ in the bound instance of <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/containers/IAllContainersState.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.containers.IAllContainersState" >IAllContainersState</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/IAllContainersState.java" title="View Source Code" >(src)</a> 
of the referring language. These will be described in detail in the following sections.
</p>
<p>
<div class="image" >
<img src="images/index_container.png" 
/>
<div class="caption">
IContainer Management
</div>
</div>
</p>
<a name="jdt_based_containers"></a>
<h5>JDT-Based Container Manager</h5>
<p>
As JDT is an Eclipse feature, this JDT-based container management is only available in the UI scenario. 
It assumes so called <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IPackageFragmentRoot.html" title="View JavaDoc"><abbr title="org.eclipse.jdt.core.IPackageFragmentRoot" >IPackageFragmentRoots</abbr></a> as containers. An 
<a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IPackageFragmentRoot.html" title="View JavaDoc"><abbr title="org.eclipse.jdt.core.IPackageFragmentRoot" >IPackageFragmentRoot</abbr></a> in JDT is the root of a tree of Java model elements. 
It usually refers to 
<ul>
	<li>
		a source folder of a Java project,
	</li>
	<li>
		a referenced jar, 
	</li>
	<li>
		a class path entry of a referenced Java project, or
	</li>
	<li>
		the exported packages of a required PDE plug-in.
	</li>
</ul>
</p>
<p>
So for an element to be referable, its resource must be on the class path of the caller&apos;s Java project 
and it must be exported (as described above). 
</p>
<p>
As this strategy allows to reuse a lot of nice Java things like jars, OSGi, maven, etc. it is part of 
the default: You should not have to reconfigure anything to make it work. Nevertheless, if you messed 
something up, make sure you bind
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;IContainer.Manager&gt;&nbsp;bindIContainer$Manager()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;StateBasedContainerManager.<span class="keyword">class</span>;<br/>
}
</p>
</div>
</div>
</p>
<p>
in the runtime module and 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Provider&lt;IAllContainersState&gt;&nbsp;provideIAllContainersState()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;org.eclipse.xtext.ui.shared.Access.getJavaProjectsState();<br/>
}
</p>
</div>
</div>
</p>
<p>
in the UI module of the referencing language. The latter looks a bit more difficult than a common 
binding, as we have to bind a global singleton to a Guice provider. A 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ui/containers/StrictJavaProjectsState.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ui.containers.StrictJavaProjectsState" >StrictJavaProjectsState</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/containers/StrictJavaProjectsState.java" title="View Source Code" >(src)</a> requires all elements to be on the 
class path, while the default <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ui/containers/JavaProjectsState.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ui.containers.JavaProjectsState" >JavaProjectsState</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/containers/JavaProjectsState.java" title="View Source Code" >(src)</a> also allows 
models in non-source folders. 
</p>
<a name="project_based_containers"></a>
<h5>Eclipse Project-Based Containers</h5>
<p>
If the class path based mechanism doesn&apos;t work for your case, Xtext offers an alternative container 
manager based on plain Eclipse projects: Each project acts as a container and the project references 
<em>Properties-&gt;Project References</em> are the visible containers. 
</p>
<p>
In this case, your runtime module should define
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
public&nbsp;Class&lt;?&nbsp;extends&nbsp;IContainer.Manager&gt;&nbsp;bindIContainer$Manager()&nbsp;{<br/>
&nbsp;&nbsp;return&nbsp;StateBasedContainerManager.class;<br/>
}
</p>
</div>
</div>

and the UI module should bind 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Provider&lt;IAllContainersState&gt;&nbsp;provideIAllContainersState()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState();<br/>
}
</p>
</div>
</div>
</p>
<a name="resource_set_containers"></a>
<h5>ResourceSet-Based Containers</h5>
<p>
If you need an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.Manager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer.Manager" >IContainer.Manager</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> that is independent of 
Eclipse projects, you can use the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/containers/ResourceSetBasedAllContainersState.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.containers.ResourceSetBasedAllContainersState" >ResourceSetBasedAllContainersState</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/ResourceSetBasedAllContainersState.java" title="View Source Code" >(src)</a>. 
This one can be configured with a mapping of container handles to resource URIs.
</p>
<p>
It is unlikely you want to use this strategy directly in your own code, but it is used in the back-end 
of the MWE2 workflow component <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/mwe/Reader.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.mwe.Reader" >Reader</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/mwe/Reader.java" title="View Source Code" >(src)</a>. This is responsible 
for reading in models in a workflow, e.g. for later code generation. The 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/mwe/Reader.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.mwe.Reader" >Reader</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/mwe/Reader.java" title="View Source Code" >(src)</a> allows to either scan the whole class path or a set of paths 
for all models therein. When paths are given, each path entry becomes an 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IContainer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IContainer" >IContainer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java" title="View Source Code" >(src)</a> of its own. In the following snippet,
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
component&nbsp;=&nbsp;org.eclipse.xtext.mwe.Reader&nbsp;{<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;lookup&nbsp;all&nbsp;resources&nbsp;on&nbsp;the&nbsp;class&nbsp;path<br/>
</span>&nbsp;&nbsp;<span class="comment">//&nbsp;useJavaClassPath&nbsp;=&nbsp;true<br/>
</span>&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;or&nbsp;define&nbsp;search&nbsp;scope&nbsp;explicitly<br/>
</span>&nbsp;&nbsp;path&nbsp;=&nbsp;<span class="string">"src/models"</span><br/>
&nbsp;&nbsp;path&nbsp;=&nbsp;<span class="string">"src/further-models"</span><br/>
<br/>
&nbsp;&nbsp;...<br/>
}
</p>
</div>
</div>
</p>
<a name="local_scoping"></a>
<h3>Local Scoping</h3>
<p>
We now know how the outer world of referenceable elements can be defined in Xtext. Nevertheless, not 
everything is available in any context and with a global name. Rather than that, each context can usually 
have a different scope. As already stated, scopes can be nested, i.e. a scope can in addition to its 
own elements contain elements of a parent scope. When parent and child scope contain different elements 
with the same name, the parent scope&apos;s element will usually be <em>shadowed</em> by the element from the child scope.      
</p>
<p>
To illustrate that, let&apos;s have a look at Java: Java defines multiple kinds of scopes 
(object scope, type scope, etc.). For Java one would create the scope hierarchy as commented in the 
following example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">//&nbsp;file&nbsp;contents&nbsp;scope<br/>
</span><span class="keyword">import</span>&nbsp;<span class="keyword">static</span>&nbsp;my.Constants.STATIC;<br/>
<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ScopeExample&nbsp;{&nbsp;<span class="comment">//&nbsp;class&nbsp;body&nbsp;scope<br/>
</span>&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;Object&nbsp;field&nbsp;=&nbsp;STATIC;<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">void</span>&nbsp;method(String&nbsp;param)&nbsp;{&nbsp;<span class="comment">//&nbsp;method&nbsp;body&nbsp;scope<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;localVar&nbsp;=&nbsp;<span class="string">"bar"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;innerBlock:&nbsp;{&nbsp;<span class="comment">//&nbsp;block&nbsp;scope<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;innerScopeVar&nbsp;=&nbsp;<span class="string">"foo"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;field&nbsp;=&nbsp;innerScopeVar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;the&nbsp;scope&nbsp;hierarchy&nbsp;at&nbsp;this&nbsp;point&nbsp;would&nbsp;look&nbsp;like&nbsp;this:<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;blockScope{field,innerScopeVar}-&gt;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;methodScope{localVar,&nbsp;param}-&gt;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;classScope{field}-&gt;&nbsp;(&apos;field&apos;&nbsp;is&nbsp;shadowed)<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;fileScope{STATIC}-&gt;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;classpathScope{<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;all&nbsp;qualified&nbsp;names&nbsp;of&nbsp;accessible&nbsp;static&nbsp;fields&apos;}&nbsp;-&gt;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;&nbsp;NULLSCOPE{}<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;field.add(localVar);<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
In fact the class path scope should also reflect the order of class path entries.
For instance:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
classpathScope{stuff&nbsp;from&nbsp;bin/}<br/>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;foo.jar/}<br/>
-&gt;&nbsp;...<br/>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;JRE&nbsp;System&nbsp;Library}<br/>
-&gt;&nbsp;NULLSCOPE{}
</p>
</div>
</div>
</p>
<p>
Please find the motivation behind this and some additional details in 
<a href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html">this blog post</a> .
</p>
<a name="local_scoping_7"></a>
<h4>Declarative Scoping</h4>
<p>
If you have to define scopes for certain contexts, the base class 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/AbstractDeclarativeScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider" >AbstractDeclarativeScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/AbstractDeclarativeScopeProvider.java" title="View Source Code" >(src)</a> allows to do 
that in a declarative way. It looks up methods which have either of the following two signatures:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
IScope&nbsp;scope_&lt;RefDeclaringEClass&gt;_&lt;Reference&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;ContextType&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)<br/>
<br/>
IScope&nbsp;scope_&lt;TypeToReturn&gt;(&lt;ContextType&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)
</p>
</div>
</div>
</p>
<p>
The former is used when evaluating the scope for a specific cross-reference and here <em>ContextReference</em> 
corresponds to the name of this reference (prefixed with the name of the reference&apos;s declaring type and 
separated by an underscore). The <em>ref</em> parameter represents this cross-reference.
</p>
<p>
The latter method signature is used when computing the scope for a given element type and is applicable 
to all cross-references of that type. Here <em>TypeToReturn</em> is the name of that type. 
</p>
<p>
So if you for example have a state machine with a  <em>Transition</em> object owned by its source <em>State</em> and 
you want to compute all reachable states (i.e. potential target states), the corresponding method could 
be declared as follows (assuming the cross-reference is declared by the <em>Transition</em> type and is called <em>target</em>):
</p>
<p>
<span class="inlinecode">IScope&nbsp;scope_Transition_target(Transition&nbsp;<span class="keyword">this</span>,&nbsp;EReference&nbsp;ref)</span>
</p>
<p>
If such a method does not exist, the implementation will try to find one for the context object&apos;s container. 
Thus in the example this would match a method with the same name but <em>State</em> as the type of the first 
parameter. It will keep on walking the containment hierarchy until a matching method is found. This 
container delegation allows to reuse the same scope definition for elements in different places of the 
containment hierarchy. Also it may make the method easier to implement as the elements comprising the 
scope are quite often owned or referenced by a container of the context object. In the example the 
<em>State</em> objects could for instance be owned by a containing <em>StateMachine</em> object.
</p>
<p>
If no method specific to the cross-reference in question was found for any of the objects in the 
containment hierarchy, the implementation will start looking for methods matching the other signature.
Again it will first attempt to match the context object. Thus in the 
example the signature first matched would be:
</p>
<p>
<span class="inlinecode">IScope&nbsp;scope_State(Transition&nbsp;<span class="keyword">this</span>,&nbsp;EReference&nbsp;ref)</span>
</p>
<p>
If no such method exists, the implementation will again try to find a method matching the context object&apos;s 
container objects. In the case of the state machine example you might want to declare the scope with 
available states at the state machine level:
</p>
<p>
<span class="inlinecode">IScope&nbsp;scope_State(StateMachine&nbsp;<span class="keyword">this</span>,&nbsp;EReference&nbsp;ref)</span>
</p>
<p>
This scope can now be used for any cross-references of type <em>State</em> for context objects owned by the 
state machine.
</p>
<a name="namespaceImports"></a>
<h3>Imported Namespace-Aware Scoping</h3>
<p>
The imported namespace aware scoping is based on qualified names and namespaces. It adds namespace 
support to your language, which is comparable and similar to the one in Scala and C#. Scala and C# both 
allow to have multiple nested packages within one file and you can put imports per namespace, so that 
imported names are only visible within that namespace. See the domain model example: its scope provider 
extends <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider" >ImportedNamespaceAwareLocalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java" title="View Source Code" >(src)</a>.
</p>
<a name="namespaceImports_2"></a>
<h4>org.eclipse.xtext.naming.IQualifiedNameProvider</h4>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider" >ImportedNamespaceAwareLocalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java" title="View Source Code" >(src)</a> 
makes use of the so called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/IQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider" >IQualifiedNameProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java" title="View Source Code" >(src)</a> 
service. It computes <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/QualifiedName.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.QualifiedName" >QualifiedNames</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/QualifiedName.java" title="View Source Code" >(src)</a> for 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObjects</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>. A qualified name consists of several segments
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider" >default implementation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.java" title="View Source Code" >(src)</a> uses 
a simple name look up composes the qualified name of the simple names of all containers and the object
itself. 
</p>
<p>
It also allows to override the name computation declaratively. The following snippet shows how you could 
make <em>Transitions</em> in the state machine example referable by giving them a name. Don&apos;t forget to bind 
your implementation in your runtime module. 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
FowlerDslQualifiedNameProvider&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">extends</span>&nbsp;DefaultDeclarativeQualifiedNameProvider&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;QualifiedName&nbsp;qualifiedName(Transition&nbsp;t)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(t.getEvent()&nbsp;==&nbsp;<span class="keyword">null</span>&nbsp;||!(t.eContainer()&nbsp;<span class="keyword">instanceof</span>&nbsp;State))&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">null</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;QualifiedName.create((State)t.eContainer()).getName(),&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.getEvent().getName());<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<a name="namespaceImports_3"></a>
<h4>Importing Namespaces</h4>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider" >ImportedNamespaceAwareLocalScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java" title="View Source Code" >(src)</a> looks up 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EAttribute.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EAttribute" >EAttributes</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java" title="View Source Code" >(src)</a> with name &apos;importedNamespace&apos; and 
interprets them as import statements. By default qualified names with or without a wildcard at the end 
are supported. For an import of a qualified name the simple name is made available as we know from e.g. 
Java, where
</p>
<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;java.util.Set;</span>
</p>
<p>
makes it possible to refer to <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Set.html" title="View JavaDoc"><abbr title="java.util.Set" >java.util.Set</abbr></a> by its simple name <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Set.html" title="View JavaDoc"><abbr title="java.util.Set" >Set</abbr></a>.
Contrary to Java the import is not active for the whole file but only for the namespace it is declared 
in and its child namespaces. That is why you can write the following in the example DSL:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;foo&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">import</span>&nbsp;bar.Foo<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Bar&nbsp;<span class="keyword">extends</span>&nbsp;Foo&nbsp;{<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">package</span>&nbsp;bar&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Foo&nbsp;{}<br/>
}
</p>
</div>
</div>
</p>
<p>
Of course the declared elements within a package are as well referable by their simple name:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;bar&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Bar&nbsp;<span class="keyword">extends</span>&nbsp;Foo&nbsp;{}<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Foo&nbsp;{}<br/>
}
</p>
</div>
</div>
</p>
<p>
The following would as well be ok:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;bar&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Bar&nbsp;<span class="keyword">extends</span>&nbsp;bar.Foo&nbsp;{}<br/>
&nbsp;&nbsp;<span class="keyword">entity</span>&nbsp;Foo&nbsp;{}<br/>
}
</p>
</div>
</div>
</p>
<p>
See the JavaDocs and <a href="http://blogs.itemis.de/stundzig/archives/773">this blog post</a> 
for details.
</p>
<a name="valueconverter"></a>
<h2>Value Converter</h2>
<p>
Value converters are registered to convert the parsed text into a data type instance and vice versa.
The primary hook is the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/IValueConverterService.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.IValueConverterService" >IValueConverterService</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverterService.java" title="View Source Code" >(src)</a> 
and the concrete implementation can be registered via the runtime <a href="030-generator.html#guicemodules" title="Go to &quot;The Module API&quot;">Guice module</a>.
Simply override the corresponding binding in your runtime module like shown in this example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Override<br/>
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;IValueConverterService&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bindIValueConverterService()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;MySpecialValueConverterService.<span class="keyword">class</span>;<br/>
}
</p>
</div>
</div>
</p>
<p>
The most simple way to register additional value converters is to make use of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/impl/AbstractDeclarativeValueConverterService.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.impl.AbstractDeclarativeValueConverterService" >AbstractDeclarativeValueConverterService</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractDeclarativeValueConverterService.java" title="View Source Code" >(src)</a>, 
which allows to declaratively register an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/IValueConverter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.IValueConverter" >IValueConverter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java" title="View Source Code" >(src)</a>
by means of an annotated method.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@ValueConverter(rule&nbsp;=&nbsp;<span class="string">"MyRuleName"</span>)<br/>
<span class="keyword">public</span>&nbsp;IValueConverter&lt;MyDataType&gt;&nbsp;getMyRuleNameConverter()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;MyValueConverterImplementation();<br/>
}
</p>
</div>
</div>
</p>
<p>
If you use the common terminals grammar <span class="inlinecode">org.eclipse.xtext.common.Terminals</span> you should extend the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/common/services/DefaultTerminalConverters.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.services.DefaultTerminalConverters" >DefaultTerminalConverters</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/services/DefaultTerminalConverters.java" title="View Source Code" >(src)</a> and override or 
add value converters by adding the respective methods. In addition to the explicitly 
defined converters in the default implementation, a delegating converter is registered for each 
available <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EDataType.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EDataType" >EDataType</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EDataType.java" title="View Source Code" >(src)</a>. The delegating converter reuses the functionality of the corresponding EMF 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EFactory.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EFactory" >EFactory</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EFactory.java" title="View Source Code" >(src)</a>.
</p>
<p>
Many languages introduce a concept for qualified names, i.e. names composed of namespaces separated by
a delimiter. Since this is such a common use case, Xtext provides an extensible converter implementation
for qualified names. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/impl/QualifiedNameValueConverter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.impl.QualifiedNameValueConverter" >QualifiedNameValueConverter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/QualifiedNameValueConverter.java" title="View Source Code" >(src)</a> handles
comments and white space gracefully and is capable to use the appropriate value converter for each segment of
a qualified name. This allows for individually quoted segments. The domainmodel example shows how to use it. 
</p>
<p>
The protocol of an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/IValueConverter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.IValueConverter" >IValueConverter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java" title="View Source Code" >(src)</a> allows to throw a 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/ValueConverterException.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.ValueConverterException" >ValueConverterException</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/ValueConverterException.java" title="View Source Code" >(src)</a> if something went wrong.
The exception is propagated as a syntax error by the parser or as a validation problem by the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/validation/impl/ConcreteSyntaxValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.impl.ConcreteSyntaxValidator" >ConcreteSyntaxValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxValidator.java" title="View Source Code" >(src)</a> if the value cannot be converted 
to a valid string. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/impl/AbstractLexerBasedConverter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.impl.AbstractLexerBasedConverter" >AbstractLexerBasedConverter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractLexerBasedConverter.java" title="View Source Code" >(src)</a> is useful when 
implementing a custom value converter. If the converter needs to know about the rule that it currently 
works with, it may implement the interface <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/IValueConverter.RuleSpecific.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.IValueConverter.RuleSpecific" >IValueConverter.RuleSpecific</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java" title="View Source Code" >(src)</a>. 
The framework will set the rule such as the implementation may use it afterwards.
</p>
<a name="serialization"></a>
<h2>Serialization</h2>
<p>
Serialization is the process of transforming an EMF model into its textual representation. Thereby, 
serialization complements parsing and lexing.
</p>
<p>
In Xtext, the process of serialization is split into the following steps:
</p>
<p>
<ol>
	<li>
		Validating the semantic model. This is optional, enabled by default, done by the 
		     <a href="050-heading-runtime.html#concrete_syntax_validation" title="Go to &quot;Serializer: Concrete Syntax Validation&quot;">concrete syntax validator</a> and can be turned off in 
		     the <a href="050-heading-runtime.html#saveoptions" title="Go to &quot;Options&quot;">save options</a>.
	</li>
	<li>
		Matching the model elements with the grammar rules and creating a stream of tokens. 
		     This is done by the <a href="050-heading-runtime.html#parsetreeconstructor" title="Go to &quot;Parse Tree Constructor&quot;">parse tree constructor</a>.
	</li>
	<li>
		Associating comments with semantic objects. This is done by the
		     <a href="050-heading-runtime.html#commentassociater" title="Go to &quot;Preserving Comments from the Node Model&quot;">comment associator</a>.
	</li>
	<li>
		Associating existing nodes from the node model with tokens from the token stream.
	</li>
	<li>
		<a href="050-heading-runtime.html#hiddentokenmerger" title="Go to &quot;Merge White Space&quot;">Merging existing white space</a> and line-wraps into the token stream.
	</li>
	<li>
		Adding further needed white space or replacing all white space using a 
		    <a href="050-heading-runtime.html#formatting" title="Go to &quot;Formatting (Pretty Printing)&quot;">formatter</a>.
	</li>
</ol>
</p>
<p>
Serialization is invoked when calling 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/XtextResource.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.XtextResource" >XtextResource.save(..)</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java" title="View Source Code" >(src)</a>. Furthermore, the
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/Serializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.Serializer" >Serializer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java" title="View Source Code" >(src)</a> provides resource-independent 
support for serialization. Another situation that triggers serialization is applying <a href="120-heading-UI.html#quickfixes" title="Go to &quot;Quick Fixes&quot;">quick fixes</a> 
with semantic modifications. Serialization is <em>not</em> called when a textual editors contents is saved to disk.
</p>
<a name="serializationcontract"></a>
<h3>The Contract</h3>
<p>
The contract of serialization says that a model which is saved (serialized) to its textual representation 
and then loaded (parsed) again yields a new model that is equal to the original model. Please be 
aware that this does <em>not</em> imply, that loading a textual representation and serializing it back produces 
identical textual representations. However, the serialization algorithm tries to restore as much information
as possible. That is, if the parsed model was not modified in-memory, the serialized output will usually
be equal to the previous input. Unfortunately, this cannot be ensured for each and every case. A use
case where is is hardly possible, is shown in the following example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
MyRule:<br/>
&nbsp;&nbsp;(xval+=ID&nbsp;|&nbsp;yval+=INT)*;
</p>
</div>
</div>
</p>
<p>
The given <em>MyRule</em> reads <em>ID</em>- and <em>INT</em>-elements which may occur in an arbitrary order in 
the textual representation. However, when serializing the model all <em>ID</em>-elements will be written 
first and then all <em>INT</em>-elements. If the order is important it can be preserved by storing all elements 
in the same list - which may require wrapping the <em>ID</em>- and <em>INT</em>-elements into other objects.
</p>
<a name="serialization_6"></a>
<h3>Roles of the Semantic Model and the Node Model During Serialization</h3>
<p>
A serialized document represents the state of the semantic model. However, if there is a node model 
available (i.e. the semantic model has been created by the parser), the serializer
<ul>
	<li>
		preserves <a href="050-heading-runtime.html#hiddentokenmerger" title="Go to &quot;Merge White Space&quot;">existing white spaces</a> from the node model.
	</li>
	<li>
		preserves <a href="050-heading-runtime.html#commentassociater" title="Go to &quot;Preserving Comments from the Node Model&quot;">existing comments</a> from the node model.
	</li>
	<li>
		preserves the representation of cross-references: If a cross-referenced object can be 
		     identified by multiple names (i.e. scoping returns multiple 
		     <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IEObjectDescription.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IEObjectDescription" >IEObjectDescriptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java" title="View Source Code" >(src)</a> for the 
		     same object), the serializer tries to keep the name that was used in the input file.
	</li>
	<li>
		preserves the representation of values: For values handled by the 
		    <a href="050-heading-runtime.html#valueconverter" title="Go to &quot;Value Converter&quot;">value converter</a>, the serializer checks whether the textual representation 
		    converted to a value equals the value from the semantic model. If that is true, the textual 
		    representation is kept.
	</li>
</ul>
</p>
<a name="parsetreeconstructor"></a>
<h3>Parse Tree Constructor</h3>
<p>
The parse tree constructor usually does not need to be customized since it is automatically derived 
from the <a href="020-grammar-language.html#grammarLanguage" title="Go to &quot;The Grammar Language&quot;">Xtext Grammar</a>. However, it can be helpful to look into it to understand 
its error messages and its runtime performance.
</p>
<p>
For serialization to succeed, the parse tree constructor must be able to <em>consume</em> every non-transient 
element of the to-be-serialized EMF model. To <em>consume</em> means, in this context, to write the element to 
the textual representation of the model. This can turn out to be a not-so-easy-to-fulfill requirement, 
since a grammar usually introduces implicit constraints to the EMF model as explained for the 
<a href="050-heading-runtime.html#concrete_syntax_validation" title="Go to &quot;Serializer: Concrete Syntax Validation&quot;">concrete syntax validator</a>.
</p>
<p>
If a model can not be serialized, an 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/XtextSerializationException.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.XtextSerializationException" >XtextSerializationException</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/XtextSerializationException.java" title="View Source Code" >(src)</a> is thrown. 
Possible reasons are listed below:
</p>
<p>
<ul>
	<li>
		A model element can not be consumed. This can have the following reasons/solutions:
		    <ul>
			<li>
				The model element should not be stored in the model.
			</li>
			<li>
				The grammar needs an assignment which would consume the model element.
			</li>
			<li>
				The <a href="050-heading-runtime.html#transientvalues" title="Go to &quot;Transient Values&quot;">transient value service</a> can be used to indicate that this model 
				      element should not be consumed.
			</li>
		</ul>
		
	</li>
	<li>
		An assignment in the grammar has no corresponding model element. The default transient 
		    value service considers a model element to be transient if it is <em>unset</em> or <em>equals</em> its 
		    default value. However, the parse tree constructor may serialize default values if 
		    this is required by a grammar constraint to be able to serialize another model element.
		    The following solution may help to solve such a scenario:
		    <ul>
			<li>
				A model element should be added to the model.
			</li>
			<li>
				The assignment in the grammar should be made optional.
			</li>
		</ul>
		
	</li>
	<li>
		The type of the model element differs from the type in the grammar. The type of the model 
		    element must be identical to the return type of the grammar rule or the action&apos;s type. 
		    Subtypes are not allowed.
	</li>
	<li>
		<a href="050-heading-runtime.html#valueconverter" title="Go to &quot;Value Converter&quot;">Value conversion</a> fails. The value converter can indicate that a value 
		    is not serializable by throwing a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/conversion/ValueConverterException.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.conversion.ValueConverterException" >ValueConverterException</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/ValueConverterException.java" title="View Source Code" >(src)</a>.
	</li>
	<li>
		An enum literal is not allowed at this position. This can happen if the referenced enum 
		    rule only lists a subset of the literals of the actual enumeration.
	</li>
</ul>
</p>
<p>
To understand error messages and performance issues of the parse tree constructor it is important to 
know that it implements a backtracking algorithm. This basically means that the grammar is used to 
specify the structure of a tree in which one path (from the root node to a leaf node) is a valid 
serialization of a specific model. The parse tree constructor&apos;s task is to find this path - with the 
condition, that all model elements are consumed while walking this path. The parse tree constructor&apos;s 
strategy is to take the most promising branch first (the one that would consume the most model elements). 
If the branch leads to a dead end (for example, if a model element needs to be consumed that is not 
present in the model), the parse tree constructor goes back the path until a different branch can be 
taken. This behavior has two consequences:
<ul>
	<li>
		In case of an error, the parse tree constructor has found only dead ends but no leaf. It cannot
		    tell which dead end is actually erroneous. Therefore, the error message lists dead ends of the 
		    longest paths, a fragment of their serialization and the reason why the path could not be continued 
		    at this point. The developer has to judge on his own which reason is the actual error.
	</li>
	<li>
		For reasons of performance, it is critical that the parse tree constructor takes the most promising
		    branch first and detects wrong branches early. One way to achieve this is to avoid having many rules 
		    which return the same type and which are called from within the same alternative in the grammar.
	</li>
</ul>
</p>
<a name="saveoptions"></a>
<h3>Options</h3>
<p>
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/SaveOptions.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.SaveOptions" >SaveOptions</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/SaveOptions.java" title="View Source Code" >(src)</a> can be passed to 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/XtextResource.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.XtextResource" >XtextResource.save(options)</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java" title="View Source Code" >(src)</a> and to 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/Serializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.Serializer" >Serializer.serialize(..)</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java" title="View Source Code" >(src)</a>. 
Available options are:
<ul>
	<li>
		<em>Formatting</em>. Default: <span class="inlinecode"><span class="keyword">false</span></span>. If enabled, it is the <a href="050-heading-runtime.html#formatting" title="Go to &quot;Formatting (Pretty Printing)&quot;">formatters</a> job to determine
		     all white space information during serialization. If disabled, the formatter only defines white
		     space 
		     information for the places in which no white space information can be preserved from the node model. 
		     E.g. When new model elements are inserted or there is no node model.
	</li>
	<li>
		<em>Validating</em>. Default: <span class="inlinecode"><span class="keyword">true</span></span>: Run the <a href="050-heading-runtime.html#concrete_syntax_validation" title="Go to &quot;Serializer: Concrete Syntax Validation&quot;">concrete syntax validator</a> 
		    before serializing the model.
	</li>
</ul>
</p>
<a name="commentassociater"></a>
<h3>Preserving Comments from the Node Model</h3>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/ICommentAssociater.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.ICommentAssociater" >ICommentAssociater</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ICommentAssociater.java" title="View Source Code" >(src)</a> associates 
comments with semantic objects. This is important in case an element in the semantic model is moved 
to a different position and the model is serialized, one expects the comments to be moved to the 
new position in the document as well.
</p>
<p>
Which comment belongs to which semantic object is surely a very subjective issue. The 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/impl/DefaultCommentAssociater.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.impl.DefaultCommentAssociater" >default 
implementation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/DefaultCommentAssociater.java" title="View Source Code" >(src)</a>
behaves as follows, but can be customized:
<ul>
	<li>
		If there is a semantic token before a comment and in the same line, the comment is associated 
		    with this token&apos;s semantic object.
	</li>
	<li>
		In all other cases, the comment is associated with the semantic object of the next following 
		    object.
	</li>
</ul>
</p>
<a name="transientvalues"></a>
<h3>Transient Values</h3>
<p>
Transient values are values or model elements which are not persisted (written to the textual 
representation in the serialization phase). If a model contains model elements which can not be serialized 
with the current grammar, it is critical to mark them transient using the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/ITransientValueService.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.ITransientValueService" >ITransientValueService</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITransientValueService.java" title="View Source Code" >(src)</a>, or serialization 
will fail. The default implementation marks all model elements transient, which are <span class="inlinecode">eStructuralFeature.isTransient()</span> 
or not <span class="inlinecode">eObject.eIsSet(eStructuralFeature)</span>. By default, EMF returns <span class="inlinecode"><span class="keyword">false</span></span> for <span class="inlinecode">eIsSet(..)</span> if the 
value equals the default value.    
</p>
<a name="unassignedtext"></a>
<h3>Unassigned Text</h3>
<p>
If there are calls of data type rules or terminal rules that do not reside in an assignment, 
the serializer by default doesn&apos;t know which value to use for serialization.  
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
PluralRule:<br/>
&nbsp;&nbsp;<span class="string">&apos;contents:&apos;</span>&nbsp;count=INT&nbsp;Plural;<br/>
&nbsp;&nbsp;<br/>
<span class="keyword">terminal</span>&nbsp;Plural:&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;item&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;items&apos;</span>;
</p>
</div>
</div>
</p>
<p>
Valid models for this example are <em>contents 1 item</em> or <em>contents 5 items</em>. However, it is not stored 
in the semantic model whether the keyword <em>item</em> or <em>items</em> has been parsed. This is due to the fact 
that the rule call <em>Plural</em> is unassigned. However, the <a href="050-heading-runtime.html#parsetreeconstructor" title="Go to &quot;Parse Tree Constructor&quot;">parse tree constructor</a> 
needs to decide which value to write during serialization. This decision can be be made by customizing 
the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.IValueSerializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.ITokenSerializer.IValueSerializer" >IValueSerializer.serializeUnassignedValue(EObject, RuleCall, INode)</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.java" title="View Source Code" >(src)</a>.
</p>
<a name="crossreferenceserializer"></a>
<h3>Cross-Reference Serializer</h3>
<p>
The cross-reference serializer specifies which values are to be written to the textual representation 
for cross-references. This behavior can be customized by implementing 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.ICrossReferenceSerializer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.ITokenSerializer.ICrossReferenceSerializer" >ITokenSerializer.ICrossReferenceSerializer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.java" title="View Source Code" >(src)</a>. 
The default implementation delegates to various other services such as the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/scoping/IScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.scoping.IScopeProvider" >IScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java" title="View Source Code" >(src)</a> or the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/linking/impl/LinkingHelper.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.linking.impl.LinkingHelper" >LinkingHelper</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/impl/LinkingHelper.java" title="View Source Code" >(src)</a> each of which may be the better place for customization.
</p>
<a name="hiddentokenmerger"></a>
<h3>Merge White Space</h3>
<p>
After the <a href="050-heading-runtime.html#parsetreeconstructor" title="Go to &quot;Parse Tree Constructor&quot;">parse tree constructor</a> has done its job to create a stream of 
tokens which are to be written to the textual representation, and the <a href="050-heading-runtime.html#commentassociater" title="Go to &quot;Preserving Comments from the Node Model&quot;">comment associator</a> 
has done its work, existing white space form the node model is merged into the stream. 
</p>
<p>
The strategy is as follows: If two tokens follow each other in the stream and the corresponding 
nodes in the node model follow each other as well, then the white space information in between is kept. 
In all other cases it is up to the <a href="050-heading-runtime.html#formatting" title="Go to &quot;Formatting (Pretty Printing)&quot;">formatter</a> to calculate new white space information. 
</p>
<a name="tokenstream"></a>
<h3>Token Stream</h3>
<p>
The <a href="050-heading-runtime.html#parsetreeconstructor" title="Go to &quot;Parse Tree Constructor&quot;">parse tree constructor</a> and the <a href="050-heading-runtime.html#formatting" title="Go to &quot;Formatting (Pretty Printing)&quot;">formatter</a> use an 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/ITokenStream.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.ITokenStream" >ITokenStream</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenStream.java" title="View Source Code" >(src)</a> for their output, and the 
latter for its input as well. This allows for chaining the two components. Token streams can be converted to a <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html" title="View JavaDoc"><abbr title="java.lang.String" >String</abbr></a> 
using the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/impl/TokenStringBuffer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.impl.TokenStringBuffer" >TokenStringBuffer</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/TokenStringBuffer.java" title="View Source Code" >(src)</a> and to 
a <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/Writer.html" title="View JavaDoc"><abbr title="java.io.Writer" >Writer</abbr></a> using the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parsetree/reconstr/impl/WriterTokenStream.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parsetree.reconstr.impl.WriterTokenStream" >WriterTokenStream</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/WriterTokenStream.java" title="View Source Code" >(src)</a>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;ITokenStream&nbsp;{<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">void</span>&nbsp;flush()&nbsp;<span class="keyword">throws</span>&nbsp;IOException;<br/>
&nbsp;&nbsp;<span class="keyword">void</span>&nbsp;writeHidden(EObject&nbsp;grammarElement,&nbsp;String&nbsp;value);<br/>
&nbsp;&nbsp;<span class="keyword">void</span>&nbsp;writeSemantic(EObject&nbsp;grammarElement,&nbsp;String&nbsp;value);<br/>
}
</p>
</div>
</div>
</p>
<a name="formatting"></a>
<h2>Formatting (Pretty Printing)</h2>
<p>
A formatter can be implemented via the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/IFormatter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.IFormatter" >IFormatter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IFormatter.java" title="View Source Code" >(src)</a> 
service. Technically speaking, a formatter is a <a href="050-heading-runtime.html#tokenstream" title="Go to &quot;Token Stream&quot;">Token Stream</a> which 
inserts/removes/modifies hidden tokens (white space, line-breaks, comments).
</p>
<p>
The formatter is invoked during the <a href="050-heading-runtime.html#serialization" title="Go to &quot;Serialization&quot;">serialization phase</a> and when the user triggers 
formatting in the editor (for example, using the CTRL+SHIFT+F shortcut).
</p>
<p>
Xtext ships with two formatters:
<ul>
	<li>
		The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/OneWhitespaceFormatter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.OneWhitespaceFormatter" >OneWhitespaceFormatter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/OneWhitespaceFormatter.java" title="View Source Code" >(src)</a> simply writes one 
		    white space between all tokens.
	</li>
	<li>
		The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter" >AbstractDeclarativeFormatter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java" title="View Source Code" >(src)</a> allows advanced 
		    configuration using a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/FormattingConfig.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.FormattingConfig" >FormattingConfig</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java" title="View Source Code" >(src)</a>. Both are explained
		    below.
	</li>
</ul>
</p>
<p>
A declarative formatter can be implemented by subclassing 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter" >AbstractDeclarativeFormatter</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java" title="View Source Code" >(src)</a>, as shown in 
the following example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ExampleFormatter&nbsp;<span class="keyword">extends</span>&nbsp;AbstractDeclarativeFormatter&nbsp;{<br/>
<br/>
&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;<span class="keyword">void</span>&nbsp;configureFormatting(FormattingConfig&nbsp;c)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ExampleLanguageGrammarAccess&nbsp;f&nbsp;=&nbsp;getGrammarAccess();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setAutoLinewrap(120);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;find&nbsp;common&nbsp;keywords&nbsp;an&nbsp;specify&nbsp;formatting&nbsp;for&nbsp;them<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(Pair&lt;Keyword,&nbsp;Keyword&gt;&nbsp;pair&nbsp;:&nbsp;f.findKeywordPairs(<span class="string">"("</span>,&nbsp;<span class="string">")"</span>))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().after(pair.getFirst());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(pair.getSecond());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(Keyword&nbsp;comma&nbsp;:&nbsp;f.findKeywords(<span class="string">","</span>))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(comma);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;Line<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap(2).after(f.getLineAccess().getSemicolonKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().before(f.getLineAccess().getSemicolonKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;TestIndentation<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;c.setIndentationIncrement().after(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setIndentationDecrement().before(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap().after(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setLinewrap().after(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;formatting&nbsp;for&nbsp;grammar&nbsp;rule&nbsp;Param<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;c.setNoLinewrap().around(f.getParamAccess().getColonKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.setNoSpace().around(f.getParamAccess().getColonKeyword_1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;formatting&nbsp;for&nbsp;Comments&nbsp;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;2).before(g.getSL_COMMENTRule());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;2).before(g.getML_COMMENTRule());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cfg.setLinewrap(0,&nbsp;1,&nbsp;1).after(g.getML_COMMENTRule());<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
The formatter has to implement the method <span class="inlinecode">configureFormatting(...)</span> which declaratively sets up 
a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/FormattingConfig.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.FormattingConfig" >FormattingConfig</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java" title="View Source Code" >(src)</a>.
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/impl/FormattingConfig.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.impl.FormattingConfig" >FormattingConfig</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java" title="View Source Code" >(src)</a> consist of general 
settings and a set of formatting instructions:
</p>
<a name="formatting_8"></a>
<h3>General FormattingConfig Settings</h3>
<p>
<span class="inlinecode">setAutoLinewrap(<span class="keyword">int</span>)</span> defines the amount of characters after which a line-break should 
be dynamically inserted between two tokens. The instructions <span class="inlinecode">setNoLinewrap().???()</span>, 
<span class="inlinecode">setNoSpace().???()</span> and <span class="inlinecode">setSpace(space).???()</span> suppress this behavior locally. 
The default is 80.
</p>
<a name="formatting_9"></a>
<h3>FormattingConfig Instructions</h3>
<p>
Per default, the declarative formatter inserts one white space between two 
tokens. Instructions can be used to specify a different behavior. They consist of two parts: <em>When</em> 
to apply the instruction and <em>what</em> to do.
</p>
<p>
To understand <em>when</em> an instruction is applied think of a stream of tokens whereas each token is 
associated with the corresponding grammar element. The instructions are matched against these grammar 
elements. The following matching criteria exist:
<ul>
	<li>
		<span class="inlinecode">after(element)</span>: The instruction is applied after the grammar element has been matched. 
		    For example, if your grammar uses the keyword <span class="inlinecode"><span class="string">";"</span></span> to end lines, this can instruct the formatter 
		    to insert a line break after the semicolon.
	</li>
	<li>
		<span class="inlinecode">before(element)</span>: The instruction is executed before the matched element. For example, if your 
		    grammar contains lists which separate their values with the keyword <span class="inlinecode"><span class="string">","</span></span>, you can instruct the 
		    formatter to suppress the white space before the comma.
	</li>
	<li>
		<span class="inlinecode">around(element)</span>: This is the same as <span class="inlinecode">before(element)</span> combined with <span class="inlinecode">after(element)</span>.
	</li>
	<li>
		<span class="inlinecode">between(left,&nbsp;right)</span>: This matches if <em>left</em> directly follows <em>right</em> in the document. 
		    There may be no other tokens in between <em>left</em> and <em>right</em>.
	</li>
	<li>
		<span class="inlinecode">bounds(left,&nbsp;right)</span>: This is the same as <span class="inlinecode">after(left)</span> combined with  <span class="inlinecode">before(right)</span>.
	</li>
	<li>
		<span class="inlinecode">range(start,&nbsp;end)</span>: The rule is enabled when <em>start</em> is matched, and disabled when <em>end</em> 
		    is matched. Thereby, the rule is active for the complete region which is surrounded by <em>start</em> 
		    and <em>end</em>.
	</li>
</ul>
</p>
<p>
The term <em>tokens</em> is used slightly different here compared to the parser/lexer. Here, a token is a 
keyword or the string that is matched by a terminal rule, data type rule or cross-reference. In the 
terminology of the lexer a data type rule can match a composition of multiple tokens.
</p>
<p>
The parameter <em>element</em> can be a grammar&apos;s <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/AbstractElement.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.AbstractElement" >AbstractElement</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/emf-gen/org/eclipse/xtext/AbstractElement.java" title="View Source Code" >(src)</a> or a grammar&apos;s 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/AbstractRule.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.AbstractRule" >AbstractRule</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/emf-gen/org/eclipse/xtext/AbstractRule.java" title="View Source Code" >(src)</a>. All grammar 
rules and almost all abstract elements can be matched. This includes rule calls, parser rules, groups 
and alternatives. The semantic of <span class="inlinecode">before(element)</span>, <span class="inlinecode">after(element)</span>, etc. for rule calls and parser rules is 
identical to when the parser would "pass" this part of the grammar. The stack of called rules is taken 
into account. The following abstract elements can <em>not</em> have assigned formatting instructions:
<ul>
	<li>
		Actions. E.g. <span class="inlinecode">{MyAction}</span> or <span class="inlinecode">{MyAction.myFeature=<span class="keyword">current</span>}</span>.
	</li>
	<li>
		Grammar elements nested in data type rules. This is due to to the fact that tokens matched 
		    by a data type rule are treated as atomic by the serializer. To format these tokens, please 
		    implement a <a href="050-heading-runtime.html#valueconverter" title="Go to &quot;Value Converter&quot;">ValueConverter</a>. 
	</li>
	<li>
		Grammar elements nested in <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/CrossReference.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.CrossReference" >CrossReference</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/emf-gen/org/eclipse/xtext/CrossReference.java" title="View Source Code" >(src)</a>.
	</li>
</ul>
</p>
<p>
After having explained how rules can be activated, this is what they can do:
<ul>
	<li>
		<span class="inlinecode">setIndentationIncrement()</span> increments indentation by one unit at this position. Whether 
		    one unit consists of one tab-character or spaces is defined by 
		    <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/formatting/IIndentationInformation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.formatting.IIndentationInformation" >IIndentationInformation</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IIndentationInformation.java" title="View Source Code" >(src)</a>. The default implementation 
		    consults Eclipse&apos;s <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferenceStore.html" title="View JavaDoc"><abbr title="org.eclipse.jface.preference.IPreferenceStore" >IPreferenceStore</abbr></a>.
	</li>
	<li>
		<span class="inlinecode">setIndentationDecrement()</span> decrements indentation by one unit.
	</li>
	<li>
		<span class="inlinecode">setLinewrap()</span>: Inserts a line-wrap at this position.
	</li>
	<li>
		<span class="inlinecode">setLinewrap(<span class="keyword">int</span>&nbsp;count)</span>: Inserts <em>count</em> numbers of line-wrap at this position.
	</li>
	<li>
		<span class="inlinecode">setLinewrap(<span class="keyword">int</span>&nbsp;min,&nbsp;<span class="keyword">int</span>&nbsp;def,&nbsp;<span class="keyword">int</span>&nbsp;max)</span>: If the amount of line-wraps that have been 
		    at this position before formatting can be determined (i.e. when a node model is present), 
		    then the amount of of line-wraps is adjusted to be within the interval <em>min</em>, <em>max</em> 
		    and is then reused. In all other cases <em>def</em> line-wraps are inserted. Example: 
		    <span class="inlinecode">setLinewrap(0,&nbsp;0,&nbsp;1)</span> will preserve existing line-wraps, but won&apos;t allow more than one 
		    line-wrap between two tokens.
	</li>
	<li>
		<span class="inlinecode">setNoLinewrap()</span>: Suppresses automatic line wrap, which may occur when the line&apos;s length 
		    exceeds the defined limit.
	</li>
	<li>
		<span class="inlinecode">setSpace(String&nbsp;space)</span>: Inserts the string <em>space</em> at this position. If you use this 
		    to insert something else than white space, tabs or newlines, a small puppy will die somewhere 
		    in this world.
	</li>
	<li>
		<span class="inlinecode">setNoSpace()</span>: Suppresses the white space between tokens at this position. Be aware that 
		    between some tokens a white space is required to maintain a valid concrete syntax.
	</li>
</ul>
</p>
<a name="formatting_10"></a>
<h3>Grammar Element Finders</h3>
<p>
Sometimes, if a grammar contains many similar elements for which the same formatting instructions ought 
to apply, it can be tedious to specify them for each grammar element individually. The 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/IGrammarAccess.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.IGrammarAccess" >IGrammarAccess</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/IGrammarAccess.java" title="View Source Code" >(src)</a> provides convenience methods for this. The 
find methods are available for the grammar and for each parser rule.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">findKeywords(String...&nbsp;keywords)</span> returns all keywords that equal one of the parameters.
	</li>
	<li>
		<span class="inlinecode">findKeywordPairs(String&nbsp;leftKw,&nbsp;String&nbsp;rightKw)</span>: returns tuples of keywords from the same 
		    grammar rule. Pairs are matched nested and sequentially.  Example: for <span class="inlinecode">Rule:&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;name=ID&nbsp;(<span class="string">&apos;(&apos;</span>&nbsp;foo=ID&nbsp;<span class="string">&apos;)&apos;</span>)&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;bar=ID&nbsp;<span class="string">&apos;)&apos;</span></span> 
		    <span class="inlinecode">findKeywordPairs(<span class="string">"("</span>,&nbsp;<span class="string">")"</span>)</span> returns three pairs.
	</li>
</ul>
</p>
<a name="fragmentProvider"></a>
<h2>Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)</h2>
<p>
Although inter-Xtext linking is not done by URIs, you may want to be able to reference your <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> 
from non-Xtext models. In those cases URIs are used, which are made up of a part identifying the resource 
and a second part that points to an object. 
Each <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> contained in a resource can be identified by a so called <em>fragment</em>.
</p>
<p>
A fragment is a part of an EMF URI and needs to be unique per resource.
</p>
<p>
The generic resource shipped with EMF provides a generic path-like computation of fragments. These 
fragment paths are unique by default and do not have to be serialized. On the other hand, they can be 
easily broken by reordering the elements in a resource. 
</p>
<p>
With an XMI or other binary-like serialization it is also common and possible to use UUIDs. UUIDs 
are usually binary and technical, so you don&apos;t want to deal with them in human readable representations.
</p>
<p>
However with a textual concrete syntax we want to be able to compute fragments out of the human readable 
information. We don&apos;t want to force people to use UUIDs (i.e. synthetic identifiers) or fragile, relative, generic 
paths in order to refer to <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObjects</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a>.
</p>
<p>
Therefore one can contribute an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IFragmentProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IFragmentProvider" >IFragmentProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java" title="View Source Code" >(src)</a> 
per language. It has two methods: <span class="inlinecode">getFragment(EObject,&nbsp;Fallback)</span> to calculate the fragment of an 
<a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EObject" >EObject</abbr></a> <a class="srcLink" href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java" title="View Source Code" >(src)</a> and <span class="inlinecode">getEObject(Resource,&nbsp;String,&nbsp;Fallback)</span> to go the opposite direction. 
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/IFragmentProvider.Fallback.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.IFragmentProvider.Fallback" >IFragmentProvider.Fallback</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java" title="View Source Code" >(src)</a> interface allows to delegate to the default strategy - 
which usually uses the fragment paths described above. 
</p>
<p>
The following snippet shows how to use qualified names as fragments:   
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;QualifiedNameFragmentProvider&nbsp;<span class="keyword">implements</span>&nbsp;IFragmentProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;@Inject<br/>
&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;IQualifiedNameProvider&nbsp;qualifiedNameProvider;<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;String&nbsp;getFragment(EObject&nbsp;obj,&nbsp;Fallback&nbsp;fallback)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;qName&nbsp;=&nbsp;qualifiedNameProvider.getQualifiedName(obj);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;qName&nbsp;!=&nbsp;<span class="keyword">null</span>&nbsp;?&nbsp;qName&nbsp;:&nbsp;fallback.getFragment(obj);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;EObject&nbsp;getEObject(Resource&nbsp;resource,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fragment,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fallback&nbsp;fallback)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(fragment&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;EObject&gt;&nbsp;i&nbsp;=&nbsp;EcoreUtil.getAllContents(resource,&nbsp;<span class="keyword">false</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(i.hasNext())&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;eObject&nbsp;=&nbsp;i.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;candidateFragment&nbsp;=&nbsp;(eObject.eIsProxy())&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;((InternalEObject)&nbsp;eObject).eProxyURI().fragment()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;getFragment(eObject,&nbsp;fallback);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(fragment.equals(candidateFragment))&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;eObject;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;fallback.getEObject(fragment);<br/>
&nbsp;&nbsp;}<br/>
}
</p>
</div>
</div>
</p>
<p>
For performance reasons it is usually a good idea to navigate the resource based on the fragment 
information instead of traversing it completely. If you know that your fragment is computed from 
qualified names and your model contains something like <em>NamedElements</em>, you should split your fragment
into those parts and query the root elements, the children of the best match and so on.
</p>
<p>
Furthermore it&apos;s a good idea to have some kind of conflict resolution strategy to be able to distinguish
between equally named elements that actually are different, e.g. properties may have the very same qualified
name as entities. 
</p>
<a name="encoding"></a>
<h2>Encoding in Xtext</h2>
<p>
Encoding, aka <em>character set</em>, describes the way characters are encoded into bytes and vice versa. 
Famous standard encodings are <em>UTF-8</em> or <em>ISO-8859-1</em>. The list of available encodings can be determined
by calling <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html" title="View JavaDoc"><abbr title="java.nio.charset.Charset" >Charset.availableCharsets()</abbr></a>. There is also a list of encodings and their 
canonical Java names in the <a href="http://download.oracle.com/javase/1.5.0/docs/guide/intl/encoding.doc.html">API docs</a>.
</p>
<p>
Unfortunately, each platform and/or spoken language tends to define its own native encoding, 
e.g. <em>Cp1258</em> on Windows in Vietnamese or <em>MacIceland</em> on Mac OS X in Icelandic. 
</p>
<p>
In an Eclipse workspace, files, folders, projects can have individual encodings, which are stored
in the hidden file <em>.settings/org.eclipse.core.resources.prefs</em> in each project. If a resource does not have an 
explicit encoding, it inherits the one from its parent recursively. Eclipse chooses the native
platform encoding as the default for the workspace root. You can change the default workspace 
encoding in the Eclipse preferences <em>Preferences-&gt;Workspace-&gt;Default text encoding</em>. If you develop on
different platforms, you should consider choosing an explicit common encoding for your text or code
files, especially if you use special characters. 
</p>
<p>
While Eclipse allows to define and inspect the encoding of a file, your file system usually doesn&apos;t. 
Given an arbitrary text file there is no general strategy to tell how it was encoded. If you deploy 
an Eclipse project as a jar (even a plug-in), any encoding information not stored in the file itself 
is lost, too. Some languages define the encoding of a file explicitly, as in the first processing 
instruction of an XML file. Most languages don&apos;t. Others imply a fixed encoding or offer enhanced 
syntax for character literals, e.g. the unicode escape sequences <em>\uXXXX</em> in Java. 
</p>
<p>
As Xtext is about textual modeling, it allows to tweak the encoding in various places.
</p>
<a name="encoding_6"></a>
<h3>Encoding at Language Design Time</h3>
<p>
The plug-ins created by the <em>New Xtext Project</em> wizard are by default encoded in the workspace&apos;s standard
encoding. The same holds for all files that Xtext generates in there.
If you want to change that, e.g. because your grammar uses/allows special characters, you should manually 
set the encoding in the properties of these projects after their creation. Do this before 
adding special characters to your grammar or at least make sure the grammar reads correctly after the 
encoding change. To tell the Xtext generator to generate files in the same encoding, set the encoding 
property in the workflow next to your grammar, e.g.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Generator&nbsp;{<br/>
&nbsp;&nbsp;encoding&nbsp;=<span class="string">"UTF-8"</span><br/>
&nbsp;&nbsp;...
</p>
</div>
</div>
</p>
<a name="encoding_7"></a>
<h3>Encoding at Language Runtime</h3>
<p>
As each language could handle the encoding problem differently, Xtext offers a service here. 
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parser/IEncodingProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parser.IEncodingProvider" >IEncodingProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java" title="View Source Code" >(src)</a> has a single method 
<span class="inlinecode">getEncoding(URI)</span> to define the encoding of the resource with the given URI. Users can implement 
their own strategy but keep in mind that this is not intended to be a long running method. If the 
encoding is stored within the model file itself, it should be extractable in an easy way, like from 
the first line in an XML file. The default implementation returns the default Java character set 
in the runtime scenario. 
</p>
<p>
In the UI scenario, when there is a workspace, users will expect the encoding of the model files 
to be settable the same way as for other files in the workspace. The default implementation 
of the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parser/IEncodingProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parser.IEncodingProvider" >IEncodingProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java" title="View Source Code" >(src)</a> in the UI scenario therefore returns 
the file&apos;s workspace encoding for files in the workspace and delegates to the runtime implementation 
for all other resources, e.g. models in a jar or from a deployed plug-in. Keep in mind that you are 
going to loose the workspace encoding information as soon as you leave this workspace, e.g. deploy your 
project.
</p>
<p>
Unless you want to enforce a uniform encoding for all models of your language, we advise to 
override the runtime service only. It is bound in the runtime module using the binding annotation 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/service/DispatchingProvider.Runtime.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.service.DispatchingProvider.Runtime" >@Runtime</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/service/DispatchingProvider.java" title="View Source Code" >(src)</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Override<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;configureRuntimeEncodingProvider(Binder&nbsp;binder)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;binder.bind(IEncodingProvider.<span class="keyword">class</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.annotatedWith(DispatchingProvider.Runtime.<span class="keyword">class</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.to(MyEncodingProvider.<span class="keyword">class</span>);<br/>
}
</p>
</div>
</div>
</p>
<p>
For the uniform encoding, bind the plain <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parser/IEncodingProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parser.IEncodingProvider" >IEncodingProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java" title="View Source Code" >(src)</a> to the same
implementation in both modules:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Override<br/>
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;IEncodingProvider&gt;&nbsp;bindIEncodingProvider()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;MyEncodingProvider.<span class="keyword">class</span>;<br/>
}
</p>
</div>
</div>
</p>
<a name="encoding_8"></a>
<h3>Encoding of an XtextResource</h3>
<p>
An <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/resource/XtextResource.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.resource.XtextResource" >XtextResource</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java" title="View Source Code" >(src)</a> uses the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/parser/IEncodingProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.parser.IEncodingProvider" >IEncodingProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java" title="View Source Code" >(src)</a> 
of your language by default. You can override that by passing an option on load and save, e.g.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Map&lt;?,?&gt;&nbsp;options&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;HashMap();<br/>
options.put(XtextResource.OPTION_ENCODING,&nbsp;<span class="string">"UTF-8"</span>);<br/>
myXtextResource.load(options);<br/>
<br/>
options.put(XtextResource.OPTION_ENCODING,&nbsp;<span class="string">"ISO-8859-1"</span>);<br/>
myXtextResource.save(options);
</p>
</div>
</div>
</p>
<a name="encoding_9"></a>
<h3>Encoding in New Model Projects</h3>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/ui/generator/projectWizard/SimpleProjectWizardFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ui.generator.projectWizard.SimpleProjectWizardFragment" >SimpleProjectWizardFragment</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/projectWizard/SimpleProjectWizardFragment.java" title="View Source Code" >(src)</a> 
generates a wizard that clients of your language can use to create model 
projects. This wizard expects its templates to be in the encoding of the Generator that created it 
(see above). As for every new project wizard, its output will be encoded in the default encoding of the 
target workspace. If your language enforces a special encoding that ignores the workspace settings, you&apos;ll
have to make sure that your wizard uses the right encoding by yourself.
</p>
<a name="encoding_10"></a>
<h3>Encoding of Xtext Source Code</h3>
<p>
The source code of the Xtext framework itself is completely encoded in <em>ISO 8859-1</em>, which is necessary 
to make the Xpand templates work everywhere (they use french quotation markup). That encoding is hard 
coded into the Xtext generator code. You are likely never going to change that. 
</p>
<a name="testing"></a>
<h2>Unit Testing the Language</h2>
<p>
Automated tests are crucial for the maintainability and the quality of a software product. That is why
it is strongly recommended to write unit tests for your language, too. The Xtext project wizard creates
a test project for that purpose. It simplifies the setup procedure both for the Eclipse agnostic tests and the UI
tests for Junit4.
</p>
<p>
The following is about testing the parser and the linker for the <em>Domainmodel</em> language from the tutorial. It leverages Xtend to
write the test case.
</p>
<a name="testing_3"></a>
<h3>Creating a simple test class</h3>
<p>
First of all, a new Xtend class has to be created. Therefore, choose the src folder of the test 
plugin, and select <em>New -&gt; Xtend Class</em> from the context menu. Provide a meaningful name and
enter the package before you hit finish.
</p>
<p>
The core of the test infrastructure is the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/XtextRunner.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.XtextRunner" >XtextRunner</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/XtextRunner.java" title="View Source Code" >(src)</a> and
the language specific <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/IInjectorProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.IInjectorProvider" >IInjectorProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/IInjectorProvider.java" title="View Source Code" >(src)</a>. Both have to be provided
by means of class annotations:
 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;org.eclipse.xtext.junit4.XtextRunner<br/>
<span class="keyword">import</span>&nbsp;org.example.domainmodel.DomainmodelInjectorProvider<br/>
<br/>
@InjectWith(DomainmodelInjectorProvider)<br/>
@RunWith(XtextRunner)<br/>
<span class="keyword">class</span>&nbsp;ParserTest&nbsp;{<br/>
}
</p>
</div>
</div>
</p>
<p>
This configuration will make sure that you can use dependency injection in your test class, and that the global EMF registries
are properly populated and cleaned up before respectively after each test. 
</p>
<a name="testing_4"></a>
<h3>Writing a parser test</h3>
<p>
The class <em>org.eclipse.xtext.junit4.util.ParseHelper</em> allows to parse an arbitrary string into an
AST model. The AST model itself can be traversed and checked afterwards. A static import of
<a class="jdoc" href="http://junit.sourceforge.net/javadoc/org/junit/Assert.html" title="View JavaDoc"><abbr title="org.junit.Assert" >Assert</abbr></a> leads to concise and readable test cases.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;org.eclipse.xtext.junit4.util.ParseHelper<br/>
<span class="keyword">import</span>&nbsp;<span class="keyword">static</span>&nbsp;org.junit.Assert.*<br/>
<br/>
...<br/>
&nbsp;@Inject<br/>
ParseHelper&lt;Domainmodel&gt;&nbsp;parser<br/>
<br/>
@Test&nbsp;<br/>
<span class="keyword">def</span>&nbsp;<span class="keyword">void</span>&nbsp;parseDomainmodel()&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;model&nbsp;=&nbsp;parser.parse(<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;entity&nbsp;MyEntity&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;MyEntity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&apos;&apos;&apos;</span>)<br/>
&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;entity&nbsp;=&nbsp;model.elements.head&nbsp;<span class="keyword">as</span>&nbsp;Entity<br/>
&nbsp;&nbsp;assertSame(entity,&nbsp;entity.features.head.type)<br/>
}
</p>
</div>
</div>
</p>
<a name="testing_5"></a>
<h3>How to write tests that includes multiple different languages</h3>
<p>
If in addition to the main language your tests require using other languages for references from/to your main language,
you&apos;ll have to parse and load dependant resources into the same ResourceSet first for cross reference resolution to work.
</p>
<p>
As your main language&apos;s default generated <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/junit4/IInjectorProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.junit4.IInjectorProvider" >IInjectorProvider</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/IInjectorProvider.java" title="View Source Code" >(src)</a> (e.g. DomainmodelInjectorProvider) does not know about
any other such dependant languages, they must be initialized explicitly. The recommended pattern for this is to
create a new subclass of the generated <em>MyLanguageInjectorProvider</em> in your <em>*.test</em> project and make sure the dependenant 
language is intizialized properly. You can and then use this new injector provider instead of the original one in your test&apos;s <em>@InjectWith</em>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;MyLanguageWithDependenciesInjectorProvider&nbsp;<span class="keyword">extends</span>&nbsp;MyLanguageInjectorProvider&nbsp;{<br/>
&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;internalCreateInjector()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MyOtherLangLanguageStandaloneSetup.doSetup<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.internalCreateInjector<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
@RunWith(XtextRunner)<br/>
@InjectWith(MyLanguageWithDependenciesInjectorProvider)<br/>
<span class="keyword">class</span>&nbsp;YourTest&nbsp;{<br/>
&nbsp;&nbsp;...<br/>
}
</p>
</div>
</div>
</p>
<p>
You should not put injector creation for referenced languages in your standalone setup. Note that for the headless code generation use case,
the Maven plug-in is configured with multiple setups, so usually there is no problem there.
</p>
<p>
You may also need to initialize &apos;import&apos;-ed ecore models that are not generated by your Xtext language. This should be done by using
an explicit <em>MyModelPackage.eINSTANCE.getName();</em> in the <em>doSetup()</em> method of your respective language&apos;s StandaloneSetup class. 
Note that it is strongly recommended to follow this pattern instead of just using <em>@Before</em> methods in your
*Test class, as due to internal technical reasons that won&apos;t work anymore as soon as you have more than just one <em>@Test</em>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;MyLanguageStandaloneSetup&nbsp;<span class="keyword">extends</span>&nbsp;MyLanguageStandaloneSetupGenerated&nbsp;{<br/>
<br/>
&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;doSetup()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MyPackageImpl.init<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration<br/>
&nbsp;&nbsp;}<br/>
<br/>
}
</p>
</div>
</div>
</p>
<p>
This only applies to referencing dependencies to &apos;import&apos;-ed Ecore models and languages based on them which may be used in the test.
The inherited dependencies from mixed-in grammars are automatically listed in the generated super class already, and nothing needs to be done for those.
</p>
</body>
</html>
