«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtext::parser::antlr::AntlrGrammar»
«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::parser::antlr::Parser»

«DEFINE grammar FOR GenService»
«FILE internalAntlrGrammarFullPath() SRC_GEN-»
/*
«fileHeader()»
*/
grammar «internalAntlrGrammarName()»;

options {
	superClass=AbstractInternalAntlrParser;
}

@lexer::header {
package «internalPackage()»;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package «internalPackage()»; 

import java.io.InputStream;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.eclipse.xtext.conversion.ValueConverterException;

}

@parser::members {
 
    public «internalParserClassName()»(TokenStream input, IAstFactory factory, Grammar g) {
        this(input);
        this.factory = factory;
		grammar = g;
    }
    
    @Override
    protected InputStream getTokenFile() {
    	ClassLoader classLoader = «internalParserClassName()».class.getClassLoader();
    	return classLoader.getResourceAsStream("«internalPackageFullPath()»/«internalAntlrGrammarName()».tokens");
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "«grammar().allParserRules().first().name»";	
   	} 
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}
«EXPAND antlrRules FOR grammar()»
«ENDFILE»
«ENDDEFINE»

«DEFINE antlrRules FOR Grammar»
«EXPAND rule FOREACH allParserRules()»

«EXPAND terminalRule FOREACH allParserRules()»
«EXPAND rule FOREACH allLexerRules()»
«ENDDEFINE»


«DEFINE rule FOR ParserRule»
«IF isCalled()»
«IF !terminal»
«IF !isDatatypeRule()»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [EObject current=null] :
	{ currentNode = «EXPAND createCompositeNode» }
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current; } 
	 EOF 
;

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; setCurrentLookahead(); resetLookahead(); 
«IF definesHiddenTokens-»
		HiddenTokens myHiddenTokenState = ((XtextTokenStream)input).setHiddenTokens(«FOREACH hiddenTokens AS hidden SEPARATOR ", "»"«hidden.ruleName()»"«ENDFOREACH-»);
«ENDIF-»    
    }
    @after { resetLookahead(); 
«IF definesHiddenTokens-»
		myHiddenTokenState.restore();
«ENDIF-»
    }:
    «EXPAND ebnf FOR this.alternatives»;
«ELSE»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [String current=null] :
	{ currentNode = «EXPAND createCompositeNode» } 
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current.getText(); }  
	 EOF 
;

// Rule «name»
«ruleName()» returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()] 
    @init { setCurrentLookahead(); resetLookahead(); 
«IF definesHiddenTokens-»
		HiddenTokens myHiddenTokenState = input.setHiddenTokens(«FOREACH hiddenTokens AS hidden SEPARATOR ", "»"«hidden.ruleName()»"«ENDFOREACH-»);
«ENDIF-» 
    }
    @after { resetLookahead(); 
«IF definesHiddenTokens-»
		myHiddenTokenState.restore();
«ENDIF-» 
    }:
   «EXPAND dataTypeEbnf FOR this.alternatives»
    ;
«ENDIF»
«ENDIF»
«ENDIF»
«ENDDEFINE»

«DEFINE terminalRule FOR ParserRule»
«IF terminal»
«ruleName()» : «toLexerBody()»;
«ENDIF»
«ENDDEFINE»

«DEFINE rule FOR LexerRule»
«ruleName()» : «body»;
«ENDDEFINE»

«DEFINE ebnf FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2»)«ELSE»«EXPAND ebnf2»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE dataTypeEbnf FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND dataTypeEbnf2»)«ELSE»«EXPAND dataTypeEbnf2»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE dataTypeEbnf2 FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE dataTypeEbnf2 FOR Alternatives-»«EXPAND dataTypeEbnf FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE dataTypeEbnf2 FOR Group»«EXPAND dataTypeEbnf FOREACH abstractTokens»«ENDDEFINE»

«DEFINE dataTypeEbnf2 FOR Keyword»
	kw='«value»' 
    {
        $current.merge(kw);
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE dataTypeEbnf2 FOR RuleCall-»
«IF ParserRule.isInstance(rule) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
«ENDIF-»
    «localVar()»=«rule.ruleName()-»
    {
		$current.merge(«localVar()»);
    }
«IF ParserRule.isInstance(rule) && !isAssigned()»
    { 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF LexerRule.isInstance(rule)»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE ebnf2 FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2 FOR Alternatives-»«EXPAND ebnf FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2 FOR Group»«EXPAND ebnf FOREACH abstractTokens»«ENDDEFINE»

«DEFINE ebnf2 FOR Assignment»	
	«IF !eAllContents.typeSelect(CrossReference).isEmpty»
		«REM» Cross references are handled in the linking phase «ENDREM»
		{
			if ($current==null) {
	            $current = factory.create("«containingParserRule().typeName()»");
	            associateNodeWithAstElement(currentNode, $current);
	        }
        }
		«EXPAND ebnf FOR terminal» 
	«ELSE»
	    «IF isParserRuleAssignment()»
	    { 
	        currentNode=«EXPAND createCompositeNode FOR terminal» 
	    }
	    «ENDIF-»
	    «localVar()»=«EXPAND ebnf FOR terminal» 
	    {
	        if ($current==null) {
	            $current = factory.create("«containingParserRule().typeName()»");
	            «IF isParserRuleAssignment()»associateNodeWithAstElement(currentNode.getParent(), $current);
	            «ELSE»associateNodeWithAstElement(currentNode, $current);
	            «ENDIF-»
	        }
	        «REM»the use of input.LT(-1) in the following line is a workaroudn for a bug of antlr, where assignements of alternative keywords are ignored when there are actions«ENDREM»
	        try {
	        	factory.«setOrAdd()»($current, "«feature»", «
	        		IF isBoolean()»true«
	        		ELSE»«eAllContents.typeSelect(Keyword).isEmpty ? localVar() : "input.LT(-1)"»«
	        		ENDIF», «terminal.toStringLiteral()», currentNode);
	        } catch (ValueConverterException vce) {
				handleValueConverterException(vce);
	        }
	        «IF isParserRuleAssignment()»currentNode = currentNode.getParent();
	        «ENDIF-»
	    }
	«ENDIF»
«ENDDEFINE»

«DEFINE ebnf2 FOR CrossReference»
	«calledLexerRule().ruleName()-»
    { 
    «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Action»
    { 
        temp=factory.create("«this.typeName.getQualifiedName()»");
        try {
        	factory.«setOrAdd()»(temp, "«feature»", $current, null /*ParserRule*/, currentNode);
        } catch(ValueConverterException vce) {
        	handleValueConverterException(vce);
        }
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Keyword»'«value»' 
    {
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR RuleCall-»
«IF ParserRule.isInstance(rule) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
    «localVar()»=«ENDIF-»
«rule.ruleName()-»
«IF ParserRule.isInstance(rule) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF LexerRule.isInstance(rule) || (ParserRule.isInstance(rule) && ((ParserRule)rule).terminal)»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR emf::EObject
    »createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode.getParent());
    newNode.getChildren().add(currentNode);
    moveLookaheadInfo(currentNode, newNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR emf::EObject
    »createLeafNode("«
    objectURI()
    »" /* «
    this.metaType.name
    » */, «
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

