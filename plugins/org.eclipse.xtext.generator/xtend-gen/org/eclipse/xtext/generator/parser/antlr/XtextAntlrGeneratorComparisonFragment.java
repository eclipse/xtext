/**
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.xtext.generator.parser.antlr;

import com.google.common.base.Objects;
import com.google.common.base.Stopwatch;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.TreeTraverser;
import com.google.common.io.Files;
import com.google.inject.Inject;
import java.io.File;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;
import org.eclipse.xpand2.XpandExecutionContext;
import org.eclipse.xpand2.XpandExecutionContextImpl;
import org.eclipse.xpand2.XpandFacade;
import org.eclipse.xpand2.output.Outlet;
import org.eclipse.xpand2.output.Output;
import org.eclipse.xtend.lib.annotations.Accessors;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.generator.Generator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.Naming;
import org.eclipse.xtext.generator.adapter.FragmentAdapter;
import org.eclipse.xtext.generator.parser.antlr.AntlrOptions;
import org.eclipse.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment;
import org.eclipse.xtext.generator.parser.antlr.XtextAntlrUiGeneratorFragment;
import org.eclipse.xtext.util.internal.Log;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure0;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.Pure;
import org.eclipse.xtext.xtext.FlattenedGrammarAccess;
import org.eclipse.xtext.xtext.RuleFilter;
import org.eclipse.xtext.xtext.RuleNames;
import org.eclipse.xtext.xtext.generator.IBundleProjectConfig;
import org.eclipse.xtext.xtext.generator.IRuntimeProjectConfig;
import org.eclipse.xtext.xtext.generator.IXtextProjectConfig;
import org.eclipse.xtext.xtext.generator.Issues;
import org.eclipse.xtext.xtext.generator.model.IXtextGeneratorFileSystemAccess;
import org.eclipse.xtext.xtext.generator.model.TypeReference;
import org.eclipse.xtext.xtext.generator.parser.antlr.GrammarNaming;

/**
 * Compares the Antlr grammar generated by {@link
 * org.eclipse.xtext.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment2
 * XtextAntlrGeneratorFragment2} with that of {@link XtextAntlrGeneratorFragment}
 * by running its grammar generation in a temporary folder and comparing the
 * grammar outputs token by token.
 * 
 * @author Christian Schneider - Initial contribution and API
 * @since 2.9
 */
@Log
@SuppressWarnings("all")
public class XtextAntlrGeneratorComparisonFragment extends FragmentAdapter {
  private final static String ENCODING = "ISO-8859-1";
  
  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("\\(", "\\)", "\\[", "\\]", "\\{", "\\}", "\\|", "=", ":", ";"));
  
  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("\'(\\\\\')+\'", "(\'[^\']*\')", "(\"[^\"]*\")")), "|");
  
  private final static String TOKEN = new Function0<String>() {
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      String _join = IterableExtensions.join(XtextAntlrGeneratorComparisonFragment.SINGLE_CHAR_TOKENS, "|");
      _builder.append(_join, "");
      _builder.append("|");
      _builder.append(XtextAntlrGeneratorComparisonFragment.QUOTED_TOKENS, "");
      _builder.append("|[^\\s\'\"");
      String _join_1 = IterableExtensions.join(XtextAntlrGeneratorComparisonFragment.SINGLE_CHAR_TOKENS);
      _builder.append(_join_1, "");
      _builder.append("]+");
      return _builder.toString();
    }
  }.apply();
  
  private final static String NEWLINE = "\\r?\\n|\\r";
  
  private final static String WS = "( |\\t)+";
  
  private final Pattern p_token = Pattern.compile(XtextAntlrGeneratorComparisonFragment.TOKEN);
  
  private final Pattern p_newline = Pattern.compile(XtextAntlrGeneratorComparisonFragment.NEWLINE);
  
  private final Pattern p_ws = Pattern.compile(XtextAntlrGeneratorComparisonFragment.WS);
  
  private final Pattern compoundPattern = new Function0<Pattern>() {
    public Pattern apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("(");
      _builder.append(XtextAntlrGeneratorComparisonFragment.TOKEN, "");
      _builder.append(")|(");
      _builder.append(XtextAntlrGeneratorComparisonFragment.NEWLINE, "");
      _builder.append(")|(");
      _builder.append(XtextAntlrGeneratorComparisonFragment.WS, "");
      _builder.append(")");
      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);
      return _compile;
    }
  }.apply();
  
  @Inject
  @Extension
  private GrammarNaming _grammarNaming;
  
  @Accessors
  private AntlrOptions options;
  
  @Accessors
  private boolean partialParsing;
  
  private List<String> advices = CollectionLiterals.<String>newArrayList();
  
  public void addRegisterAdvice(final String advice) {
    this.advices.add(advice);
  }
  
  @Override
  public void checkConfiguration(final Issues issues) {
  }
  
  @Override
  public void generate() {
    Naming _naming = this.getNaming();
    boolean _tripleEquals = (_naming == null);
    if (_tripleEquals) {
      Naming _createNaming = this.createNaming();
      this.setNaming(_createNaming);
    }
    if ((this.options == null)) {
      AntlrOptions _antlrOptions = new AntlrOptions();
      this.options = _antlrOptions;
    }
    IXtextProjectConfig _projectConfig = this.getProjectConfig();
    IRuntimeProjectConfig _runtime = _projectConfig.getRuntime();
    IXtextGeneratorFileSystemAccess _srcGen = null;
    if (_runtime!=null) {
      _srcGen=_runtime.getSrcGen();
    }
    boolean _notEquals = (!Objects.equal(_srcGen, null));
    if (_notEquals) {
      IXtextProjectConfig _projectConfig_1 = this.getProjectConfig();
      IRuntimeProjectConfig _runtime_1 = _projectConfig_1.getRuntime();
      IXtextGeneratorFileSystemAccess _srcGen_1 = _runtime_1.getSrcGen();
      StringConcatenation _builder = new StringConcatenation();
      Grammar _grammar = this.getGrammar();
      TypeReference _grammarClass = this._grammarNaming.getGrammarClass(_grammar);
      String _path = _grammarClass.getPath();
      _builder.append(_path, "");
      _builder.append(".g");
      this.loadAndCompareGrammars(_srcGen_1, Generator.SRC_GEN, _builder.toString());
    }
    IXtextProjectConfig _projectConfig_2 = this.getProjectConfig();
    IBundleProjectConfig _genericIde = _projectConfig_2.getGenericIde();
    IXtextGeneratorFileSystemAccess _srcGen_2 = null;
    if (_genericIde!=null) {
      _srcGen_2=_genericIde.getSrcGen();
    }
    boolean _notEquals_1 = (!Objects.equal(_srcGen_2, null));
    if (_notEquals_1) {
      IXtextProjectConfig _projectConfig_3 = this.getProjectConfig();
      IBundleProjectConfig _genericIde_1 = _projectConfig_3.getGenericIde();
      IXtextGeneratorFileSystemAccess _srcGen_3 = _genericIde_1.getSrcGen();
      StringConcatenation _builder_1 = new StringConcatenation();
      Grammar _grammar_1 = this.getGrammar();
      TypeReference _internalContentAssistLexerClass = this._grammarNaming.getInternalContentAssistLexerClass(_grammar_1);
      String _path_1 = _internalContentAssistLexerClass.getPath();
      String _replaceFirst = _path_1.replaceFirst("Lexer$", "");
      _builder_1.append(_replaceFirst, "");
      _builder_1.append(".g");
      this.loadAndCompareGrammars(_srcGen_3, Generator.SRC_GEN_IDE, _builder_1.toString());
    }
    File _tmpDir = this.getTmpDir();
    XtextAntlrGeneratorComparisonFragment.deleteDir(_tmpDir);
  }
  
  protected void loadAndCompareGrammars(final IFileSystemAccess2 fsa, final String outlet, final String grammarFileName) {
    try {
      final Stopwatch stopWatch = Stopwatch.createStarted();
      this.performXpandBasedGeneration(outlet);
      StringConcatenation _builder = new StringConcatenation();
      String _path = this.getPath(fsa);
      _builder.append(_path, "");
      _builder.append("/");
      _builder.append(grammarFileName, "");
      final String absoluteGrammarFileName = _builder.toString();
      StringConcatenation _builder_1 = new StringConcatenation();
      File _tmpDir = this.getTmpDir();
      String _absolutePath = _tmpDir.getAbsolutePath();
      _builder_1.append(_absolutePath, "");
      _builder_1.append("/");
      _builder_1.append(grammarFileName, "");
      final String absoluteGrammarFileNameReference = _builder_1.toString();
      final CharSequence grammar = fsa.readTextFile(grammarFileName);
      File _file = new File(absoluteGrammarFileNameReference);
      Charset _forName = Charset.forName(XtextAntlrGeneratorComparisonFragment.ENCODING);
      final String grammarReference = Files.toString(_file, _forName);
      final Pair<Integer, Integer> lines = this.compareGrammars(grammar, grammarReference, absoluteGrammarFileName, absoluteGrammarFileNameReference);
      final long time = stopWatch.elapsed(TimeUnit.MILLISECONDS);
      String _xifexpression = null;
      if ((outlet == Generator.SRC_GEN)) {
        _xifexpression = "parser";
      } else {
        _xifexpression = "content assist";
      }
      final String type = _xifexpression;
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("Generated ");
      _builder_2.append(type, "");
      _builder_2.append(" grammar of ");
      Integer _key = lines.getKey();
      _builder_2.append(_key, "");
      _builder_2.append(" lines matches expected one of ");
      Integer _value = lines.getValue();
      _builder_2.append(_value, "");
      _builder_2.append(" (");
      _builder_2.append(time, "");
      _builder_2.append(" ms).");
      XtextAntlrGeneratorComparisonFragment.LOG.info(_builder_2);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  protected void performXpandBasedGeneration(final String outlet) {
    final RuleFilter filter = new RuleFilter();
    boolean _isSkipUnusedRules = this.options.isSkipUnusedRules();
    filter.setDiscardUnreachableRules(_isSkipUnusedRules);
    Grammar _grammar = this.getGrammar();
    final RuleNames ruleNames = RuleNames.getRuleNames(_grammar, true);
    FlattenedGrammarAccess _flattenedGrammarAccess = new FlattenedGrammarAccess(ruleNames, filter);
    final Grammar flattened = _flattenedGrammarAccess.getFlattenedGrammar();
    XpandExecutionContext _createExecutionContext = this.createExecutionContext();
    final XpandExecutionContextImpl context = ((XpandExecutionContextImpl) _createExecutionContext);
    final Procedure1<String> _function = new Procedure1<String>() {
      @Override
      public void apply(final String it) {
        context.registerAdvices(it);
      }
    };
    IterableExtensions.<String>forEach(this.advices, _function);
    boolean _and = false;
    boolean _equals = Objects.equal(outlet, Generator.SRC_GEN);
    if (!_equals) {
      _and = false;
    } else {
      Output _output = context.getOutput();
      Outlet _outlet = _output.getOutlet(Generator.SRC_GEN);
      boolean _notEquals = (!Objects.equal(_outlet, null));
      _and = _notEquals;
    }
    if (_and) {
      String _name = XtextAntlrGeneratorFragment.class.getName();
      final String template = _name.replaceAll("\\.", "::");
      XpandFacade _create = XpandFacade.create(context);
      _create.evaluate2((template + "::generate"), flattened, Collections.<Object>unmodifiableList(CollectionLiterals.<Object>newArrayList(this.options)));
    } else {
      boolean _and_1 = false;
      boolean _equals_1 = Objects.equal(outlet, Generator.SRC_GEN_IDE);
      if (!_equals_1) {
        _and_1 = false;
      } else {
        Output _output_1 = context.getOutput();
        Outlet _outlet_1 = _output_1.getOutlet(Generator.SRC_GEN_IDE);
        boolean _notEquals_1 = (!Objects.equal(_outlet_1, null));
        _and_1 = _notEquals_1;
      }
      if (_and_1) {
        String _name_1 = XtextAntlrUiGeneratorFragment.class.getName();
        final String template_1 = _name_1.replaceAll("\\.", "::");
        XpandFacade _create_1 = XpandFacade.create(context);
        Naming _naming = this.getNaming();
        boolean _hasIde = _naming.hasIde();
        _create_1.evaluate2((template_1 + "::generate"), flattened, Collections.<Object>unmodifiableList(CollectionLiterals.<Object>newArrayList(this.options, Boolean.valueOf(this.partialParsing), Boolean.valueOf(_hasIde))));
      }
    }
  }
  
  private int newlineCounter;
  
  private int newlineCounterReference;
  
  /**
   * Performs the actual comparison of given and expected grammar.
   * 
   * @return {@link Pair} containing the number of lines of the tested grammar (key)
   * 			and the referenced grammar (value) for logging purposes
   */
  protected Pair<Integer, Integer> compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference) {
    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);
    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);
    this.newlineCounter = 1;
    this.newlineCounterReference = 1;
    int previousEnd = 0;
    int previousEndReference = 0;
    final Procedure0 _function = new Procedure0() {
      @Override
      public void apply() {
        XtextAntlrGeneratorComparisonFragment.this.copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName);
        XtextAntlrGeneratorComparisonFragment.this.handleUnexpectedCharSequence(absoluteGrammarFileName, XtextAntlrGeneratorComparisonFragment.this.newlineCounter);
      }
    };
    final Procedure0 missedCharSequenceHandler = _function;
    final Procedure0 _function_1 = new Procedure0() {
      @Override
      public void apply() {
        XtextAntlrGeneratorComparisonFragment.this.copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName);
        XtextAntlrGeneratorComparisonFragment.this.handleUnexpectedCharSequence(absoluteGrammarFileNameReference, XtextAntlrGeneratorComparisonFragment.this.newlineCounterReference);
      }
    };
    final Procedure0 missedCharSequenceHandlerReference = _function_1;
    boolean _and = false;
    boolean _find = compoundMatcher.find();
    if (!_find) {
      _and = false;
    } else {
      boolean _find_1 = compoundMatcherReference.find();
      _and = _find_1;
    }
    boolean continue_ = _and;
    while (continue_) {
      {
        final int res = this.nextToken(compoundMatcher, previousEnd, missedCharSequenceHandler);
        int _newlineCounter = this.newlineCounter;
        this.newlineCounter = (_newlineCounter + res);
        boolean _hitEnd = compoundMatcher.hitEnd();
        boolean _not = (!_hitEnd);
        if (_not) {
          int _end = compoundMatcher.end();
          previousEnd = _end;
        }
        final int resReference = this.nextToken(compoundMatcherReference, previousEndReference, missedCharSequenceHandlerReference);
        int _newlineCounterReference = this.newlineCounterReference;
        this.newlineCounterReference = (_newlineCounterReference + resReference);
        boolean _hitEnd_1 = compoundMatcherReference.hitEnd();
        boolean _not_1 = (!_hitEnd_1);
        if (_not_1) {
          int _end_1 = compoundMatcherReference.end();
          previousEndReference = _end_1;
        }
        String _xifexpression = null;
        boolean _hitEnd_2 = compoundMatcher.hitEnd();
        if (_hitEnd_2) {
          _xifexpression = "««eof»»";
        } else {
          _xifexpression = compoundMatcher.group();
        }
        String match = _xifexpression;
        String _xifexpression_1 = null;
        boolean _hitEnd_3 = compoundMatcherReference.hitEnd();
        if (_hitEnd_3) {
          _xifexpression_1 = "««eof»»";
        } else {
          _xifexpression_1 = compoundMatcherReference.group();
        }
        String matchReference = _xifexpression_1;
        boolean _notEquals = (!Objects.equal(matchReference, match));
        if (_notEquals) {
          this.handleMismatch(absoluteGrammarFileName, absoluteGrammarFileNameReference, match, matchReference, this.newlineCounter, this.newlineCounterReference);
        }
        boolean _and_1 = false;
        boolean _and_2 = false;
        if (!continue_) {
          _and_2 = false;
        } else {
          boolean _find_2 = compoundMatcherReference.find();
          _and_2 = _find_2;
        }
        if (!_and_2) {
          _and_1 = false;
        } else {
          boolean _find_3 = compoundMatcher.find();
          _and_1 = _find_3;
        }
        continue_ = _and_1;
      }
    }
    return Pair.<Integer, Integer>of(Integer.valueOf(this.newlineCounter), Integer.valueOf(this.newlineCounterReference));
  }
  
  /**
   * continue matching until the next token is found, count newlines while doing so.
   * 
   * @return the number of newlines passed while searching
   */
  private int nextToken(final Matcher matcher, final int previousEnd, final Procedure0 missedCharSequenceHandler) {
    boolean continue_ = true;
    int newlineCounter = 0;
    int thePreviousEnd = previousEnd;
    while (continue_) {
      {
        int _start = matcher.start();
        boolean _notEquals = (_start != thePreviousEnd);
        if (_notEquals) {
          missedCharSequenceHandler.apply();
        }
        final String match = matcher.group();
        Matcher _matcher = this.p_newline.matcher(match);
        boolean _matches = _matcher.matches();
        if (_matches) {
          newlineCounter++;
          int _end = matcher.end();
          thePreviousEnd = _end;
        } else {
          Matcher _matcher_1 = this.p_ws.matcher(match);
          boolean _matches_1 = _matcher_1.matches();
          if (_matches_1) {
            int _end_1 = matcher.end();
            thePreviousEnd = _end_1;
          } else {
            Matcher _matcher_2 = this.p_token.matcher(match);
            boolean _matches_2 = _matcher_2.matches();
            if (_matches_2) {
              return newlineCounter;
            }
          }
        }
        boolean _find = matcher.find();
        continue_ = _find;
      }
    }
    return newlineCounter;
  }
  
  protected void handleUnexpectedCharSequence(final String absoluteGrammarFileName, final int lineNo) {
    File _tmpDir = this.getTmpDir();
    XtextAntlrGeneratorComparisonFragment.deleteDir(_tmpDir);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Noticed an unmatched character sequence in file ");
    _builder.append(absoluteGrammarFileName, "");
    _builder.append(" in/before line ");
    _builder.append(lineNo, "");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    throw new RuntimeException(_builder.toString());
  }
  
  protected void handleMismatch(final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final String match, final String matchReference, final int lineNo, final int lineNoReference) {
    this.copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName);
    File _tmpDir = this.getTmpDir();
    XtextAntlrGeneratorComparisonFragment.deleteDir(_tmpDir);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Generated grammar ");
    _builder.append(absoluteGrammarFileName, "");
    _builder.append(" differs at token ");
    _builder.append(match, "");
    _builder.append(" (line ");
    _builder.append(lineNo, "");
    _builder.append("), expected token ");
    _builder.append(matchReference, "");
    _builder.append(" (line ");
    _builder.append(lineNoReference, "");
    _builder.append(").");
    throw new RuntimeException(_builder.toString());
  }
  
  protected void copyFile(final String from, final String to) {
    try {
      File _file = new File(from);
      StringConcatenation _builder = new StringConcatenation();
      int _length = to.length();
      int _minus = (_length - 2);
      String _substring = to.substring(0, _minus);
      _builder.append(_substring, "");
      _builder.append("Expected.g");
      File _file_1 = new File(_builder.toString());
      Files.copy(_file, _file_1);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * offers a singleton temporary folder
   */
  private File getTmpDir() {
    final ArrayList<?> _cacheKey = CollectionLiterals.newArrayList();
    final File _result;
    synchronized (_createCache_getTmpDir) {
      if (_createCache_getTmpDir.containsKey(_cacheKey)) {
        return _createCache_getTmpDir.get(_cacheKey);
      }
      File _createTempDir = Files.createTempDir();
      _result = _createTempDir;
      _createCache_getTmpDir.put(_cacheKey, _result);
    }
    _init_getTmpDir(_result);
    return _result;
  }
  
  private final HashMap<ArrayList<?>, File> _createCache_getTmpDir = CollectionLiterals.newHashMap();
  
  private void _init_getTmpDir(final File path) {
  }
  
  /**
   * Tweaks the generation of the {@link Generator#SRC_GEN Generator.SRC_GEN} outlet
   * and injects the {@link #getTmpPath()}.
   */
  @Override
  protected Outlet createOutlet(final boolean append, final String encoding, final String name, final boolean overwrite, final String path) {
    Outlet _xifexpression = null;
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(name, Generator.SRC_GEN);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _equals_1 = Objects.equal(name, Generator.SRC_GEN_IDE);
      _or_1 = _equals_1;
    }
    if (_or_1) {
      _or = true;
    } else {
      boolean _equals_2 = Objects.equal(name, Generator.SRC_GEN_UI);
      _or = _equals_2;
    }
    if (_or) {
      File _tmpDir = this.getTmpDir();
      String _absolutePath = _tmpDir.getAbsolutePath();
      _xifexpression = super.createOutlet(append, encoding, name, overwrite, _absolutePath);
    } else {
      _xifexpression = super.createOutlet(append, encoding, name, overwrite, path);
    }
    return _xifexpression;
  }
  
  /**
   * little helper for cleaning up the temporary stuff.
   */
  private static void deleteDir(final File dir) {
    boolean _exists = dir.exists();
    boolean _not = (!_exists);
    if (_not) {
      return;
    }
    TreeTraverser<File> _fileTreeTraverser = Files.fileTreeTraverser();
    FluentIterable<File> _postOrderTraversal = _fileTreeTraverser.postOrderTraversal(dir);
    final Procedure1<File> _function = new Procedure1<File>() {
      @Override
      public void apply(final File it) {
        it.delete();
      }
    };
    IterableExtensions.<File>forEach(_postOrderTraversal, _function);
  }
  
  private final static Logger LOG = Logger.getLogger(XtextAntlrGeneratorComparisonFragment.class);
  
  @Pure
  public AntlrOptions getOptions() {
    return this.options;
  }
  
  public void setOptions(final AntlrOptions options) {
    this.options = options;
  }
  
  @Pure
  public boolean isPartialParsing() {
    return this.partialParsing;
  }
  
  public void setPartialParsing(final boolean partialParsing) {
    this.partialParsing = partialParsing;
  }
}
