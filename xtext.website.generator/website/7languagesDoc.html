<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<!--[if lt IE 9]>
	<link href="css/iebugs.css" rel="stylesheet" type='text/css'>
	<![endif]-->
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
					$('.has-popover').popover();
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtext', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-3' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li class="active"><a href="7languages.html">7 Languages</a></li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://xtend-lang.org">Xtend</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
				</div>
				<!--/.nav-collapse -->
		        <div class="btn-group pull-right">
		          <g:plusone href="http://www.xtext.org"></g:plusone>
		        </div>
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<div id="header_wrapper" class="container">
	<ul id="nav-outline">
		<li>&nbsp;</li>
		<li style="color : #333;">General Overview</li>
		<li><a href="#introduction">Introduction</a>
	<ul>	<li><a href="#_0">Write the Grammar</a></li>
		<li><a href="#_1">Map to Java</a></li>
		<li><a href="#provisional_API">CAUTION: This is Provisional API</a></li>
	</ul>	</li>
		<li><a href="#common_requirements">Common Requirements</a>
	<ul>	<li><a href="#installation">Getting the Code</a></li>
	</ul>	</li>
		<li><a href="#xtend_primer">A Short Xtend Primer</a>
		</li>
		<li>&nbsp;</li>
		<li style="color : #333;">The 7 Languages</li>
		<li><a href="#scripting">Scripting Language</a>
	<ul>	<li><a href="#scripting_solution">Overview</a></li>
		<li><a href="#scripting_running">Running the Example</a></li>
		<li><a href="#scripting_grammar">Grammar</a></li>
		<li><a href="#scripting_inferrer">Translation to Java</a></li>
	</ul>	</li>
		<li><a href="#builddsl">Build Language</a>
	<ul>	<li><a href="#builddsl_solution">Overview</a></li>
		<li><a href="#builddsl_running">Running the Example</a></li>
		<li><a href="#builddsl_grammar">Grammar</a></li>
		<li><a href="#builddsl_inferrer">Translation to Java</a></li>
		<li><a href="#builddsl_validation">Validation</a></li>
		<li><a href="#builddsl_imports">Static Imports</a></li>
		<li><a href="#builddsl_library">Operator Overloading</a></li>
		<li><a href="#builddsl_launch">Run as... Integration</a></li>
	</ul>	</li>
		<li><a href="#mongoDB">DSL for MongoDB</a>
	<ul>	<li><a href="#mongo_solution">Overview</a></li>
		<li><a href="#mongo_running">Running the Example</a></li>
		<li><a href="#mongo_grammar">Grammar</a></li>
		<li><a href="#mongo_inferrer">Translation to Java</a></li>
		<li><a href="#mongo_nameProvider">Qualified Name Provider</a></li>
		<li><a href="#mongo_validation">Validation</a></li>
		<li><a href="#mongo_visual">IDE Enhancements</a></li>
	</ul>	</li>
		<li><a href="#guice">DSL for Guice</a>
	<ul>	<li><a href="#guice_solution">Overview</a></li>
		<li><a href="#guice_running">Running the Example</a></li>
		<li><a href="#guice_grammar">Grammar</a></li>
		<li><a href="#guice_inferrer">Translation to Java</a></li>
		<li><a href="#guice_validation">Validation</a></li>
	</ul>	</li>
		<li><a href="#httpRouting">Http Routing Language</a>
	<ul>	<li><a href="#routing_solution">Overview</a></li>
		<li><a href="#routing_running">Running the Example</a></li>
		<li><a href="#routing_grammar">Grammar</a></li>
		<li><a href="#routing_inferrer">Translation to Java</a></li>
		<li><a href="#routing_improts">Validated Imports</a></li>
	</ul>	</li>
		<li><a href="#template">Template Language</a>
	<ul>	<li><a href="#templates_solution">Overview</a></li>
		<li><a href="#templates_running">Running the Example</a></li>
		<li><a href="#templates_grammar">Grammar</a></li>
		<li><a href="#templates_inferrer">Translation to Java</a></li>
		<li><a href="#templates_compiler">Extending the Compiler</a></li>
		<li><a href="#templates_typeProvider">TypeProvider</a></li>
		<li><a href="#templates_valueConverter">Value Converter</a></li>
		<li><a href="#templates_contentAssist">Content Assist</a></li>
		<li><a href="#templates_highlighting">Syntax Highlighting</a></li>
	</ul>	</li>
		<li><a href="#tortoise">Little Tortoise</a>
	<ul>	<li><a href="#tortoise_solution">Overview</a></li>
		<li><a href="#tortoise_running">Running the Example</a></li>
		<li><a href="#tortoise_grammar">Grammar</a></li>
		<li><a href="#tortoise_inferrer">Translation to Java</a></li>
		<li><a href="#tortoise_interpreter">Interpreter</a></li>
		<li><a href="#tortoise_additons">Literal Classes</a></li>
	</ul>	</li>
	</ul>
</div>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="introduction" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Introduction
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Building a domain-specific language (DSL) for structural parts of an application has always been rather 
							easy with Xtext. But structure alone is not sufficient in many cases. When it comes to the behavioral aspects users 
							often fall back to implementing them in Java. The reasons are obvious: expressions and statements are hard to get 
							right and extremely complex and therefore costly to implement.
						</p>
						<p>
							This document introduces and explains a new API, which allows reusing predefined language constructs such as type references, 
							annotations and fully featured expressions anywhere in your languages. You not only reuse the grammar but the complete implementation 
							including a compiler, interpreter, the whole Java type system and a tight IDE integration. And the best part is, that it is 
							relatively easy to do so. It is actually just two steps:
						</p>
						<!--  section -->
						<section id="_0" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Write the Grammar</h2>
						<p>
							Using the traditional Xtext grammar language you freely describe the syntax of your language. The specialty for JVM
							languages is, that you inherit from an abstract grammar org.eclipse.xtext.xbase.Xbase, which predefines the syntax
							for the reusable parts. You do not need to use all of them directly and you can of course change the syntax 
							or add new concepts, as it seems fit.
						</p>
						</section>
						<!--  section -->
						<section id="_1" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Map to Java</h2>
						<p>
							Having the grammar defined, you now need to tell Xtext what your language concepts mean in terms of Java constructs. 
							For that purpose you use a so-called model inferrer, a special API that allows you to create any number of Java classes, interfaces 
							or members from your DSL. This hook not only defines how your language is translated to Java, but also defines 
							the scope of the embedded expressions. The expressions from your language 'live' in the context you give them.
							If you want an expression to have access to certain local variables, just put it into a method with appropriate 
							parameters or use instance fields if they work better.
						</p>
						<p>
							This hook also reveals your DSL constructs to other JVM languages. The Java type system is used as a common hub to 
							integrate arbitrary languages with each other. You can for instance call <a href="#template">templates</a> directly from a <a href="#scripting">script</a>
							and vice versa. You do not even need to generate the equivalent Java code; everything is based on the Java types you
							create in the model inferrer.
						</p>
						<p>
							To illustrate the power and flexibility of these two abstractions, we have built seven example languages using them:
						</p>
						<p>
							</p>
							<ul>
								<li><a href="#scripting">A simple scripting language</a></li>
								<li><a href="#builddsl">A Grade-like build DSL</a></li>
								<li><a href="#mongoDB">A DSL for statically-typed MongoDB documents</a></li>
								<li><a href="#guice">A Guice modules DSL</a></li>
								<li><a href="#httpRouting">A Playframework-like HTTP routing language</a></li>
								<li><a href="#template">A template language</a></li>
								<li><a href="#tortoise">A Logo-like programming environment for educational purposes</a></li>
							</ul>
							<p>
						</p>
						<p>
							Each language is very simple and focuses on the value a DSL can add to the respective 
							viewpoint. It is meant to give you an idea of what is possible without being a complete practical solution.
							Yet the languages are flexible and come with powerful core abstractions.
							We also covered different technical aspects of customizing to the language infrastructure. Some languages
							have special import logic, others implement special syntax coloring, outline views or content assist.
							The new API for JVM languages does not mean that anything is hidden away and not customizable.
						</p>
						</section>
						<!--  section -->
						<section id="provisional_API" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">CAUTION: This is Provisional API</h2>
						<p>
							<strong>Please be aware that most of the new API covered in this document is not yet finalized and will 
							likely be improved in future releases in incompatible ways. The projects in these examples are configured 
							to suppress the corresponding warnings for references to provisional API.</strong>
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="common_requirements" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Common Requirements
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							To run any of the examples, you will need <a href="http://www.eclipse.org/downloads">Eclipse 3.5 or better</a>
							for your platform. In addition, you have to install <a href="http://www.eclipse.org/xtend/download.html">Xtend</a>
							and of course <a href="http://www.eclipse.org/Xtext/download.html">Xtext 2.3</a>.
						</p>
						<p>
							If you prefer a simple all-inclusive installation, consider downloading the latest
							<a href="http://www.eclipse.org/Xtext/download.html">Xtext distribution</a>.
						</p>
						<p>
							Additional requirements are mentioned in the <strong>Running the Example</strong> section of each chapter.
						</p>
						<!--  section -->
						<section id="installation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Getting the Code</h2>
						<p>
							You can get the source code for all languages from the github repository at
							<a href="https://github.com/xtext-dev/seven-languages-xtext.git">github.com/xtext-dev/seven-languages-xtext</a>.
							The repository contains two folders <strong>languages</strong> and <strong>examples</strong>. Download the plug-ins from <strong>languages</strong> into
							the root workspace and the <strong>examples</strong> into the runtime workspace spawned from the root one using
							<strong>Run &gt; Run Configurations... &gt; Eclipse Application &gt; Run (&lt;language&gt;)</strong>.
						</p>
						<p>
							Each language consists of several Eclipse projects
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><strong>org.xtext.&lt;language&gt;</strong></td>
							<td>The base infrastructure</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.ui</strong></td>
							<td>The editor based on Eclipse</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.tests</strong></td>
							<td>Tests for the language</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.lib</strong></td>
							<td>Runtime library</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.example</strong></td>
							<td>Examples for using the language</td>
							</tr>
							</table>
							<p>
							 
							Some of the languages do not include all of these plug-ins but the general structure is always the same.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="xtend_primer" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							A Short Xtend Primer
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Any general code in the examples is implemented in <a href="http://www.xtend-lang.org">Xtend</a>. Xtend is 
							a more expressive and less verbose way to implement Java applications. It is 100% interoperable with Java APIs and 
							compiles to readable Java code. In addition, it uses the same expressions that we use in our example languages.
							In fact it is built with the very same API that is described in this document. This should give you a taste of 
							how powerful JVM-languages built with Xtext can actually be.
						</p>
						<p>
							Xtend is designed to be easy to learn for Java developers. In this section we will shortly describe
							the most important language features that were used in our examples. For a full description of the Xtend language, 
							please refer to the <a href="http://www.xtend-lang.org/documentation">Xtend documentation</a>.
						</p>
						<p>
							Just like a Java file, an Xtend file starts with a <code class="prettyprint lang-xtend">package</code> declaration and an <code class="prettyprint lang-xtend">import</code>
							section followed by one or more class declarations. Semicolons are optional and classes are <code class="prettyprint lang-xtend">public</code> by default.
							Xtend classes can extend other classes and implement interfaces just like in Java. It does not make any difference 
							whether they were originally declared in Xtend or in Java.
						</p>
						<p>
							<a name="xtend_property"></a>
							 
							JavaBean properties can be accessed directly by their name. The access will be automatically mapped to 
							the appropriate accessor method. That means you can write
							</p>
							<pre class="prettyprint lang-xtend linenums">
println(foo.bar)      // instead of println(foo.getBar())
foo.bar = baz         // instead of foo.setBar(baz)
foo.fooBars += foobar // instead of foo.getFooBars().add(foobar)</pre>
							<p>
							
							Empty parentheses on method calls can be skipped.
						</p>
						<p>
							<a name="xtend_methods"></a>
						</p>
						<p>
							Methods are introduced with the keyword <code class="prettyprint lang-xtend">def</code> or <code class="prettyprint lang-xtend">override</code> if they override/implement
							a super type's method. Methods are public if not specified otherwise. The value of the last expression is returned
							if no explicit return expression is used and the method's return type is not <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							<a name="xtend_variables"></a>
						</p>
						<p>
							Variables are declared with the keywords <code class="prettyprint lang-xtend">val</code> (final) or <code class="prettyprint lang-xtend">var</code> (non-final).
							Field declarations can use the same syntax as in Java.
						</p>
						<p>
							<a name="xtend_typeinferrence"></a>
						</p>
						<p>
							Xtend is statically typed, but you do not have to specify the type in a declaration if it can be inferred
							from the context:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val x = newArrayList('foo', 'bar', 'baz') // x is of type List&lt;String&gt;
def foo() {  // equivalent to  def int foo()...
  1
}</pre>
							<p>
						</p>
						<p>
							<a name="xtend_extension"></a>
							
							The methods of fields marked as <code class="prettyprint lang-xtend">extension</code> are callable in extension syntax. That means,
							you can put the first argument in front as if it were the receiver of the call, e.g.
							</p>
							<pre class="prettyprint lang-xtend linenums">
// assume the class Foo defines a method foo(Baz)
extension Foo

def bar(Baz baz) {
  baz.foo  // calls _foo.foo(baz)
}</pre>
							<p>
							
							Static methods can be put on the extension scope with a <code class="prettyprint lang-xtend">static extension</code> import, e.g.
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension java.util.Collections.*
...
val foo = singleton('foo') // calls Collections.&lt;String&gt;singleton('foo')</pre>
							<p>
						</p>
						<p>
							<a name="xtend_it"></a>
							
							In addition to Java's <code class="prettyprint lang-xtend">this</code>, you can define another implicit receiver variable named <code class="prettyprint lang-xtend">it</code>.
							As with <code class="prettyprint lang-xtend">this</code>, you can omit <code class="prettyprint lang-xtend">it</code> in feature calls, i.e.
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Foo {
  def foo(Bar it) {
    foo // will call it.foo() or if it doesn't exist this.foo()
  }
}</pre>
							<p>
						</p>
						<p>
							<a name="xtend_lambda"></a>
							
							Xtend provides lambda expressions. These are anonymous functions in square brackets. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
[String foo, String bar | foo + bar]  
  // a function (String foo, String bar) { foo + bar }</pre>
							<p>
							
							<a name="xtend_lambda_coercion"></a>
							
							As this is a bit bulky, there are more rules to make working with lambdas more attractive:
							</p>
							<ol>
								<li>When a lambda expression is the last argument in a method call, it can be put behind the closing parentheses.</li>
								<li>Lambdas are automatically coerced to interfaces with a single function. Parameter types will be
								inferred.</li>
								<li>If you skip the declaration of the only parameter, it will be implicitly called <code class="prettyprint lang-xtend">it</code>.</li>
							</ol>
							<p>
							
							</p>
							<pre class="prettyprint lang-xtend linenums">
new Thread [ println("Hello concurrent world") ] 
  // lambda will be coerced to a java.lang.Runnable
val list = newArrayList('fooooo', 'fo', 'foo')
list.sortBy[ length ]   
  // lambda is coerced to a function (String)=&gt;Comparable
  // equivalent to list.sortBy[String it | it.length]</pre>
							<p>
						</p>
						<p>
							<a name="xtend_templates"></a>
							
							Also noteworthy is the template expression, which allows defining interpolated multi-line string literals.
							In addition, the template expressions has intelligent whitespace handling and supports a special <code class="prettyprint lang-xtend">FOR</code> and 
							<code class="prettyprint lang-xtend">IF</code> construct, which is far better readable in this context.
						</p>
						<p>
							We most often use this expression in the examples to generate some synthetic Java boilerplate code. Here is
							an example from the <a href="#httpRouting">http routing language</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
'''
  String url =  request.getRequestURL().toString();
  &laquo;FOR route : routes&raquo;
    {
      java.util.regex.Matcher _matcher = _pattern&laquo;route.index&raquo;.matcher(url);
      if (_matcher.find()) {
        &laquo;FOR variable : route.url.variables&raquo;
            String &laquo;variable.name&raquo; = _matcher.group(&laquo;variable.index + 1&raquo;);
        &laquo;ENDFOR&raquo;
        &laquo;IF route.condition != null&raquo;
          if (&laquo;route.nameOfRouteMethod&raquo;Condition(request, response
            &laquo;FOR v : route.url.variables 
             BEFORE ", " 
             SEPARATOR ", "&raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;))
        &laquo;ENDIF&raquo;
        &laquo;route.nameOfRouteMethod&raquo;(request, response
          &laquo;FOR v : route.url.variables&raquo;, &laquo;v.name&raquo;&laquo;ENDFOR&raquo;);
      }
    }
  &laquo;ENDFOR&raquo;
'''</pre>
							<p>
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="scripting" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Scripting Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The scripting language allows writing code without any preludes such as package, class or method declarations.
							Just open a file and start coding. It's the simplest of the seven languages and is therefore a good starting point.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/scripting_screenshot.png" alt="" width="590" height="443">
							</div>
							<p>
						</p>
						<!--  section -->
						<section id="scripting_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							As you can see the language is straightforward: All you can do is write expressions and imports in any order.
							The expressions you see are the same as in Xtend and they are defined in its own grammar (called Xbase).
							They are syntactically very close to Java, but feature advanced concepts like lambda expressions
							and operator overloading. They support local type inference so you do not have to write types everywhere
							like in Java, but the expressions are still statically typed. 
							For a Java developer, the code should be self-explanatory. The Xbase expression language is exhaustively 
							covered in the <a href="http://www.eclipse.org/Xtext/documentation.html">Xtext documentation</a>.
						</p>
						<p>
							A script is compiled to a Java class with one main method. That is the script
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-scripting linenums">
println('Hello World!')</pre>
							<p>
						</p>
						<p>
							is compiled to the following Java source code
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
package my.first;

public class Application {
  public static void main(String[] args) {
    System.out.println("Hello World!");
  }
}</pre>
							<p>
						</p>
						<p>
							Note that the core language infrastructure such as the parser, linker and compiler is not Eclipse-dependent,
							but the compilation is integrated with Eclipse for convenience reasons. All 7 languages can be parsed, compiled and executed
							without Eclipse. We could also make use of the interpreter, which might make more sense for a scripting language.
							How to use and integrate the interpreter is explained in the section describing the <a href="#tortoise"></a> language.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							Make sure you have the projects <strong>org.xtext.scripting</strong> and <strong>org.xtext.scripting.ui</strong> in your workspace.
							Then start a new Eclipse by choosing <strong>Run &gt; Run Configurations... &gt; Eclipse Application &gt; Run (org.xtext.scripting)</strong>.
							Import the project <strong>org.xtext.scripting.examples</strong> into the newly spawned workspace using the <strong>Import existing projects
							into workspace</strong> wizard.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							To build a language with Xtext, you first have to define a grammar. As opposed to other parser generators,
							an Xtext grammar defines both, the lexical structure of the language and an object model (the AST or semantic model) 
							that is build during parsing. 
							For a more detailed description of the Xtext grammar language, please see the <a href="http://www.eclipse.org/Xtext/documentation.html">Xtext documentation</a>.
						</p>
						<p>
							The grammar for our DSL is rather simple. We inherit from <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.Xbase</code> to get the
							syntax of the expressions. As we want to refer to the type 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XBlockExpression.html"><abbr title="org.eclipse.xtext.xbase.XBlockExpression">XBlockExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XBlockExpression.java">(src)</a>, we have to import Xbase's Ecore model. The single type 
							inferred from this grammar goes into the Ecore model <code class="prettyprint lang-xtend">simpleExpressions</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.scripting.Scripting with org.eclipse.xtext.xbase.Xbase

generate scripting "http://www.xtext.org/scripting/Scripting"
import "http://www.eclipse.org/xtext/xbase/Xbase"

Script returns XBlockExpression:
  {Script} 
  // return an object of type Script which is a subtype of XBlockExpression
  ((expressions+=XExpressionInsideBlock | imports+=Import) ';'?)*;

Import:
  'import' importedNamespace=QualifiedNameWithWildcard;

QualifiedNameWithWildcard:
  QualifiedName '.*'?;</pre>
							<p>
						</p>
						<p>
							The main rule <strong>Script</strong> is defined to produce an object of type <code class="prettyprint lang-xtend">Script</code>, which is a subtype of <code class="prettyprint lang-xtend">XBlockExpression</code>. 
							A block expression simply contains any number of expressions. The rule <code class="prettyprint lang-xtend">XExpressionInsideBlock</code> is defined in the
							Xbase grammar. Usually block expressions are surrounded by curly braces, but of course we do not
							want to force anybody to write curly braces at the beginning and the end of a simple script.
						</p>
						<p>
							In addition to expressions you can have any number of imports. Xtext has a very simple way to let you
							define imports, all you need to do is name a feature <code class="prettyprint lang-xtend">importedNamespace</code> and it will be interpreted
							as a namespace import.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							To make our language executable, we have to define how its concepts relate to Java concepts. In Xtext, this
							is defined by the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer">IJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">(src)</a>. The language
							generator automatically generates an Xtend stub for it. Nevertheless, it is up to the language developer to 
							implement the <code class="prettyprint lang-xtend">infer()</code> method.
						</p>
						<p>
							This hook is not only used to explain how to generate Java code, but also to give expressions a proper
							scope and to make your DSL constructs visible by other JVM languages. The Java type system is used as
							a common hub to integrate arbitrary languages with each other.
						</p>
						<p>
							The inferrer is written in Xtend, if you are not yet familiar with it, you should read at least the 
							<a href="#xtend_primer">Xtend Primer</a> first.
						</p>
						<p>
							The JVM model inferrer code for the scripting language looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ScriptingJvmModelInferrer extends AbstractModelInferrer {
  
  @Inject extension JvmTypesBuilder

  def dispatch void infer(Script script, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    val className = script.eResource.URI.trimFileExtension.lastSegment
    acceptor.accept(script.toClass(className)).initializeLater [
      // the class gets one main method
      members += script.toMethod('main', script.newTypeRef('void')) [
        parameters += script.toParameter('args', 
            script.newTypeRef('java.lang.String')).addArrayTypeDimension)
        setStatic(true)
        // Associate the script as the body of the main method
        body = script
      ]
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							It maps each script to one Java class with a main method. Note the use of <code class="prettyprint lang-xtend">script</code> as a receiver
							for all the factory methods. When creating a Java element, you need to pass a context so Xtext knows
							what the origin of a Java element is. This is used throughout the workbench for features like find references,
							call hierarchies, rename refactoring and more.
						</p>
						<p>
							As the whole script is an expression it is associated with the body of the main method. That association is important 
							since it defines the scope of the expression. It includes the variables, fields and methods that are visible as
							well as which return type is expected.
						</p>
						<p>
							In this case <code class="prettyprint lang-java">void</code> is expected, so you would get an error when using a return expression. Also the
							parameter <code class="prettyprint lang-xtend">args</code> defined in the main method is now on the scope. So you could write the following script:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-scripting linenums">
for (arg : args)
  println('-- '+arg)</pre>
							<p>
						</p>
						<p>
							As you can imagine, this is a fairly powerful way to put things on the scope implicitly.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="builddsl" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Build Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Build tools like Ant or <a href="http://www.gradle.org/">Gradle</a> decompose the build process into a set of tasks. A task can 
							stand for a compilation step, copying some files, bundling, running tests etc. The order of execution is calculated from 
							the dependencies of the defined tasks.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/builddsl_screenshot.png" alt="" width="590" height="447">
							</div>
							<p>
						</p>
						<p>
							This build language is a fully-statically typed language which combines the declarative approach of defining tasks
							and dependencies with the full power of a modern expression language. It is a bit similar to Gradle but statically typed 
							and with very good IDE support.
						</p>
						<!--  section -->
						<section id="builddsl_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							The above screenshot shows an examplary build script. A script has a couple of parameters. The 
							tasks define dependencies to other tasks. What happens if the task is executed is defined in a block
							within curly braces.
						</p>
						<p>
							A build script can be run from the command line, assigning values to the parameters in the syntax
							<code class="prettyprint lang-xtend">myscript --&lt;paramName&gt; &lt;value&gt;</code>.
						</p>
						<p>
							We have put most functionality of the language in the runtime library: Detecting the order of execution,
							parsing parameters, etc. The language itself focusses on the structural parts, and leaves the actions
							to Xbase. With this approach, it has proven beneficial to allow additional library methods to be added
							via the extension method mechanism. So we do not ship a library of tasks as e.g. Ant does.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the runtime workspace, open the <strong>BuildExample.build</strong> in the editor. The example project comes with 
							some sample java code to compile in the <strong>example-project</strong> folder. Choose <strong>Run as &gt; Build Task</strong> from the context
							menu of any task to execute it.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar of the DSL is once again quite slim:
							 
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.builddsl.BuildDSL with org.eclipse.xtext.xbase.Xbase

generate build "http://www.xtext.org/builddsl"

BuildFile:
  ("package" name=QualifiedName)?
  imports+=ImportDeclaration*
  declarations+=Declaration*;

ImportDeclaration:
  'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedNameWithWildCard:
  QualifiedName '.*'?;

Declaration:
  Task | Parameter;

Parameter:
  'param' type=JvmTypeReference? name=ValidID ('=' init=XExpression)?;

Task:
  'task' name=ValidID 
  ('depends' depends+=[Task|ValidID] (',' depends+=[Task|ValidID])*)?
  action=XBlockExpression;</pre>
							<p>
						</p>
						<p>
							First there is the usual package delaration and <strong>Import</strong> stuff. It is followed by the <strong>Declarations</strong>.
							A <strong>Declaration</strong> can be a <strong>Task</strong> or a <strong>Parameter</strong>. A <strong>Parameter</strong> can declare a type and an initialization
							expression. <strong>Tasks</strong> define dependencies on other tasks by means of an Xtext cross-reference. They also
							contain an action, which is a <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XBlockExpression.html"><abbr title="org.eclipse.xtext.xbase.XBlockExpression">XBlockExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XBlockExpression.java">(src)</a> from Xbase, thus everthing 
							is possible within a task.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							For each <strong>BuildFile</strong> we create a Java class that extends the library class 
							<abbr title="org.xtext.builddsl.lib.BuildScript">BuildScript</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/BuildScript.xtend">(src)</a>. We generate a main method allowing to execute the script as
							a Java application with command line parameters. The use of <code class="prettyprint lang-java">System.exit</code> allows to return error codes
							to the caller.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
package sample</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package sample;
...
public class SimpleBuild extends BuildScript {
...
  public static void main(final String[] args) {
    SimpleBuild script = new SimpleBuild();
    if (script.showHelp(args)) {
      System.exit(HELP);
    }
    System.exit(script.doBuild(args));
  }
...
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The respective inferrer code looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLJvmModelInferrer extends AbstractModelInferrer {

  @Inject extension JvmTypesBuilder
  @Inject ITypeProvider typeProvider

  def dispatch void infer(BuildFile file, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    val fqn = file.javaClassName
    val scriptName = Strings::lastToken(fqn, ".")
    acceptor.accept(file.toClass(fqn)).initializeLater [
      superTypes += file.newTypeRef(typeof(BuildScript))
...      
      val stringArray = 
          file.newTypeRef(typeof(String)).addArrayTypeDimension
      members += file.toMethod("main", file.newTypeRef(Void::TYPE)) [
        parameters += toParameter("args", stringArray)
        setStatic(true)
        body = [ append('''
          &laquo;scriptName&raquo; script = new &laquo;scriptName&raquo;();
          if (script.showHelp(args)) {
            System.exit(HELP);
          }
          System.exit(script.doBuild(args));
        ''') ]
      ]
    ]
...</pre>
							<p>
						</p>
						<p>
							Each <strong>Task</strong> becomes a method in the Java class. A <abbr title="org.xtext.builddsl.lib.DependsOn">@DependsOn</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/DependsOn.java">(src)</a> annotation
							communicates the dependencies to the runtime. The superclass will scan for such annotations and execute
							the dependencies in the right order.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
task print depends prepare {
  print(name)
}</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@DependsOn("prepare")
protected void print() {
  InputOutput.&lt;String&gt;print(this.name);
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The annotation part may be interesting, so here is the snippet from the inferrer:
							 
							</p>
							<pre class="prettyprint lang-xtend linenums">
// a method for the actual task body
members += file.tasks.map[ task | toMethod(task.methodName, task.newTypeRef(Void::TYPE)) [
  visibility = JvmVisibility::PROTECTED
  annotations += task.toAnnotation(typeof(DependsOn)) =&gt; [
    values += createJvmStringAnnotationValue =&gt; [
      values += task.depends.map[name]
    ]
  ]
  body = task.action
]]</pre>
							<p>
						</p>
						<p>
							Finally, we create a field with the <abbr title="org.xtext.builddsl.lib.Param">@Param</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/Param.java">(src)</a> annotation from each <strong>Parameter</strong>. 
							The superclass will make the so marked fields initializable from command line arguments.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
param name = 'World'</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@Param
public String name = "World";</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The type can be skipped. If there is an initialization expression, the parameter's type is inferred using
							the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/typing/ITypeProvider.html"><abbr title="org.eclipse.xtext.xbase.typing.ITypeProvider">ITypeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/ITypeProvider.java">(src)</a>. If nothing is specified, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> 
							is assumed. The Elvis-operator comes handy for this use case. The different sources are tried to find the
							best type for the field. In the inferrer, this looks like:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject ITypeProvider typeProvider
...
val type = declaredParameter.type 
  ?: typeProvider.getType(declaredParameter.init)
  ?: file.newTypeRef(typeof(String))</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validation</h2>
						<p>
							When <strong>Tasks</strong> are depending on each other, cycles will break the computation of the execution order.
							There is a check for this constraint in the validator <abbr title="org.xtext.builddsl.validation.BuildDSLValidator">BuildDSLValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/validation/BuildDSLValidator.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLValidator extends XbaseJavaValidator {
...
  @Check
  def void checkNoRecursiveDependencies(Task task) {
    task.findDependentTasks [ cycle |
      if (cycle.size == 1) {
        error('''The task '&laquo;task.name&raquo;' cannot depend on itself.''', 
            cycle.head, DECLARATION__NAME, CYCLIC_DEPENDENCY)
      } else {
        error('''There is a cyclic dependency that involves tasks &laquo;
                cycle.map[name].join(", ")&raquo;''', 
              cycle.head, DECLARATION__NAME, CYCLIC_DEPENDENCY)
      }
    ]
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_imports" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Static Imports</h2>
						<p>
							It is very likely that users want to add their own functionality, e.g. to format a file. To facilitate
							that, all imports in the build DSL are automatically treated like Xtend's <code class="prettyprint lang-xtend">static extension</code> 
							imports, too. That means, the static
							methods of an imported type are callable in <a href="#xtend_extension">extension syntax</a>. This is accomplished
							by binding our own <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/scoping/featurecalls/StaticImplicitMethodsFeatureForTypeProvider.html"><abbr title="org.eclipse.xtext.xbase.scoping.featurecalls.StaticImplicitMethodsFeatureForTypeProvider">StaticImplicitMethodsFeatureForTypeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/scoping/featurecalls/StaticImplicitMethodsFeatureForTypeProvider.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class AllImportsAreStaticFeatureProvider 
    extends StaticImplicitMethodsFeatureForTypeProvider {

  override getVisibleTypesContainingStaticMethods(
      Iterable&lt;JvmTypeReference&gt; hierarchy) {
    val buildFile = context.contents.get(0) as BuildFile
    val importedTypes = &lt;String&gt;newArrayList
    for (importDeclaration : buildFile.imports) {
      val importedTypeOrPackage = importDeclaration.importedNamespace
      if (!importedTypeOrPackage.endsWith(".*")) {
        importedTypes += importedTypeOrPackage
      }
    }
    val result = Maps::newLinkedHashMap(
      super.getVisibleTypesContainingStaticMethods(hierarchy))
    for (entry : result.entrySet) {
      val copy = Sets::newLinkedHashSet(entry.getValue)
      copy += importedTypes
      entry.value = copy
    }
    return result
  }
}</pre>
							<p>
						</p>
						<p>
							We also ship some predefined extension classes to enhance the Java classes <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>
							and <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html"><abbr title="java.lang.Class">Class</abbr></a>. These are bound in a customized 
							<abbr title="org.xtext.builddsl.scoping.BuildDSLExtensionClassNameProvider">BuildDSLExtensionClassNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/scoping/BuildDSLExtensionClassNameProvider.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLExtensionClassNameProvider extends ExtensionClassNameProvider {
  override simpleComputeExtensionClasses() {
    super.simpleComputeExtensionClasses =&gt; [
      put(typeof(File), typeof(FileExtensions))
      put(typeof(String), typeof(FileExtensions))
      put(typeof(Class), typeof(ClassExtensions))
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							As always, the new implementations have to be bound in the <abbr title="org.xtext.builddsl.BuildDSLRuntimeModule">BuildDSLRuntimeModule</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/BuildDSLRuntimeModule.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class BuildDSLRuntimeModule 
    extends org.xtext.builddsl.AbstractBuildDSLRuntimeModule {
...
  public Class&lt;? extends ExtensionClassNameProvider&gt; 
      bindExtensionClassNameProvider() {
    return BuildDSLExtensionClassNameProvider.class;
  }
  
  public Class&lt;? extends StaticImplicitMethodsFeatureForTypeProvider&gt; 
      bindStaticImplicitMethodsFeatureForTypeProvider() {
    return AllImportsAreStaticFeatureProvider.class;
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_library" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Operator Overloading</h2>
						<p>
							As we expect a build language to deal with files and directories a lot, we have extended the syntax 
							around these in the <abbr title="org.xtext.builddsl.lib.FileExtensions">FileExtensions</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/FileExtensions.xtend">(src)</a>. We leverage the fact that Xbase 
							allows to overload operators by means of library extensions. The following examples show how to avoid 
							the noisy constructor calls to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
val dir = 'someDir'.file
val file = dir / 'fileName.txt'
val theSameFile = 'someDir' / 'fileName.txt'</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
final File dir = FileExtensions.file("someDir");
final File file = FileExtensions.operator_divide(dir, "fileName.txt");
final File theSameFile = FileExtensions.operator_divide(
    "someDir", 
    "fileName.txt");</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The compiler replaces operators with method calls to methods named <code class="prettyprint lang-xtend">operator_&lt;operatorName&gt;()</code>.
							These have to be callable on the left operand, i.e. be a method of the left operands type or be added
							as an extension to the left operand type. In this case, we use the latter approach, since <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>
							as well as <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> are sealed types. To learn more about operators and operator overloading
							please consult the <a href="http://www.eclipse.org/Xtext/documentation.html#Xbase_Expressions_Operators">Xtext documentation</a>.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_launch" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Run as... Integration</h2>
						<p>
							To facilitate executing build scripts from within Java, we have extended Eclipse's launch support. The
							respective classes are <abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchDelegate">BuildDSLLaunchDelegate</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchDelegate.xtend">(src)</a>,
							<abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchShortcut">BuildDSLLaunchShortcut</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchShortcut.xtend">(src)</a> and 
							<abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchTabGroup">BuildDSLLaunchTabGroup</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchTabGroup.xtend">(src)</a>. Describing all the details would be a bit
							lengthy but it is quite straightforward if you are familiar with the launching API.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="mongoDB" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							DSL for MongoDB
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							<a href="http://www.mongodb.org">MongoDB</a> is a very popular document-based database management system. 
							In mongoDB, database entries (AKA <strong>documents</strong>) have fields, which are essentially <strong>(key, value)</strong> pairs.
							MongoDB is schema free, i.e. there are no rules, which fields have to be defined and of what type they are.
							This allows for very flexible and heterogeneous data structures and is a perfect match with JSON.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mongobeans_screenshot.png" alt="" width="590" height="446">
							</div>
							<p>
						</p>
						<p>
							OTOH, Java is statically typed: The available types, their field names and field types are known and validated 
							at compile time. The JavaBeans convention defines how instances can be manipulated. The standard mongoDB Java 
							driver reflects the fact that mongoDB is schema-free by providing mongo documents as plain Java maps.
						</p>
						<p>
							With this language you can describe statically typed Java-facades for MongoDB documents without hiding the dynamic
							nature of them. The language uses a tree-like syntax similar to JSON but lets you add static Java type information.
						</p>
						<!--  section -->
						<section id="mongo_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							In this project, we have created a small DSL <strong>mongoBeans</strong> based on Xtext that allows to create basic 
							entity classes. These are backed by mongoDB objects but provide a statically typed JavaBeans API. Think of 
							the language as a description how to map mongoDB documents to JavaBeans, in analogy to well known object 
							relational mappers.
						</p>
						<p>
							An example mongoBeans file looks like this:
							</p>
							<pre class="prettyprint lang-mongobeans linenums">
import java.util.*

package org.musicdb {
    // a mongo bean
    Artist {
        String name    // single valued property
        Album* albums  // array property
        // an operation
        Iterable&lt;Track&gt; getOevre() {
            albums.map[track].flatten
        }
    }

    // another mongo bean
    Album {
        String title 
        int year 
        // inline definition of a mongo bean
        Track {        
            String title
            int seconds
        }* tracks
    }
}</pre>
							<p>
						</p>
						<p>
							For each <strong>MongoBean</strong> definition in a <strong>MongoFile</strong> file, we generate a Java class that wraps a 
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a>. The class provides statically typed getter and setter methods for all 
							defined <strong>MongoProperties</strong>. In the implementation of these accessor methods we delegate to the wrapped
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and do all the casting and conversion work. For the <code class="prettyprint lang-xtend">Artist</code> in the 
							above example, this would look like
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean {

  private DBObject _dbObject;  
  ...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  ...
}</pre>
							<p>
						</p>
						<p>
							By using the generating Java code, the rest of the application can use a type-safe and 
							JavaBeans conformant API to access the data model. In addition, <strong>MongoBeans</strong> can define <strong>MongoOperations</strong>, 
							which are translated to Java methods. We can use <strong>MongoProperties</strong> as well as Java types inside the 
							operations' bodies.
						</p>
						<p>
							Client code could then look like this:
							</p>
							<pre class="prettyprint lang-java linenums">
Artist john = new Artist();
john.setName("John Coltrane");
Album album = new Album();
album.setTitle("A Love Supreme");
john.getAlbums().add(album);
Track...  // create some tracks and add them to the album
 
System.out.println(john.getName() + "'s Oevre");
for(Track track: john.getOevre()) 
  System.out.println(track.getTitle());

DBCollection dbCollection = ... // standard mongoDB driver code
dbCollection.save(john.getDBObject())</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="mongo_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In addition to the <a href="#common_requirements">common requirements</a>, you need the 
							<a href="http://www.mongodb.org/downloads">mongoDB implementation</a> for your platform. We have included 
							the mongoDB Java driver from <a href="http://download.eclipse.org/tools/orbit/downloads/">Eclipse Orbit</a> 
							in the code base.
						</p>
						<p>
							Import the projects into an Eclipse workspace and run the launch configuration
							<strong>Run (org.eclipse.xtext.mongobeans)</strong>. Import the example plug-in into the new workspace and run 
							<code class="prettyprint lang-xtend">MusicDBXtendTest</code> as a JUnit test.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The complete mongoBeans grammar looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.mongobeans.MongoBeans with org.eclipse.xtext.xbase.Xbase

generate mongoBeans "http://www.eclipse.org/xtext/mongobeans/MongoBeans"

MongoFile:
  elements+=AbstractElement*;

Import:
  'import' importedNamespace=QualifiedNameWithWildcard;

AbstractElement:
  Import | PackageDeclaration | MongoBean;

PackageDeclaration:
  'package' name=QualifiedName '{'
    elements+=AbstractElement*
  '}';

MongoBean:
  name=ValidID '{'
    features+=AbstractFeature*
  '}';

AbstractFeature:
  MongoOperation | MongoProperty;

MongoProperty:
  (type=JvmTypeReference | inlineType=MongoBean) (many?='*')? name=ValidID;

MongoOperation:
  =&gt;(returnType=JvmTypeReference name=ValidID '(') 
    (parameters+=FullJvmFormalParameter 
    	(',' parameters+=FullJvmFormalParameter)*)? 
  ')' 
  body=XBlockExpression;

QualifiedNameWithWildcard:
  QualifiedName (".*")?;</pre>
							<p>
						</p>
						<p>
							The language inherits from the <code class="prettyprint lang-xtend">Xbase</code> grammar in order to allow Xbase expressions and references to Java 
							elements. A <strong>MongoFile</strong> contains any number of <strong>AbstractElements</strong>, which can be <strong>PackageDeclarations</strong>,
							<strong>Imports</strong> or <strong>MongoBeans</strong>. <strong>Imports</strong> use Xtext's naming convention <code class="prettyprint lang-xtend">importedNamespace</code> to automatically 
							shorten qualified names of matching elements. Note that as opposed to Java, <strong>PackageDeclarations</strong> can be nested.     
							<strong>MongoBeans</strong> define statically typed <strong>MongoProperties</strong>, which can be single-valued or multi-valued denoted by an 
							<code class="prettyprint lang-xtend">*</code> following the type name. The type of a <strong>MongoProperty</strong> can also be defined inline. <strong>MongoBeans</strong> can 
							also define <strong>MongoOperations</strong>. The body of such an operation is an <strong>XBlockExpression</strong> from Xbase.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							The JVM model inference is implemented in the <abbr title="org.xtext.mongobeans.jvmmodel.MongoBeansJvmModelInferrer">MongoBeansJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/jvmmodel/MongoBeansJvmModelInferrer.xtend">(src)</a>.
							As the generated code is quite rich, this is the most complex component of this language.
						</p>
						<p>
							For each <strong>MongoBean</strong>, we create a Java class implementing the interface <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>.
							This interface is the first type of a small runtime library that has to be on the classpath at runtime.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
package org.musicdb {
  Artist { ...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package org.musicdb;
...
public class Artist implements IMongoBean {  ...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
@Inject extension IQualifiedNameProvider  
...
def dispatch void infer(MongoFile file, 
                        IJvmDeclaredTypeAcceptor acceptor, 
                        boolean isPreIndexingPhase) {
  for(bean : file.eAllOfType(typeof(MongoBean))) {
       acceptor.accept(bean.toClass(bean.fullyQualifiedName))
         .initializeLater([
           documentation = bean.documentation
           superTypes += newTypeRef(bean, 'org.xtext.mongobeans.IMongoBean')
... // calling various methods to create Java members
    // from the AbstractFeatures
         ])
  }
}</pre>
							<p>
						</p>
						<p>
							First, it finds all elements of type <strong>MongoBean</strong> in the given <strong>MongoFile</strong>. For each of these, it creates a new 
							Java class. Then the documentation is copied and the interface <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>
							is added to the list of supertypes. This will also insert a Java import at the appropriate location.
						</p>
						<p>
							Each <strong>MongoBean</strong> wraps a <a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a>, which is represented as a Java field with a 
							getter. There are two constructors, one for a given <a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and one that 
							creates a new one. We have to store the class name in the DB object, if we want to be able to restore
							JavaBeans from query results.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
Artist { ...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean { 
  private DBObject _dbObject;
  
  public DBObject getDbObject() {
    return this._dbObject;
  }

  public Artist(final DBObject dbObject) {
    this._dbObject = dbObject;
  }
  
  public Artist() {
    _dbObject = new BasicDBObject();
    _dbObject.put(JAVA_CLASS_KEY, "org.musicdb.Artist");
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code does this in two separate methods: One for the property <code class="prettyprint lang-xtend">_dbObject</code> and another
							for the constructors.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addDbObjectProperty(JvmDeclaredType 
                                  inferredType, 
                                  MongoBean bean) {
  inferredType.members += bean.toField('_dbObject', 
      newTypeRef(bean, 'com.mongodb.DBObject'))
  inferredType.members += bean.toGetter('dbObject', '_dbObject',
      newTypeRef(bean, 'com.mongodb.DBObject'))
}

def protected addConstructors(JvmDeclaredType inferredType, 
                              MongoBean bean) {
  inferredType.members += bean.toConstructor [
    documentation = '''...'''
    parameters += toParameter("dbObject", 
        newTypeRef(bean, 'com.mongodb.DBObject'))
    body = [
      append('''
        this._dbObject = dbObject;
      ''')
    ]
  ]
  inferredType.members += bean.toConstructor [
    documentation = '''...'''
    body = [
      append('''
        _dbObject = new com.mongodb.BasicDBObject();
        _dbObject.put(JAVA_CLASS_KEY, "&laquo;inferredType.identifier&raquo;");
      ''')
    ]
  ]
}</pre>
							<p>
						</p>
						<p>
							Next on our list are the getters and setters delegating to the <code class="prettyprint lang-xtend">_dbObject</code>. We have to handle four
							cases: Properties with a type that can be handled by the mongoDB Java-driver directly (most primitive types,
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html"><abbr title="java.util.Date">Date</abbr></a>, etc.), <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>
							properties, and their respective multi-valued counterparts:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
...
  String name     // primitive property
  Artist friend   // bean-type property
  String* aliases // multi-valued primitive property
  Album* albums   // multi-valued bean-type property
...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  
  public Artist getFriend() {
    return WrappingUtil.wrapAndCast(
        (DBObject) _dbObject.get("friend"));
  }
  public void setFriend(final Artist friend) {
     _dbObject.put("friend", WrappingUtil.unwrap(friend));
  }
  
  public List&lt;String&gt; getAliases() {
    return (List&lt;String&gt;) _dbObject.get("aliases");
  }
  
  private MongoBeanList&lt;Album&gt; _albums;
  public List&lt;Album&gt; getAlbums() {
    if(_albums==null)
      _albums = new MongoBeanList&lt;Album&gt;(_dbObject, "albums");
    return _albums;
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The runtime helper class <abbr title="org.xtext.mongobeans.lib.WrappingUtil">WrappingUtil</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/WrappingUtil.xtend">(src)</a> does the conversion between 
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>. For multi-valued <strong>MongoProperties</strong>
							we need getters only. If they have a primitive type, they can be handled by the Java-driver directly. Multi-valued 
							<strong>MongoBean</strong> typed properties require a special <abbr title="org.xtext.mongobeans.lib.MongoBeanList">MongoBeanList</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/MongoBeanList.xtend">(src)</a> to automatically 
							wrap/unwrap the elements.
						</p>
						<p>
							The corresponding inferrer code does not show anything particularly new so we skip most of it for brevity. To detect 
							whether a type is an <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a> or a primitive mongoDB type, we use the last helper 
							class <abbr title="org.xtext.mongobeans.jvmmodel.MongoTypes">MongoTypes</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/jvmmodel/MongoTypes.xtend">(src)</a>. The following snippet shows the inference of the getter for
							multi-valued properties:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addListAccessor(JvmDeclaredType inferredType,
                              MongoProperty property) {
  if(isMongoPrimitiveType(property.jvmType)) {
    inferredType.members += property.toMethod(
      'get' + property.name.toFirstUpper, 
       newTypeRef(property, 'java.util.List', 
         property.jvmType.asWrapperTypeIfPrimitive)
    ) [
...
    ]    
  } else {
    inferredType.members += property.toField(
      '_' + property.name, newTypeRef(property,
        'org.xtext.mongobeans.MongoBeanList', property.jvmType))
    inferredType.members += property.toMethod(
      'get' + property.name.toFirstUpper,
      newTypeRef(property, 'java.util.List', property.jvmType)
    ) [
 ...</pre>
							<p>
						</p>
						<p>
							Last but not least, we infer Java methods for <strong>MongoOperations</strong>.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
...
  Iterable&lt;Track&gt; getOevre() {
      albums.map[tracks].flatten
  }
...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
...
  public Iterable&lt;Track&gt; getOevre() {
    // some java code you really don't care about 
    // but it should just do the right thing
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code for this particular task is surprisingly simple, as we can directly associate the
							body of the <strong>MongoOperation</strong>  to the generated Java method. The Xbase compiler will automatically 
							transform that to Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addMethod(JvmDeclaredType inferredType, 
                        MongoOperation operation) {
  inferredType.members += operation.toMethod(operation.name, 
      operation.returnType) [
    documentation = operation.documentation
    for(parameter: operation.parameters)
      parameters += parameter.toParameter(parameter.name, 
          parameter.parameterType)
    body = operation.body
  ]
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="mongo_nameProvider" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Qualified Name Provider</h2>
						<p>
							By default, the qualified name of an element is calculated by joining all the simple names of its 
							containers with a dot. In our example, the <strong>MongoBean</strong> <code class="prettyprint lang-xtend">Track</code> would consequently be named 
							<code class="prettyprint lang-xtend">org.musicdb.Album.track.Track</code>. To ignore properties and beans on the path, we implemented our own
							<abbr title="org.xtext.mongobeans.scoping.MongoQualifiedNameProvider">MongoQualifiedNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/scoping/MongoQualifiedNameProvider.xtend">(src)</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoQualifiedNameProvider extends XbaseQualifiedNameProvider {
  
  def qualifiedName(MongoBean mongoBean) {
    val packageDeclaration = 
      mongoBean.getContainerOfType(typeof(PackageDeclaration))
    if(packageDeclaration != null) 
      packageDeclaration.fullyQualifiedName.append(mongoBean.name)
    else
      return QualifiedName::create(mongoBean.name)
  }
}</pre>
							<p>
						</p>
						<p>
							To make the framework pick up our customization, we have to add a binding in the respective 
							Guice module <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/MongoBeansRuntimeModule.java">(src)</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Override
public Class&lt;? extends IQualifiedNameProvider&gt; bindIQualifiedNameProvider() {
  return MongoQualifiedNameProvider.class;
}</pre>
							<p>
						</p>
						<p>
							See the <a href="http://www.eclipse.org/Xtext/documentation.html">Xtext documentation</a> to learn more about Xtext's 
							dependency injection.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validation</h2>
						<p>
							The Java driver for mongoDB cannot map all Java types to mongoDB types. To enforce that constraint, 
							we have added the <abbr title="org.xtext.mongobeans.validation.MongoBeansValidator">MongoBeansValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/validation/MongoBeansValidator.xtend">(src)</a>. It also checks for missing types 
							and avoids name collisions in the generated code with the implicitly defined property <code class="prettyprint lang-xtend">dbObject</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansValidator extends XbaseJavaValidator {
...
  @Inject extension MongoTypes mongoTypes
  
  @Check def checkMongoProperty(MongoProperty it) {
    if (name == 'dbObject') 
      error("Illegal property name 'dbObject'", 
            ABSTRACT_FEATURE__NAME, 
            ILLEGAL_PROPERTY_NAME, 
            '_' + name)
    if (type != null) {
      if (!type.isMongoType)
        error('Only MongoBeans and mappable types are allowed',
              MONGO_PROPERTY__TYPE, ILLEGAL_TYPE)
    } else if (inlineType == null) {
      error('Type must be set', ABSTRACT_FEATURE__NAME, MISSING_TYPE)
    }
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="mongo_visual" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">IDE Enhancements</h2>
						<p>
							The validator from the previous section raises an error <code class="prettyprint lang-xtend">ILLEGAL_PROPERTY_NAME</code> when a property is named <strong>dbObject</strong>.
							We have implemented a quick fix to replace the invalid name:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansQuickfixProvider extends XbaseWithAnnotationsQuickfixProvider {

  @Fix(MongoBeansValidator::ILLEGAL_PROPERTY_NAME)
  def void capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 
        'Rename to ' + issue.data.head, 
        '''Rename property to &laquo;issue.data.head&raquo;.''', 
        null) [
      xtextDocument.replace(issue.offset, issue.length, issue.data.head)
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							To improve the language IDE visually, we have tuned the 
							outline <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.ui/src/org/xtext/mongobeans/ui/outline/MongoBeansOutlineTreeProvider.xtend">(src)</a> a bit
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansOutlineTreeProvider extends DefaultOutlineTreeProvider {
  // don't show children of operations
  def _isLeaf(MongoOperation operation) {
    true
  }
  
  // show inline declared MongoBeans
  def _createChildren(IOutlineNode parentNode, MongoProperty property) {
    if(property.inlineType != null)
      parentNode.createNode(property.inlineType)
  }
  
  def _isLeaf(MongoProperty property) {
    property.inlineType == null
  }
}</pre>
							<p>
						</p>
						<p>
							and the label provider <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.ui/src/org/xtext/mongobeans/ui/labeling/MongoBeansLabelProvider.xtend">(src)</a> as well:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansLabelProvider extends XbaseLabelProvider {
...  
  override image(Object element) {
    // icons are stored in the 'icons' folder of this project
    switch element {
      MongoBean: 'Letter-B-blue-icon.png'
      MongoProperty: 'Letter-P-orange-icon.png'
      MongoOperation: 'Letter-O-red-icon.png'
      Import: 'imp_obj.gif'
      PackageDeclaration: 'package_obj.gif'
      default:
        super.image(element)
    }
  }</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="guice" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							DSL for Guice
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The Guice DSL is a little language that lets you define Guice modules 
							in a readable and declarative way.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/guicemodules_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<!--  section -->
						<section id="guice_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							Guice is a great dependency injection container, which uses Java types and annotations to declare and 
							refer to injection points. You could for instance have the following field:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Inject
@Named("properties") Map&lt;String,String&gt; properties;</pre>
							<p>
						</p>
						<p>
							A module is used to tell the framework what instance to inject into such injection points.
							For that, Guice comes with a fluent interface API written in Java and a couple of tricks (e.g. TypeLiteral) to
							make the configuration as readable and maintainable as possible.
						</p>
						<p>
							You could for instance declare the following module:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class MyModule implements Module {
  @Override
  public void configure(Binder binder) {
    Map&lt;String,String&gt; properties = Maps.newHashMap();
    properties.put("debugLevel", "info");
    
    binder.bind(new TypeLiteral&lt;Map&lt;String,String&gt;&gt;(){})
      .annotatedWith(Names.named("properties"))
      .toInstance(properties);
  }
}</pre>
							<p>
						</p>
						<p>
							The big advantage of using Java over an external text or XML file is that you can leverage
							the IDE and the type checking. We want to have that. The downside is that you have to trick (i.e. 
							<a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/TypeLiteral.html"><abbr title="com.google.inject.TypeLiteral">TypeLiteral</abbr></a>) a lot in
							order to have an agreeable syntax. Also since the configuration is 'hidden' in a method implementation and not
							really declarative you cannot validate a Guice module at compile time.
						</p>
						<p>
							The Guice DSL described in this section lets you describe the module above like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-guice linenums">
MyModule {
  @Named("properties") Map&lt;String,String&gt; 
    to-instance newHashMap('debugLevel' -&gt; 'info')
}</pre>
							<p>
						</p>
						<p>
							This not only uses the exact same syntax one uses in any injection points, but also opens up all kinds
							of possibilities for static analysis. Usually the instantiation of a Guice injector at runtime takes quite some time,
							because then all the very helpful validation is done. A language like the one described in this section could
							do all theses analysis at compile time, that way speeding up start up of the whole application significantly.
						</p>
						</section>
						<!--  section -->
						<section id="guice_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the example located in the project <strong>org.xtext.guicemodules.examples</strong> two modules are declared, one
							for a possible runtime scenario and one for a test scenario (yes, you sometimes want a module for tests).
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-guice linenums">
import com.acme.*
import com.acme.impl.*

com.acme.RuntimeModule {
  bind DataProvider to FileDataProvider
  bind @DataFile String to-instance 'my-data.txt'
}

com.acme.TestModule mixin RuntimeModule {
  bind DataProvider to-instance [| 'dummy-data' ]
  bind LoggingService to BufferedLoggingService
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="guice_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar is less than 30 lines long. It allows declaring any number of imports using the import mechanism
							already described for the <a href="#scripting_grammar">scripting language</a>. A module can 'mixin' any number of other modules, which allows
							to reuse existing modules but override keys with different bindings. The mixin feature is described as a 
							cross reference to another <code class="prettyprint lang-xtend">ModuleAST</code>. Cross references are covered in detail in the <a href="http://www.eclipse.org/Xtext/documentation.html#cross_reference">Xtext documentation</a>.
						</p>
						<p>
							The language allows binding keys to other keys and to instances. Other concepts like binding to providers
							is something you could do, but would not help in getting the idea across. Everybody is encouraged to fork
							this first prototype and build something really useful ;-)
						</p>
						<p>
							Instead of extending <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.Xbase</code> the grammar <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations</code>
							is extended which adds full support for annotations. You just have to refer to the rule <code class="prettyprint lang-xtend">XAnnotation</code>
							as it is done in the rule <code class="prettyprint lang-xtend">KeyAST</code>. Btw. it is sometimes a good idea to suffix (or prefix) the AST
							node types to avoid confusion when working with a library where concepts are named similarly.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.guicemodules.GuiceModules 
  with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
 
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate guiceModules "http://www.xtext.org/guicemodules/GuiceModules"
  
ModulesAST :
  imports+=ImportAST*
  modules+=ModuleAST*;

ModuleAST :
  name=QualifiedName 
  ('mixin' mixins+=[ModuleAST|QualifiedName] 
    (',' mixins+=[ModuleAST|QualifiedName])*)? 
  '{'
    bindings+=BindingAST*
  '}';

BindingAST:
  'bind' from=KeyAST 
  ('to' to=KeyAST | 'to-instance' toInstance=XExpression)?;

KeyAST:
  annotation=XAnnotation? type=JvmTypeReference;

ImportAST:
  'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedNameWithWildCard:
  QualifiedName '.*'?;</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="guice_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							A module is mapped to a single java class. The 'mixin' modules are not translated to Java inheritance
							but to a delegation approach. Here is how a simple module declaration with a single mixed-in module is
							translated.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-guice linenums">
MyModule mixin OtherModule { 
}</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public class MyModule implements Module {

  private OtherModule otherModule = new OtherModule();

  public void configure(final Binder binder) {
    configure(binder, new HashSet&lt;com.google.inject.Key&lt;?&gt;&gt;());
  }

  public void configure(final Binder bind, 
      final Set&lt;Key&lt;? extends Object&gt;&gt; usedKeys) {
    try {
      testModule.configure(bind, usedKeys);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							As you can see, the language simply leverages the nice <code class="prettyprint lang-xtend">equals</code>/<code class="prettyprint lang-xtend">hashCode</code> implementation 
							of Guice's <a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Key.html"><abbr title="com.google.inject.Key">Key</abbr></a> to implement the override semantics of mixed-in modules.
						</p>
						<p>
							The corresponding parts in <abbr title="org.xtext.guicemodules.jvmmodel.GuiceModulesJvmModelInferrer">GuiceModulesJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.guicemodules/src/org/xtext/guicemodules/jvmmodel/GuiceModulesJvmModelInferrer.xtend">(src)</a> are:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
acceptor.accept(module.toClass(module.fullyQualifiedName))
  .initializeLater [
...      
  // declare a field for each mixed-in module
  for (mixin : module.mixins) {
    if (!mixin.eIsProxy)
      members += mixin.toField( mixin.simpleName, 
          newTypeRef(mixin.fullyQualifiedName.toString)) [
        setInitializer [
          append('''new &laquo;mixin.name&raquo;()''')
        ]
      ]
  }
  
  // and later when declaring the configure method
  members+= module.toMethod("configure", voidType.createTypeRef) [
    documentation = 'Registers bindings for keys not present in ...'
    parameters += module.toParameter("bind", binderType.createTypeRef)
    parameters += module.toParameter("usedKeys", setType.createTypeRef( 
        keyType.createTypeRef(wildCard)))
    body = [append('''
      try {
        ...some other code
        &laquo;FOR mix : module.mixins&raquo;
          &laquo;mix.simpleName&raquo;.configure(bind, usedKeys);
        &laquo;ENDFOR&raquo;
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    ''')]
  ]</pre>
							<p>
						</p>
						<p>
							Expressions are used in <code class="prettyprint lang-xtend">to-instance</code> bindings and as always they need a proper scope to live in.
							The simplest way is to declare a private method for each expression.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (binding : module.bindings) {
  // if it's a toInstance binding, create a synthetic
  // method to give the expression a proper scope
  if (binding.toInstance != null) {
    members += binding.toMethod(binding.syntheticToInstanceName, 
        binding.from.type) [
      visibility = JvmVisibility::PRIVATE
      body = binding.toInstance
    ]
  } 
...</pre>
							<p>
						</p>
						<p>
							In order to obtain instances of annotations as required by Guice's <a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Binder.html"><abbr title="com.google.inject.Binder">Binder</abbr></a>,
							we declare dummy fields for annotated types and use reflection to get corresponding instances.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-guice linenums">
com.acme.RuntimeModule {
  bind @DataFile String to-instance 'my-data.txt'
}</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
// declaration of dummy field with annotation
@DataFile
private String _from0;
  
// and later the following code is used to get the key
  Key&lt;java.lang.String&gt; key = 
      Key.get(new TypeLiteral&lt;String&gt;(){}, 
          getClass().getDeclaredField("_from0").getAnnotations()[0]);</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The two sections in the model inferrer responsible for this are:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (binding : module.bindings) {
...
  // if a key has an annotation, declare a field so we can use that 
  // annotation via reflection later.
  if (binding.to?.annotation != null) {
    members += binding.toField(binding.to.syntheticName, binding.to.type) [
      newHashSet(binding.to.annotation).translateAnnotationsTo(it)
      visibility = JvmVisibility::PRIVATE
    ]
  }
  if (binding.from.annotation != null) {
    members += binding.toField(binding.from.syntheticName, 
        binding.from.type) [
      newHashSet(binding.from.annotation).translateAnnotationsTo(it)
      visibility = JvmVisibility::PRIVATE
    ]
  }
}

// and the following method
def guiceKey(KeyAST it) '''
  Key.get(new TypeLiteral&lt;&laquo;type.identifier&raquo;&gt;(){}&laquo;
  IF annotation != null
  &raquo;, getClass().getDeclaredField("&laquo;syntheticName&raquo;").getAnnotations()[0]&laquo;
  ENDIF&raquo;)'''</pre>
							<p>
						</p>
						<p>
							That is basically it. The rest should hopefully be self-explanatory.
						</p>
						</section>
						<!--  section -->
						<section id="guice_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validation</h2>
						<p>
							One of the sweet spots for a Guice modules DSL is the ability to do a lot of the validation usually done
							at runtime during compile time. Since this is just an example it just scratches the surface. There is
							just a single compiler check validating whether any used annotation is itself annotated with 
							<a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/BindingAnnotation.html"><abbr title="com.google.inject.BindingAnnotation">@BindingAnnotation</abbr></a>.
						</p>
						<p>
							This is the relevant code from <abbr title="org.xtext.guicemodules.validation.GuiceModulesValidator">GuiceModulesValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.guicemodules/src/org/xtext/guicemodules/validation/GuiceModulesValidator.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Check def checkAnnotationIsBindingAnnotation(XAnnotation it) {
  if (!annotationType.annotations.exists [ 
  	annotation.is(typeof(BindingAnnotation)) ])
    error("The annotation is not annotated with @BindingAnnotation", 
        XANNOTATION__ANNOTATION_TYPE)
}</pre>
							<p>
						</p>
						<p>
							It would be really cool to leverage the full information, which is available and analyze the dependencies
							transitively so you get feedback while you type for any unfulfilled dependencies. Also using all the
							information to compile a ready to use <a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Injector.html"><abbr title="com.google.inject.Injector">Injector</abbr></a> instead of a module seems 
							interesting.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="httpRouting" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Http Routing Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							This is a little language that lets you dispatch incoming HTTP requests.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/httprouting_screenshot.png" alt="" width="590" height="443">
							</div>
							<p>
						</p>
						<!--  section -->
						<section id="routing_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							For server-side web development one needs to match any incoming HTTP requests to some handling code. A request
							is defined by a HTTP method (i.e. GET, POST, etc.), a URL and maybe some other data (headers, parameters,
							etc.). In the Java world there are many different solutions to this problem. Java Servlets come with an external 
							configuration (web.xml), where you configure what servlet should be called for which URLs. JAX-RS (JSR-311) uses 
							annotations to match incoming URLs and other frameworks have their own external DSLs for that.
						</p>
						<p>
							The HTTP routing language explained in this section uses an approach very similar to the one from the
							<a href="http://playframework.org">Play framework</a>. You basically declare a list of URL patterns and explain
							what to do for each case. In contrast to play! which heavily relies on static methods, you can also declare
							so called dependencies which are translated to fields annotated with <code class="prettyprint lang-xtend">@Inject</code>. So this DSL plays
							nicely with dependency injection and especially with the <a href="#guice">Guice modules DSL</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-routing linenums">
inject GuessTheNumber controller

GET /guess/:theGuess
  do controller.handleGuess(theGuess)</pre>
							<p>
						</p>
						<p>
							As you can see, you can have named variable placeholders in the URL and use them in the <code class="prettyprint lang-routing">do</code>-part.
							There also is a <code class="prettyprint lang-routing">when</code>-part which allows to specify an additional condition using the request object
							as well as any parameters:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-routing linenums">
inject GuessTheNumber controller

GET /guess/:theGuess
  when !controller.isValidGuess(theGuess)
  do controller.handleWrongRange(theGuess)

GET /guess/:theGuess
  do controller.handleGuess(theGuess)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="routing_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							The example project's name is <strong>org.xtext.httprouting.examples</strong> and includes a simple but runnable number
							guessing game. Just start the server (an embedded Jetty) by running <abbr title="framework.StartServer">StartServer</abbr> as a
							Java Application. Then point your browser to the URL <a href="http://localhost:8080/guess">http://localhost:8080/guess</a>.
						</p>
						</section>
						<!--  section -->
						<section id="routing_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The Routing DSL extends org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations to make use of expressions
							predefined by <a href="http://www.eclipse.org/Xtext/#xbase">Xbase</a> plus support for Annotations.
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.httprouting.Route 
  with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

generate route "http://www.xtext.org/httprouting/Route"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase

Model :
  imports+=Import*
  declarations+=AbstractDeclaration*;

Import :
  'import' importedType=[ types::JvmType | QualifiedName];

AbstractDeclaration :
  Dependency | Route;

Dependency :
  'inject' annotations+=XAnnotation? type=JvmTypeReference name=ID;

Route :
  requestType=RequestType url=URL 
  ('when' condition=XExpression)? 
  'do' call=XExpression;

enum RequestType :
  GET | POST | PUT | DELETE | HEAD;

/**
 * matches URLs like 
 *   '/foo/bar.html' or 
 *   '/customer/:customerID/save'
 */
URL :
  {URL} 
  ( '/' | ('/' (QualifiedName | variables+=Variable))* 
  ('/' variables+=Variable wildcard?='*')?);

Variable :
  ':' name=ID;</pre>
							<p>
						</p>
						<p>
							The routing DSL defines imports by using cross references. This makes it possible to use content assist and
							get an error marker if the type does not exist. It is planned for an upcoming version of Xtext to provide
							an even better abstraction for importing Java types, including automatic support for IDE features like organizing imports.
						</p>
						<p>
							Other than that there should not be any surprises if you know the grammar language: A <strong>Model</strong> consists of
							any number of <strong>Imports</strong> followed by any number of <strong>Dependencies</strong> and <strong>Routes</strong>. A <strong>Route</strong> starts with a <strong>RequestType</strong>,
							i.e. HTTP method, followed by a <strong>URL</strong> pattern. Then an optional when-clause can be specified followed by
							a mandatory do-clause.
						</p>
						</section>
						<!--  section -->
						<section id="routing_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							In <abbr title="org.xtext.httprouting.jvmmodel.RouteJvmModelInferrer">RouteJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/jvmmodel/RouteJvmModelInferrer.xtend">(src)</a> you can see that a Java class 
							extending the class <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a> is derived.
							First the <strong>Dependencies</strong> are translated to Java fields. This is almost a one-to-one mapping.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
// translate the dependencies to fields annotated with @Inejct
for (field : model.declarations.filter(typeof(Dependency))) {
  members += field.toField(field.name, field.type) [
    annotations += field.toAnnotation(typeof(Inject))
    field.annotations.translateAnnotationsTo(it)
  ]
}</pre>
							<p>
						</p>
						<p>
							Next up a field for the <strong>URL</strong> patterns is generated and a method for the used expressions, such giving them
							a proper scope and context.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
// declare fields for the URL regexp, a method for each when-part 
// and of course the call part of a route
for (route : model.routes.filter[ url != null ]) {
  members += route.toRoutePatternField
  if (route.condition != null)
    members += route.toRouteConditionMethod
  members += route.toRouteCallMethod
}</pre>
							<p>
						</p>
						<p>
							Note that the code in a model inferrer has to be very defensive, because it is called for any kind of
							broken models. You just cannot assume that the URL is set although it is mandatory in the grammar, because
							the user might have written syntactically incorrect code.
						</p>
						<p>
							Next up the handler methods from <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a> are implemented such that they
							dispatch according the URL patterns and when-clauses. Here is a translated example:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.acme.GuessTheNumber

inject GuessTheNumber controller

GET /guess/:theGuess
  do controller.handleGuess(theGuess)</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@SuppressWarnings("serial")
public class NumberGuessing extends HttpServlet {
  @Inject
  private GuessTheNumber controller;
  
  private static Pattern _pattern2 = Pattern.compile("/guess/(\\w+)");
  
  public void _doGet2(final HttpServletRequest request, 
                      final HttpServletResponse response, 
                      final String theGuess) {
    this.controller.handleGuess(theGuess);
  }
  
  @Override
  public void doGet(final HttpServletRequest request, 
                    final HttpServletResponse response) {
    String url =  request.getRequestURL().toString();
    {
      java.util.regex.Matcher _matcher = _pattern2.matcher(url);
      if (_matcher.find()) {
        String theGuess = _matcher.group(1);
        _doGet2(request, response, theGuess);
      }
    }
  }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							As you can see the expression <code class="prettyprint lang-xtend">controller.handleGuess(theGuess)</code> is put into a method with
							three parameters. This is done in the following method from <abbr title="org.xtext.httprouting.jvmmodel.RouteJvmModelInferrer">RouteJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/jvmmodel/RouteJvmModelInferrer.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
/**
 * Creates a method for the route's target call.
 * Gives scope and live to the expression.
 */
def protected toRouteCallMethod(Route route) {
  route.toMethod(route.nameOfRouteMethod, route.newTypeRef(Void::TYPE)) [
    parameters += route.toParameter("request",  
        route.newTypeRef(HTTP_REQUEST))
    parameters += route.toParameter("response", 
        route.newTypeRef(HTTP_RESPONSE))
    for (variable : route.url.variables) {
      parameters += variable.toParameter(variable.name, 
        route.newTypeRef(typeof(String)))
    }
    body = route.call
  ]
}</pre>
							<p>
						</p>
						<p>
							Just because of that code you can now refer to the local variables <code class="prettyprint lang-xtend">request</code>, <code class="prettyprint lang-xtend">response</code>, and
							<code class="prettyprint lang-xtend">theGuess</code>. Also it defines that the expected type is <code class="prettyprint lang-xtend">void</code> so you are not allowed to
							write thing like <code class="prettyprint lang-xtend">return 42</code>.
						</p>
						</section>
						<!--  section -->
						<section id="routing_improts" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validated Imports</h2>
						<p>
							Unlike in the other examples, where we used Xtext's default imports approach, in the routing DSL we use real cross-references
							to Java types in imports. Although it is not as convenient to implement, it has the advantage having imports validated 
							and getting proper content assist in your imports section. For future releases it is planned to significantly
							improve support for import sections for JVM languages including nice IDE features like organize imports.
						</p>
						<p>
							To get a bit of this goodness you first use a slightly different <strong>Import</strong> rule in the grammar. Instead of using the
							magic 'importedNamespace' feature name we simply use a cross reference to <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmType.html"><abbr title="org.eclipse.xtext.common.types.JvmType">JvmType</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmType.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Import :
  'import' importedType=[ types::JvmType | QualifiedName];</pre>
							<p>
						</p>
						<p>
							In addition to that you need to explain how the import of a type contributes to the namespace resolution.
							For that you subclass the scope provider as done in <abbr title="org.xtext.httprouting.scoping.RouteImportedNamespaceScopeProvider">RouteImportedNamespaceScopeProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/scoping/RouteImportedNamespaceScopeProvider.xtend">(src)</a>
							and override the method <code class="prettyprint lang-xtend">internalGetImportedNamespaceResolvers</code> like in the following:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override internalGetImportedNamespaceResolvers(EObject context, 
    boolean ignoreCase) {
  val model = context.getContainerOfType(typeof(Model))
  return model.imports.map [
      createImportedNamespaceResolver(importedType.qualifiedName, 
         ignoreCase)
    ].filterNull.toList
}</pre>
							<p>
						</p>
						<p>
							To register your customized class you go into the runtime module <abbr title="org.xtext.httprouting.RouteRuntimeModule">RouteRuntimeModule</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/RouteRuntimeModule.java">(src)</a>
							and override the corresponding binding:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Override
public void configureIScopeProviderDelegate(Binder binder) {
  binder.bind(IScopeProvider.class).annotatedWith(
      Names.named(AbstractDeclarativeScopeProvider.NAMED_DELEGATE))
  .to(RouteImportedNamespaceScopeProvider.class);
}</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="template" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Template Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							This is a little template language specialized in generating HTML documents.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/template_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							The language allows web designers to do their job and lets developers put in the dynamic parts. 
							The syntax and terminals are chosen to be readable and allow rendering the templates in the browser as 
							well as in any HTML 5 compatible WYSIWYG editors. Still, when opened in the DSL editor you get the 
							fully featured, statically typed Eclipse editor.
						</p>
						<!--  section -->
						<section id="templates_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							A template language works in two modes: Plain text mode, where everything goes directly into the output
							and the expression mode, where expressions have to be evaluated and the result is inserted into the text.
							To switch between text mode and expression mode, we use the French quotes <code class="prettyprint lang-xtend">&laquo;</code> and <code class="prettyprint lang-xtend">&raquo;</code>. A document
							starts in text mode.
						</p>
						<p>
							The template will be compiled to a Java class with a <code class="prettyprint lang-xtend">generate(params)</code> method. You can provide 
							additional information like a package declaration, imports and parameters in the preamble inside a 
							template at the beginning of the document.
						</p>
						<p>
							We provide additional <code class="prettyprint lang-templates">FOR-ENDFOR</code> and <code class="prettyprint lang-templates">IF-ELSE-ENDIF</code> statements to
							iterate / branch over fixed text blocks. To distinguish them from the Xbase expressions with the same
							names, they are in uppercase.
						</p>
						</section>
						<!--  section -->
						<section id="templates_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the runtime workspace, run the <strong>GenerateHtml</strong> file as a Java application (<strong>Run
							as... &gt; Java Application</strong> from the context menu). This will execute the template <strong>MyWebsite</strong> and print
							the result to the console.
						</p>
						</section>
						<!--  section -->
						<section id="templates_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							This is the grammar of the templates DSL:
							 
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.template.Template 
    with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

generate template "http://www.xtext.org/template/Template"
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase

TemplateFile:
  '&lt;!--''&laquo;' 
    ('package' package=QualifiedName)? 
    imports+=Import* 
    params+=Parameter* 
    body=RichString;

Import:
  'import' importedNamespace=QualifiedName;

Parameter:
  annotations+=XAnnotation* 
  'param' type=JvmTypeReference? name=ID ('=' defaultexp=XExpression)?;

RichString returns xbase::XBlockExpression:
  {RichString}  
  expressions+=RichStringLiteral 
  (expressions+=RichStringPart expressions+=RichStringLiteral)*;

RichStringLiteral returns xbase::XStringLiteral:
  {RichStringLiteral} value=TEXT;

RichStringPart returns xbase::XExpression:
  XExpressionInsideBlock |
  RichStringForLoop |
  RichStringIf;

RichStringForLoop returns xbase::XForLoopExpression:
  {RichStringForLoop}
  "FOR" declaredParam=JvmFormalParameter ':' forExpression=XExpression
    eachExpression=RichString
  "ENDFOR";

RichStringIf returns xbase::XIfExpression:
  {RichStringIf}
  "IF" if=XExpression
    then=RichString
  (else=RichStringElseIf | "ELSE" else=RichString)?
  "ENDIF";
  
RichStringElseIf returns xbase::XIfExpression:
  {RichStringIf}
  "ELSEIF" if=XExpression
    then=RichString
  (else=RichStringElseIf | "ELSE" else=RichString)?;

terminal TEXT : '&raquo;' (!'&laquo;')* (EOF|'&laquo;');</pre>
							<p>
						</p>
						<p>
							It becomes quite straightforward once you have understood the escaping. Have a look at the last rule
							<strong>TEXT</strong> first: It says that a text starts with a closing French quote and ends with an opening quote or 
							the end of the file. By inverting opening and closing quotes we mark up text instead of expressions.
						</p>
						<p>
							A <strong>TemplateFile</strong> starts with a comment and switches to the expression mode for the preamble part consisting 
							of the package declaration, the imports and the parameter declaration. The body is a <strong>RichString</strong>, which
							is an alternating sequence of <strong>RichStringLiterals</strong> and <strong>RichStringPart</strong>. The <strong>RichStringLiterals</strong>
							is essentially a text block (in inverted French quotes). The <strong>RichStringPart</strong> is either an Xbase expression,
							a <strong>RichStringForLoop</strong> or a <strong>RichStringIf</strong>. The latter inherit from the Xbase expressions with the same name 
							to reuse as much of the Xbase infrastructure as possible. The rest should be easy.
						</p>
						</section>
						<!--  section -->
						<section id="templates_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							Each <strong>TemplateFile</strong> is compiled to a Java class with a <code class="prettyprint lang-java">generate</code> method that takes a lambda
							expression as a parameter. The lambda expression is called to initialize the template's properties, by 
							handling the template itself as an argument. This comes along nicely, especially when called from Xtend.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-templates linenums">
&lt;!--&laquo;
  ...
&raquo;--&gt;</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public class MyWebsite {
...  
  public String generate(final Procedure1&lt;MyWebsite&gt; init) {
    if (init != null)
      init.apply(this);
    String result = generate().toString();
    // remove leading --&gt;
    result = result.replaceAll("^--&gt;\\n","");
    // trim multi-newline to single newline
    result = result.replaceAll("\\n\\s*\\n","\n");
    return result;
    
  }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The corresponding code in the <abbr title="org.xtext.template.jvmmodel.TemplateJvmModelInferrer">TemplateJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/jvmmodel/TemplateJvmModelInferrer.xtend">(src)</a> is:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TemplateJvmModelInferrer extends AbstractModelInferrer {
...
     def dispatch void infer(TemplateFile element, 
                             IJvmDeclaredTypeAcceptor acceptor, 
                             boolean isPreIndexingPhase) {
       val simpleName = element.eResource.URI.trimFileExtension.lastSegment
       val qualifiedName = if(element.getPackage != null) 
           element.getPackage + "." + simpleName
         else 
           simpleName
    val javaClass = element.toClass(qualifiedName)
       acceptor.accept(javaClass).initializeLater [
...
      // generate a method accepting an initializer lambda expression
      members += element.toMethod("generate", 
          element.newTypeRef(typeof(String))) [
        parameters += element.toParameter(
          "init", 
          element.newTypeRef(typeof(Procedures$Procedure1), 
              newTypeRef(javaClass))
        )
        body = [
          append('''
            if (init != null)
              init.apply(this);
            String result = generate().toString();
            // remove leading --&gt;
            result = result.replaceAll("^--&gt;\\n","");
            // trim multi-newline to single newline
            result = result.replaceAll("\\n\\s*\\n","\n");
            return result;
          ''')
        ]
...</pre>
							<p>
						</p>
						<p>
							Each <strong>Parameter</strong> becomes a Java property, i.e. a field with a getter and a setter.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-templates linenums">
param title = "No Title"</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
private String title = "No Title";

public void setTitle(final String title) {
  this.title = title;
}

public String getTitle() {
  return this.title;
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							In the inferrer, note that we derive the property's type in three steps: Take the declared one, if there is none, 
							derive it from the initializer using the injected <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/typing/ITypeProvider.html"><abbr title="org.eclipse.xtext.xbase.typing.ITypeProvider">ITypeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/ITypeProvider.java">(src)</a>
							and if even that fails, use <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> as default.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension ITypeProvider
...
for (param : element.params) {
  val type = param.type 
    ?: param.defaultexp?.type 
    ?: element.newTypeRef(typeof(String))
  members += param.toField(param.name, type) [
    if (param.defaultexp != null)
      initializer = param.defaultexp
  ]
  members += param.toSetter(param.name, type)
  members += param.toGetter(param.name, type)
}</pre>
							<p>
						</p>
						<p>
							The body of the template is compiled into a big private <code class="prettyprint lang-java">generate()</code> method. We skip
							the inferrer code here, as it is straightforward. But we had to extend the compiler to support rich
							strings and the new <code class="prettyprint lang-templates">FOR</code> loop our new control structures. This is described in the 
							<a href="#templates_compiler">next section</a>.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-templates linenums">
&raquo;&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;&laquo;title&raquo;&lt;/title&gt;
  &lt;meta name="viewport" content="width=device-width, initial-sca..."&gt;
  &lt;meta name="description"
    content="&laquo;description&raquo;"&gt;
  &lt;meta name="author" content="&laquo;...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
private CharSequence generate() {
  StringBuilder _appendable = new StringBuilder();
  _appendable.append(ObjectExtensions.operator_elvis(
    "--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n\t&lt;meta...",
    ""));
  _appendable.append(ObjectExtensions.operator_elvis(
    this.title,""));
  // appends galore
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="templates_compiler" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Extending the Compiler</h2>
						<p>
							We have added additional expressions to Xbase, so we have to tell the compiler how to translate them
							to Java. The <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/XbaseCompiler.html"><abbr title="org.eclipse.xtext.xbase.compiler.XbaseCompiler">XbaseCompiler</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/XbaseCompiler.java">(src)</a> has a method 
							<code class="prettyprint lang-java">doInternalToJavaStatement</code> that dispatches the compilation with regard to the type of the
							current expression. This is where we have to hook in with our <abbr title="org.xtext.template.jvmmodel.TemplateCompiler">TemplateCompiler</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/jvmmodel/TemplateCompiler.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TemplateCompiler extends XbaseCompiler {
  
  override protected doInternalToJavaStatement(XExpression expr, 
                                               ITreeAppendable it, 
                                               boolean isReferenced) {
    switch expr {
      RichString : {
...   }
      RichStringForLoop : {
...   }
      default :
        super.doInternalToJavaStatement(expr, it, isReferenced)
    }
  }
...</pre>
							<p>
						</p>
						<p>
							For a <strong>RichString</strong>, we declare a variable <code class="prettyprint lang-xtend">_appendable</code> of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html"><abbr title="java.lang.StringBuilder">StringBuilder</abbr></a>
							and append the results of all its evaluated expressions. Remember from the grammar that every second expression
							is a <strong>RichStringPart</strong> which can be <code class="prettyprint lang-xtend">null</code>, so we use the 'elvis operator' <code class="prettyprint lang-xbase">?:</code>
							to insert an empty string in this case.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
RichString : {
  val name = declareVariable(expr, '_appendable')
  newLine
  append('''
    StringBuilder &laquo;name&raquo; = new StringBuilder();
  ''')
  for (nestedExpression : expr.expressions) {
    nestedExpression.internalToJavaStatement(it, true)
    newLine
    append('''&laquo;name&raquo;.append(ObjectExtensions.operator_elvis(''')
    nestedExpression.internalToJavaExpression(it)
    append(',""));')
  }
}</pre>
							<p>
						</p>
						<p>
							As our <strong>RichStringLiteral</strong> inherits from <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XStringLiteral.html"><abbr title="org.eclipse.xtext.xbase.XStringLiteral">XStringLiteral</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XStringLiteral.java">(src)</a>, it does not
							need any special treatment. The same holds for <strong>RichStringIf</strong> and <strong>RichStringElseIif</strong>. The <strong>RichStringForLoop</strong>
							requires special treatment, because as opposed to the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XForLoopExpression.html"><abbr title="org.eclipse.xtext.xbase.XForLoopExpression">XForLoopExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XForLoopExpression.java">(src)</a>
							that always returns <code class="prettyprint lang-java">null</code>, we want it to return a concatenation of its results. This looks
							like
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
RichStringForLoop : {
  expr.forExpression.internalToJavaStatement(it, true)
  val paramType = typeProvider.getTypeForIdentifiable(expr.declaredParam)
  val name = declareVariable(expr, '_forLoopResult')
  newLine
  append('''
    StringBuilder &laquo;name&raquo; = new StringBuilder();
    for (final ''')
  serialize(paramType, expr, it);
  append(''' &laquo;declareVariable(expr.declaredParam, 
      makeJavaIdentifier(expr.declaredParam.name))&raquo; : ''')
  internalToJavaExpression(expr.forExpression, it)
  append(") {").increaseIndentation
    expr.eachExpression.internalToJavaStatement(it, true)
    newLine
    append('''&laquo;name&raquo;.append(''')
    expr.eachExpression.internalToJavaExpression(it)
    append(');')
  decreaseIndentation.newLine.append("}")
}</pre>
							<p>
						</p>
						<p>
							The compiler now knows how to handle the new expressions in a statement context. In addition, we have
							to teach it to compile them in an expression context. This is what the second method does:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override protected internalToConvertedExpression(XExpression obj, 
                                                 ITreeAppendable it) {
  if (hasName(obj))
    append(getName(obj))
  else 
    super.internalToConvertedExpression(obj, it) 
}</pre>
							<p>
						</p>
						<p>
							As usual, we have to bind our <abbr title="org.xtext.template.jvmmodel.TemplateCompiler">TemplateCompiler</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/jvmmodel/TemplateCompiler.xtend">(src)</a> in the 
							<abbr title="org.xtext.template.TemplateRuntimeModule">TemplateRuntimeModule</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/TemplateRuntimeModule.java">(src)</a> in order to be picked up as the 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/XbaseCompiler.html"><abbr title="org.eclipse.xtext.xbase.compiler.XbaseCompiler">XbaseCompiler</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/XbaseCompiler.java">(src)</a> in the context of our language.
						</p>
						</section>
						<!--  section -->
						<section id="templates_typeProvider" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">TypeProvider</h2>
						<p>
							The type system has to know what types our new expressions have. This is the job of the 
							<abbr title="org.xtext.template.jvmmodel.TemplateTypeProvider">TemplateTypeProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/jvmmodel/TemplateTypeProvider.xtend">(src)</a>: <strong>RichString</strong> becomes a 
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html"><abbr title="java.lang.StringBuilder">StringBuilder</abbr></a>. As opposed to its super type 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XForLoopExpression.html"><abbr title="org.eclipse.xtext.xbase.XForLoopExpression">XForLoopExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XForLoopExpression.java">(src)</a> a <strong>RichStringForLoop</strong> is of type
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html"><abbr title="java.lang.StringBuilder">StringBuilder</abbr></a> as well. The for-loop's body is expected to have a type, as the results
							must be concatenatable, which is different from Xbase's for-loop.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Singleton
class TemplateTypeProvider extends XbaseTypeProvider {
  
  @Inject TypeReferences typeReferences
  
  def dispatch type(RichString string, 
                    JvmTypeReference typeRef, 
                    boolean isRawTypes) {
    typeReferences.getTypeForName(typeof(StringBuilder), string)
  }
  
  def dispatch type(RichStringForLoop string, 
                    JvmTypeReference typeRef, 
                    boolean isRawTypes) {
    typeReferences.getTypeForName(typeof(StringBuilder), string)
  }
  
  def dispatch expectedType(RichStringForLoop container, 
                            EReference reference, 
                            int index, boolean rawType) {
    if (reference == XFOR_LOOP_EXPRESSION__EACH_EXPRESSION)
      typeReferences.getTypeForName(typeof(Object), container)
    else
      super._expectedType(container,reference,index, rawType)
  }
}</pre>
							<p>
						</p>
						<p>
							Like the compiler, we have to bind this implementation in our 
							runtime module <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/TemplateRuntimeModule.java">(src)</a> as well.
						</p>
						</section>
						<!--  section -->
						<section id="templates_valueConverter" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Value Converter</h2>
						<p>
							The <strong>RichStringLiterals</strong> still have the French quotes around their values. As we do not want to see 
							them in the output, we
							have implemented the <abbr title="org.xtext.template.TemplateValueConverterService">TemplateValueConverterService</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/TemplateValueConverterService.xtend">(src)</a> and bound it in the 
							runtime module <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template/src/org/xtext/template/TemplateRuntimeModule.java">(src)</a>.
						</p>
						</section>
						<!--  section -->
						<section id="templates_contentAssist" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Content Assist</h2>
						<p>
							The French quotes are not easy to type on every keyboard. We have adapted content assist to insert them
							when the cursor is inside a TEXT terminal:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class TemplateProposalProvider 
    extends AbstractTemplateProposalProvider {
  @Override
  public void complete_TEXT(EObject model, 
                            RuleCall ruleCall, 
                            ContentAssistContext context,
      ICompletionProposalAcceptor acceptor) {
    acceptor.accept(new CompletionProposal("&laquo;&raquo;", 
        context.getOffset(), 0, 1));
  }
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="templates_highlighting" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Syntax Highlighting</h2>
						<p>
							Sometimes it is hard to see whether you are in text or expression mode. To give the user better feedback,
							we have changed the way the text is highlighted. This customization consists of two parts: Add new highlighting
							styles in the <abbr title="org.xtext.template.ui.highlighting.TemplateHighlightingConfiguration">TemplateHighlightingConfiguration</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template.ui/src/org/xtext/template/ui/highlighting/TemplateHighlightingConfiguration.xtend">(src)</a> and apply
							them to the text in the <abbr title="org.xtext.template.ui.highlighting.TemplateHighlightingCalculator">TemplateHighlightingCalculator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.template.ui/src/org/xtext/template/ui/highlighting/TemplateHighlightingCalculator.xtend">(src)</a>. As
							this is rather extensively covered in the <a href="documentation.html#highlighting">Xtext documentation</a>, we 
							skip a deeper explanation here.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="tortoise" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Little Tortoise
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Do you remember the programming language <a href="http://en.wikipedia.org/wiki/Logo_%28programming_language%29">Logo</a>? 
							Logo was used in computer science classes to teach children how to program. In fact, it was a adaptation of LISP!
							But the remarkable part was the so-called <strong>turtle</strong>, a graphical cursor that can be given commands to move and turn, 
							thereby drawing lines.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/tortoise_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							The goal is a language to control a turtle drawing an image. Technically, this example will teach you how to adapt 
							and use the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a> for your own languages.
						</p>
						<!--  section -->
						<section id="tortoise_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							We have built a language that allows to define <strong>Programs</strong> and <strong>SubPrograms</strong>. Each of these has a body,
							which can contain any number of expressions. In addition to the standard Xbase expressions, we are able
							to issue commands to the tortoise. Here is an example explaining the concepts in comments:
							 
							</p>
							<pre class="prettyprint lang-tortoise linenums">
// Program: Haus vom Nikolaus
begin
  val length = 150                // local variable
  val diagonal = length * sqrt(2) // all Math.* methods are available
  lineWidth = 2                   // assignment of a property
  square(length)                  // call to a SubProgram
  turnRight(45)                   // call to a command method
  lineColor = blue                // all ColorConstants.* are available
  forward(diagonal)
  turnLeft(90)
  lineColor = red
  forward(diagonal / 2)
  turnLeft(90)
  forward(diagonal / 2)
  turnLeft(90)
  lineColor = blue
  forward(diagonal)
end  // main program

sub square           // a subprogram
  int length         // parameter
begin
  for (i : 1..4) {   // loop-expression from Xbase 
    forward(length)
    turnRight(90) 
  }
end  // sub square</pre>
							<p>
						</p>
						<p>
							The main trick about our solution is to <strong>not</strong> bake in the turtle commands into the language itself, but
							define it in the runtime library. This way, the language stays as slim as can be and additions can be easily
							added without the need to regenerate the whole language infrastructure.
						</p>
						<p>
							The core of the runtime library is the class <abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>. You can
							think of it as of our only domainmodel class: It keeps the current state of the tortoise and allows 
							modifying it using methods. Here is an excerpt of its code:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Tortoise {
  double angle
  double x
  double y
  @Property int delay = 200

  boolean isPaint = true
  @Property int lineWidth
  @Property Color lineColor

  List&lt;ITortoiseEvent$Listener&gt; listeners = newArrayList()
...</pre>
							<p>
						</p>
						<p>
							When a method changes the state of the tortoise, an event is thrown. These events are consumed
							by a GEF based view and turned into animations of a <abbr title="org.xtext.tortoiseshell.lib.view.TortoiseFigure">TortoiseFigure</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/view/TortoiseFigure.xtend">(src)</a>. This
							loose coupling of model and view allows for easier testing.
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the runtime Eclipse, open the <strong>Tortoise View</strong> <strong>(Window &gt; Show View &gt; Other &gt; Xtext &gt; TortoiseView)</strong>.
							Then open one of the example files in <strong>org.eclipse.xtext.tortoiseshell.examples</strong>. 
							The <strong>Program</strong> is interpreted on editor activation and on save. An additional toggle button <strong>Step Mode</strong> 
							in the <strong>Tortoise View</strong> allows to execute the code live from the editor up to the caret's current line.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/Pythagoras.png" alt="Tortoise takes a rest after running the Pythagoras example" width="651" height="546">
							</div>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar is very short. Once again, we inherit from the Xbase language to have nice Java integration
							and rich expressions. A user can define a <strong>Program</strong>, which can have <strong>SubPrograms</strong> with parameters. The 
							<strong>Executable</strong> rule is never called, but defines a common supertype for <strong>Program</strong> and <strong>SubProgram</strong> that 
							will hold their common member <code class="prettyprint lang-xtend">body</code>. A <strong>Body</strong> is an <strong>XBlockExpression</strong> from Xbase, but with the 
							keywords <code class="prettyprint lang-xtend">begin</code> and <code class="prettyprint lang-xtend">end</code> instead of the curly braces.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.tortoiseshell.TortoiseShell
  with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase"
generate tortoiseShell "http://www.xtext.org/tortoiseshell/TortoiseShell"

Program :
  body=Body
  subPrograms+=SubProgram*;
  
SubProgram:
  'sub' name=ValidID
  (parameters += FullJvmFormalParameter)*
  body=Body;

Body returns XBlockExpression:
  {XBlockExpression}
  'begin'
  (expressions+=XExpressionInsideBlock ';'?)*
  'end';
  
Executable:
  Program | SubProgram;</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							With the tortoise commands defined as methods in the runtime library class 
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>, we have to infer a Java class that inherits from this. 
							Within this class, we create a method for each <strong>Program</strong> and <strong>SubProgram</strong>. The resulting code looks 
							like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TortoiseShellJvmModelInferrer extends AbstractModelInferrer {
  public static val INFERRED_CLASS_NAME = 'MyTortoiseProgram'
  
  @Inject extension JvmTypesBuilder
  
  def dispatch void infer(Program program, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    acceptor.accept(program.toClass(INFERRED_CLASS_NAME)).initializeLater [
      superTypes += program.newTypeRef(typeof(Tortoise))
      if(program.body != null)
        members += program.toMethod("main", 
            program.newTypeRef(Void::TYPE)) [
          body = program.body
        ]
      for(subProgram: program.subPrograms)
        members += subProgram.toMethod(subProgram.name, 
            program.newTypeRef(Void::TYPE)) [
          for(functionParameter: subProgram.parameters)
            parameters += functionParameter.toParameter(
                functionParameter.name, functionParameter.parameterType)
          body = subProgram.body
        ]
    ]
  }
 }</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_interpreter" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Interpreter</h2>
						<p>
							The Xbase language library does not only provide a compiler that generates Java code, but also an 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html">interpreter</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>. This has been adapted 
							to execute our <strong>Programs</strong>.
						</p>
						<p>
							After all an interpreter is just a big visitor. For each expression type, it has an evaluation method,
							that recursively calls the evaluation methods for the subexpressions for its arguments. The methods
							also pass an execution context storing all temporary state such as local variables.
						</p>
						<p>
							The first thing we have to cope with is the mixture of existing Java methods (from the super class
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>) and inferred ones. While the former are evaluated
							via Java reflection, we need special treatment for the latter. The idea is to bind an instance of 
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a> to <code class="prettyprint lang-xtend">this</code> and intercept calls to the inferred 
							methods to execute them directly. This is accomplished by overriding the method
						</p>
						<p>
							<code class="prettyprint lang-xtend">invokeOperation</code>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension IJvmModelAssociations
 
override protected invokeOperation(JvmOperation operation, 
                                   Object receiver, 
                                   List&lt;Object&gt; argumentValues) {
  val executable = operation.sourceElements.head
  if(executable instanceof Executable) {
    val context = createContext
    context.newValue(XbaseScopeProvider::THIS, tortoise)
    var index = 0
    for(param: operation.parameters) {
      context.newValue(QualifiedName::create(param.name), 
                       argumentValues.get(index))
      index = index + 1  
    }
    evaluate((executable as Executable).body, context, 
             CancelIndicator::NullImpl)
  } else {
    super.invokeOperation(operation, receiver, argumentValues)
  }
}</pre>
							<p>
						</p>
						<p>
							One thing you have to know about the Java inferrence is that when creating Java elements using the
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder">JvmTypesBuilder</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a>, the infrastructure stores the information which 
							elements have been inferred from which source elements. To navigate these traces, we use the Xbase service
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations">IJvmModelAssociations</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java">(src)</a>. So to detect whether a 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html"><abbr title="org.eclipse.xtext.common.types.JvmOperation">JvmOperation</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a> is inferred, we check whether it has a source element.
							If so, we have to setup an execution context binding <code class="prettyprint lang-xtend">this</code> and the parameters as local variables and then 
							execute the method's body using the interpreter.
						</p>
						<p>
							To start the interpretation we have to do almost the same: Setup the execution context and then evaluate
							the <strong>Program's</strong> body. The respective code is
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override run(Tortoise tortoise, EObject program, int stopAtLine) {
  if(tortoise != null &amp;&amp; program != null) {
    this.tortoise = tortoise
    this.stopAtLine = stopAtLine
    try {
      program.jvmElements.filter(typeof(JvmOperation)).head
        ?.invokeOperation(null, Collections::emptyList)
    } catch (StopLineReachedException exc) {
      // ignore
    }
  }
}</pre>
							<p>
						</p>
						<p>
							The <abbr title="org.xtext.tortoiseshell.interpreter.StopLineReachedException">StopLineReachedException</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/interpreter/TortoiseShellInterpeter.xtend">(src)</a> is part of the <strong>Step Mode</strong>.
							It is thrown when the execution reaches the line <code class="prettyprint lang-xtend">stopAtLine</code>, thus terminating the current execution.
							The throwing code is
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override protected internalEvaluate(XExpression expression, 
                                    IEvaluationContext context, 
                                    CancelIndicator indicator) {
  val line = NodeModelUtils::findActualNodeFor(expression)?.startLine
  if(line-1 == stopAtLine)
    throw new StopLineReachedException
  super.internalEvaluate(expression, context, indicator)
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_additons" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Literal Classes</h2>
						<p>
							To make the static methods and fields of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Math.html"><abbr title="java.lang.Math">Math</abbr></a> and <a href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/draw2d/ColorConstants.html"><abbr title="org.eclipse.draw2d.ColorConstants">ColorConstants</abbr></a>
							callable directly, we provided the <abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellExtensionClassNameProvider">TortoiseShellExtensionClassNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/scoping/TortoiseShellExtensionClassNameProvider.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TortoiseShellExtensionClassNameProvider extends 
  StaticImplicitMethodsFeatureForTypeProvider$ExtensionClassNameProvider {

  override protected computeLiteralClassNames() {
    super.computeLiteralClassNames =&gt; [
      it += "java.lang.Math"
      it += "org.eclipse.draw2d.ColorConstants" 
    ]  
  }
}</pre>
							<p>
						</p>
						<p>
							To overcome a small issue in the interpreter we also had to implement the 
							<abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellIdentifiableSimpleNameProvider">TortoiseShellIdentifiableSimpleNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/scoping/TortoiseShellIdentifiableSimpleNameProvider.xtend">(src)</a>.
						</p>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtext</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
	<script type="text/javascript" src="google-code-prettify/lang-common.js"></script><script type="text/javascript">
		registerLanguage('grammar|import|generate|terminal|enum|returns|with|hidden|as|current|fragment|EOF', 'xtext');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'xbase');
		registerLanguage('module|var|auto-inject|auto|inject|import|true|false', 'mwe2');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|package|import', 'mongobeans');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|sub|begin|end', 'tortoise');
		registerLanguage('inject|extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|GET|POST|PUT|DELETE|HEAD|import|when', 'routing');
		registerLanguage('super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'scripting');
		registerLanguage('to-instance|bind|to|mixin|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'guice');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|package|import|param|task|depends', 'builddsl');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|package|import|param|FOR|ENDFOR|IF|ELSE|ENDIF', 'templates');
	</script>
</body>
</html>
